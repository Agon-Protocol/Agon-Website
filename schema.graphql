schema {
  query: query_root
  subscription: subscription_root
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

scalar _coin

"Boolean expression to compare columns of type \"_coin\". All fields are combined with logical 'AND'."
input _coin_comparison_exp {
  _eq: _coin
  _gt: _coin
  _gte: _coin
  _in: [_coin!]
  _is_null: Boolean
  _lt: _coin
  _lte: _coin
  _neq: _coin
  _nin: [_coin!]
}

scalar _dec_coin

"Boolean expression to compare columns of type \"_dec_coin\". All fields are combined with logical 'AND'."
input _dec_coin_comparison_exp {
  _eq: _dec_coin
  _gt: _dec_coin
  _gte: _dec_coin
  _in: [_dec_coin!]
  _is_null: Boolean
  _lt: _dec_coin
  _lte: _dec_coin
  _neq: _dec_coin
  _nin: [_dec_coin!]
}

scalar _text

"Boolean expression to compare columns of type \"_text\". All fields are combined with logical 'AND'."
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"columns and relationships of \"account\""
type account {
  "An array relationship"
  account_balance_histories("distinct select on columns" distinct_on: [account_balance_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_history_order_by!] "filter the rows returned" where: account_balance_history_bool_exp): [account_balance_history!]!
  "An aggregate relationship"
  account_balance_histories_aggregate("distinct select on columns" distinct_on: [account_balance_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_history_order_by!] "filter the rows returned" where: account_balance_history_bool_exp): account_balance_history_aggregate!
  "An array relationship"
  account_balances("distinct select on columns" distinct_on: [account_balance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_order_by!] "filter the rows returned" where: account_balance_bool_exp): [account_balance!]!
  "An aggregate relationship"
  account_balances_aggregate("distinct select on columns" distinct_on: [account_balance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_order_by!] "filter the rows returned" where: account_balance_bool_exp): account_balance_aggregate!
  address: String!
  "An array relationship"
  delegation_rewards("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): [delegation_reward!]!
  "An aggregate relationship"
  delegation_rewards_aggregate("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): delegation_reward_aggregate!
  "An array relationship"
  delegations("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): [delegation!]!
  "An aggregate relationship"
  delegations_aggregate("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): delegation_aggregate!
  "An array relationship"
  proposal_deposits("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): [proposal_deposit!]!
  "An aggregate relationship"
  proposal_deposits_aggregate("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): proposal_deposit_aggregate!
  "An array relationship"
  proposal_votes("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): [proposal_vote!]!
  "An aggregate relationship"
  proposal_votes_aggregate("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): proposal_vote_aggregate!
  "An array relationship"
  proposals("distinct select on columns" distinct_on: [proposal_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_order_by!] "filter the rows returned" where: proposal_bool_exp): [proposal!]!
  "An aggregate relationship"
  proposals_aggregate("distinct select on columns" distinct_on: [proposal_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_order_by!] "filter the rows returned" where: proposal_bool_exp): proposal_aggregate!
  "An array relationship"
  redelegations("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): [redelegation!]!
  "An aggregate relationship"
  redelegations_aggregate("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): redelegation_aggregate!
  "An array relationship"
  unbonding_delegations("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): [unbonding_delegation!]!
  "An aggregate relationship"
  unbonding_delegations_aggregate("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): unbonding_delegation_aggregate!
  "An array relationship"
  validator_infos("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): [validator_info!]!
  "An aggregate relationship"
  validator_infos_aggregate("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): validator_info_aggregate!
  "An object relationship"
  vesting_account: vesting_account
}

"aggregated selection of \"account\""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"aggregate fields of \"account\""
type account_aggregate_fields {
  count(columns: [account_select_column!] distinct: Boolean): Int!
  max: account_max_fields
  min: account_min_fields
}

"columns and relationships of \"account_balance\""
type account_balance {
  "An object relationship"
  account: account!
  address: String!
  "An object relationship"
  block: block
  coins: _coin!
  height: bigint!
  "A computed field, executes function \"account_balance_tokens_prices\""
  tokens_prices("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): [token_price!]
}

"aggregated selection of \"account_balance\""
type account_balance_aggregate {
  aggregate: account_balance_aggregate_fields
  nodes: [account_balance!]!
}

"aggregate fields of \"account_balance\""
type account_balance_aggregate_fields {
  avg: account_balance_avg_fields
  count(columns: [account_balance_select_column!] distinct: Boolean): Int!
  max: account_balance_max_fields
  min: account_balance_min_fields
  stddev: account_balance_stddev_fields
  stddev_pop: account_balance_stddev_pop_fields
  stddev_samp: account_balance_stddev_samp_fields
  sum: account_balance_sum_fields
  var_pop: account_balance_var_pop_fields
  var_samp: account_balance_var_samp_fields
  variance: account_balance_variance_fields
}

"order by aggregate values of table \"account_balance\""
input account_balance_aggregate_order_by {
  avg: account_balance_avg_order_by
  count: order_by
  max: account_balance_max_order_by
  min: account_balance_min_order_by
  stddev: account_balance_stddev_order_by
  stddev_pop: account_balance_stddev_pop_order_by
  stddev_samp: account_balance_stddev_samp_order_by
  sum: account_balance_sum_order_by
  var_pop: account_balance_var_pop_order_by
  var_samp: account_balance_var_samp_order_by
  variance: account_balance_variance_order_by
}

"aggregate avg on columns"
type account_balance_avg_fields {
  height: Float
}

"order by avg() on columns of table \"account_balance\""
input account_balance_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"account_balance\". All fields are combined with a logical 'AND'."
input account_balance_bool_exp {
  _and: [account_balance_bool_exp!]
  _not: account_balance_bool_exp
  _or: [account_balance_bool_exp!]
  account: account_bool_exp
  address: String_comparison_exp
  block: block_bool_exp
  coins: _coin_comparison_exp
  height: bigint_comparison_exp
  tokens_prices: token_price_bool_exp
}

"columns and relationships of \"account_balance_history\""
type account_balance_history {
  "An object relationship"
  account: account!
  address: String!
  balance: _coin!
  commission: _dec_coin!
  delegated: _coin!
  redelegating: _coin!
  reward: _dec_coin!
  timestamp: timestamp
  "A computed field, executes function \"account_balance_history_tokens_prices\""
  token_prices_history("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): [token_price_history!]
  unbonding: _coin!
}

"aggregated selection of \"account_balance_history\""
type account_balance_history_aggregate {
  aggregate: account_balance_history_aggregate_fields
  nodes: [account_balance_history!]!
}

"aggregate fields of \"account_balance_history\""
type account_balance_history_aggregate_fields {
  count(columns: [account_balance_history_select_column!] distinct: Boolean): Int!
  max: account_balance_history_max_fields
  min: account_balance_history_min_fields
}

"order by aggregate values of table \"account_balance_history\""
input account_balance_history_aggregate_order_by {
  count: order_by
  max: account_balance_history_max_order_by
  min: account_balance_history_min_order_by
}

"Boolean expression to filter rows from the table \"account_balance_history\". All fields are combined with a logical 'AND'."
input account_balance_history_bool_exp {
  _and: [account_balance_history_bool_exp!]
  _not: account_balance_history_bool_exp
  _or: [account_balance_history_bool_exp!]
  account: account_bool_exp
  address: String_comparison_exp
  balance: _coin_comparison_exp
  commission: _dec_coin_comparison_exp
  delegated: _coin_comparison_exp
  redelegating: _coin_comparison_exp
  reward: _dec_coin_comparison_exp
  timestamp: timestamp_comparison_exp
  token_prices_history: token_price_history_bool_exp
  unbonding: _coin_comparison_exp
}

"aggregate max on columns"
type account_balance_history_max_fields {
  address: String
  timestamp: timestamp
}

"order by max() on columns of table \"account_balance_history\""
input account_balance_history_max_order_by {
  address: order_by
  timestamp: order_by
}

"aggregate min on columns"
type account_balance_history_min_fields {
  address: String
  timestamp: timestamp
}

"order by min() on columns of table \"account_balance_history\""
input account_balance_history_min_order_by {
  address: order_by
  timestamp: order_by
}

"Ordering options when selecting data from \"account_balance_history\"."
input account_balance_history_order_by {
  account: account_order_by
  address: order_by
  balance: order_by
  commission: order_by
  delegated: order_by
  redelegating: order_by
  reward: order_by
  timestamp: order_by
  unbonding: order_by
}

"select columns of table \"account_balance_history\""
enum account_balance_history_select_column {
  "column name"
  address
  "column name"
  balance
  "column name"
  commission
  "column name"
  delegated
  "column name"
  redelegating
  "column name"
  reward
  "column name"
  timestamp
  "column name"
  unbonding
}

"aggregate max on columns"
type account_balance_max_fields {
  address: String
  height: bigint
}

"order by max() on columns of table \"account_balance\""
input account_balance_max_order_by {
  address: order_by
  height: order_by
}

"aggregate min on columns"
type account_balance_min_fields {
  address: String
  height: bigint
}

"order by min() on columns of table \"account_balance\""
input account_balance_min_order_by {
  address: order_by
  height: order_by
}

"Ordering options when selecting data from \"account_balance\"."
input account_balance_order_by {
  account: account_order_by
  address: order_by
  block: block_order_by
  coins: order_by
  height: order_by
}

"select columns of table \"account_balance\""
enum account_balance_select_column {
  "column name"
  address
  "column name"
  coins
  "column name"
  height
}

"aggregate stddev on columns"
type account_balance_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"account_balance\""
input account_balance_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type account_balance_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"account_balance\""
input account_balance_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type account_balance_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"account_balance\""
input account_balance_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type account_balance_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"account_balance\""
input account_balance_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type account_balance_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"account_balance\""
input account_balance_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type account_balance_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"account_balance\""
input account_balance_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type account_balance_variance_fields {
  height: Float
}

"order by variance() on columns of table \"account_balance\""
input account_balance_variance_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"account\". All fields are combined with a logical 'AND'."
input account_bool_exp {
  _and: [account_bool_exp!]
  _not: account_bool_exp
  _or: [account_bool_exp!]
  account_balance_histories: account_balance_history_bool_exp
  account_balances: account_balance_bool_exp
  address: String_comparison_exp
  delegation_rewards: delegation_reward_bool_exp
  delegations: delegation_bool_exp
  proposal_deposits: proposal_deposit_bool_exp
  proposal_votes: proposal_vote_bool_exp
  proposals: proposal_bool_exp
  redelegations: redelegation_bool_exp
  unbonding_delegations: unbonding_delegation_bool_exp
  validator_infos: validator_info_bool_exp
  vesting_account: vesting_account_bool_exp
}

"aggregate max on columns"
type account_max_fields {
  address: String
}

"aggregate min on columns"
type account_min_fields {
  address: String
}

"Ordering options when selecting data from \"account\"."
input account_order_by {
  account_balance_histories_aggregate: account_balance_history_aggregate_order_by
  account_balances_aggregate: account_balance_aggregate_order_by
  address: order_by
  delegation_rewards_aggregate: delegation_reward_aggregate_order_by
  delegations_aggregate: delegation_aggregate_order_by
  proposal_deposits_aggregate: proposal_deposit_aggregate_order_by
  proposal_votes_aggregate: proposal_vote_aggregate_order_by
  proposals_aggregate: proposal_aggregate_order_by
  redelegations_aggregate: redelegation_aggregate_order_by
  unbonding_delegations_aggregate: unbonding_delegation_aggregate_order_by
  validator_infos_aggregate: validator_info_aggregate_order_by
  vesting_account: vesting_account_order_by
}

"select columns of table \"account\""
enum account_select_column {
  "column name"
  address
}

"columns and relationships of \"application_link\""
type application_link {
  application: String!
  "An array relationship"
  application_link_oracle_requests("distinct select on columns" distinct_on: [application_link_oracle_request_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_oracle_request_order_by!] "filter the rows returned" where: application_link_oracle_request_bool_exp): [application_link_oracle_request!]!
  "An aggregate relationship"
  application_link_oracle_requests_aggregate("distinct select on columns" distinct_on: [application_link_oracle_request_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_oracle_request_order_by!] "filter the rows returned" where: application_link_oracle_request_bool_exp): application_link_oracle_request_aggregate!
  creation_time: timestamp!
  height: bigint!
  id: Int!
  "An object relationship"
  profile: profile!
  result("JSON select path" path: String): jsonb
  state: String!
  user_address: String!
  username: String!
}

"aggregated selection of \"application_link\""
type application_link_aggregate {
  aggregate: application_link_aggregate_fields
  nodes: [application_link!]!
}

"aggregate fields of \"application_link\""
type application_link_aggregate_fields {
  avg: application_link_avg_fields
  count(columns: [application_link_select_column!] distinct: Boolean): Int!
  max: application_link_max_fields
  min: application_link_min_fields
  stddev: application_link_stddev_fields
  stddev_pop: application_link_stddev_pop_fields
  stddev_samp: application_link_stddev_samp_fields
  sum: application_link_sum_fields
  var_pop: application_link_var_pop_fields
  var_samp: application_link_var_samp_fields
  variance: application_link_variance_fields
}

"order by aggregate values of table \"application_link\""
input application_link_aggregate_order_by {
  avg: application_link_avg_order_by
  count: order_by
  max: application_link_max_order_by
  min: application_link_min_order_by
  stddev: application_link_stddev_order_by
  stddev_pop: application_link_stddev_pop_order_by
  stddev_samp: application_link_stddev_samp_order_by
  sum: application_link_sum_order_by
  var_pop: application_link_var_pop_order_by
  var_samp: application_link_var_samp_order_by
  variance: application_link_variance_order_by
}

"aggregate avg on columns"
type application_link_avg_fields {
  height: Float
  id: Float
}

"order by avg() on columns of table \"application_link\""
input application_link_avg_order_by {
  height: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"application_link\". All fields are combined with a logical 'AND'."
input application_link_bool_exp {
  _and: [application_link_bool_exp!]
  _not: application_link_bool_exp
  _or: [application_link_bool_exp!]
  application: String_comparison_exp
  application_link_oracle_requests: application_link_oracle_request_bool_exp
  creation_time: timestamp_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  profile: profile_bool_exp
  result: jsonb_comparison_exp
  state: String_comparison_exp
  user_address: String_comparison_exp
  username: String_comparison_exp
}

"aggregate max on columns"
type application_link_max_fields {
  application: String
  creation_time: timestamp
  height: bigint
  id: Int
  state: String
  user_address: String
  username: String
}

"order by max() on columns of table \"application_link\""
input application_link_max_order_by {
  application: order_by
  creation_time: order_by
  height: order_by
  id: order_by
  state: order_by
  user_address: order_by
  username: order_by
}

"aggregate min on columns"
type application_link_min_fields {
  application: String
  creation_time: timestamp
  height: bigint
  id: Int
  state: String
  user_address: String
  username: String
}

"order by min() on columns of table \"application_link\""
input application_link_min_order_by {
  application: order_by
  creation_time: order_by
  height: order_by
  id: order_by
  state: order_by
  user_address: order_by
  username: order_by
}

"columns and relationships of \"application_link_oracle_request\""
type application_link_oracle_request {
  "An object relationship"
  application_link: application_link!
  application_link_id: bigint!
  call_data("JSON select path" path: String): jsonb!
  client_id: String!
  height: bigint!
  id: Int!
  request_id: bigint!
  script_id: bigint!
}

"aggregated selection of \"application_link_oracle_request\""
type application_link_oracle_request_aggregate {
  aggregate: application_link_oracle_request_aggregate_fields
  nodes: [application_link_oracle_request!]!
}

"aggregate fields of \"application_link_oracle_request\""
type application_link_oracle_request_aggregate_fields {
  avg: application_link_oracle_request_avg_fields
  count(columns: [application_link_oracle_request_select_column!] distinct: Boolean): Int!
  max: application_link_oracle_request_max_fields
  min: application_link_oracle_request_min_fields
  stddev: application_link_oracle_request_stddev_fields
  stddev_pop: application_link_oracle_request_stddev_pop_fields
  stddev_samp: application_link_oracle_request_stddev_samp_fields
  sum: application_link_oracle_request_sum_fields
  var_pop: application_link_oracle_request_var_pop_fields
  var_samp: application_link_oracle_request_var_samp_fields
  variance: application_link_oracle_request_variance_fields
}

"order by aggregate values of table \"application_link_oracle_request\""
input application_link_oracle_request_aggregate_order_by {
  avg: application_link_oracle_request_avg_order_by
  count: order_by
  max: application_link_oracle_request_max_order_by
  min: application_link_oracle_request_min_order_by
  stddev: application_link_oracle_request_stddev_order_by
  stddev_pop: application_link_oracle_request_stddev_pop_order_by
  stddev_samp: application_link_oracle_request_stddev_samp_order_by
  sum: application_link_oracle_request_sum_order_by
  var_pop: application_link_oracle_request_var_pop_order_by
  var_samp: application_link_oracle_request_var_samp_order_by
  variance: application_link_oracle_request_variance_order_by
}

"aggregate avg on columns"
type application_link_oracle_request_avg_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by avg() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_avg_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"Boolean expression to filter rows from the table \"application_link_oracle_request\". All fields are combined with a logical 'AND'."
input application_link_oracle_request_bool_exp {
  _and: [application_link_oracle_request_bool_exp!]
  _not: application_link_oracle_request_bool_exp
  _or: [application_link_oracle_request_bool_exp!]
  application_link: application_link_bool_exp
  application_link_id: bigint_comparison_exp
  call_data: jsonb_comparison_exp
  client_id: String_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  request_id: bigint_comparison_exp
  script_id: bigint_comparison_exp
}

"aggregate max on columns"
type application_link_oracle_request_max_fields {
  application_link_id: bigint
  client_id: String
  height: bigint
  id: Int
  request_id: bigint
  script_id: bigint
}

"order by max() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_max_order_by {
  application_link_id: order_by
  client_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate min on columns"
type application_link_oracle_request_min_fields {
  application_link_id: bigint
  client_id: String
  height: bigint
  id: Int
  request_id: bigint
  script_id: bigint
}

"order by min() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_min_order_by {
  application_link_id: order_by
  client_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"Ordering options when selecting data from \"application_link_oracle_request\"."
input application_link_oracle_request_order_by {
  application_link: application_link_order_by
  application_link_id: order_by
  call_data: order_by
  client_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"select columns of table \"application_link_oracle_request\""
enum application_link_oracle_request_select_column {
  "column name"
  application_link_id
  "column name"
  call_data
  "column name"
  client_id
  "column name"
  height
  "column name"
  id
  "column name"
  request_id
  "column name"
  script_id
}

"aggregate stddev on columns"
type application_link_oracle_request_stddev_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by stddev() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_stddev_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate stddev_pop on columns"
type application_link_oracle_request_stddev_pop_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by stddev_pop() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_stddev_pop_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate stddev_samp on columns"
type application_link_oracle_request_stddev_samp_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by stddev_samp() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_stddev_samp_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate sum on columns"
type application_link_oracle_request_sum_fields {
  application_link_id: bigint
  height: bigint
  id: Int
  request_id: bigint
  script_id: bigint
}

"order by sum() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_sum_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate var_pop on columns"
type application_link_oracle_request_var_pop_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by var_pop() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_var_pop_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate var_samp on columns"
type application_link_oracle_request_var_samp_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by var_samp() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_var_samp_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"aggregate variance on columns"
type application_link_oracle_request_variance_fields {
  application_link_id: Float
  height: Float
  id: Float
  request_id: Float
  script_id: Float
}

"order by variance() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_variance_order_by {
  application_link_id: order_by
  height: order_by
  id: order_by
  request_id: order_by
  script_id: order_by
}

"Ordering options when selecting data from \"application_link\"."
input application_link_order_by {
  application: order_by
  application_link_oracle_requests_aggregate: application_link_oracle_request_aggregate_order_by
  creation_time: order_by
  height: order_by
  id: order_by
  profile: profile_order_by
  result: order_by
  state: order_by
  user_address: order_by
  username: order_by
}

"select columns of table \"application_link\""
enum application_link_select_column {
  "column name"
  application
  "column name"
  creation_time
  "column name"
  height
  "column name"
  id
  "column name"
  result
  "column name"
  state
  "column name"
  user_address
  "column name"
  username
}

"aggregate stddev on columns"
type application_link_stddev_fields {
  height: Float
  id: Float
}

"order by stddev() on columns of table \"application_link\""
input application_link_stddev_order_by {
  height: order_by
  id: order_by
}

"aggregate stddev_pop on columns"
type application_link_stddev_pop_fields {
  height: Float
  id: Float
}

"order by stddev_pop() on columns of table \"application_link\""
input application_link_stddev_pop_order_by {
  height: order_by
  id: order_by
}

"aggregate stddev_samp on columns"
type application_link_stddev_samp_fields {
  height: Float
  id: Float
}

"order by stddev_samp() on columns of table \"application_link\""
input application_link_stddev_samp_order_by {
  height: order_by
  id: order_by
}

"aggregate sum on columns"
type application_link_sum_fields {
  height: bigint
  id: Int
}

"order by sum() on columns of table \"application_link\""
input application_link_sum_order_by {
  height: order_by
  id: order_by
}

"aggregate var_pop on columns"
type application_link_var_pop_fields {
  height: Float
  id: Float
}

"order by var_pop() on columns of table \"application_link\""
input application_link_var_pop_order_by {
  height: order_by
  id: order_by
}

"aggregate var_samp on columns"
type application_link_var_samp_fields {
  height: Float
  id: Float
}

"order by var_samp() on columns of table \"application_link\""
input application_link_var_samp_order_by {
  height: order_by
  id: order_by
}

"aggregate variance on columns"
type application_link_variance_fields {
  height: Float
  id: Float
}

"order by variance() on columns of table \"application_link\""
input application_link_variance_order_by {
  height: order_by
  id: order_by
}

"columns and relationships of \"average_block_time_from_genesis\""
type average_block_time_from_genesis {
  average_time: numeric!
  height: bigint!
}

"aggregated selection of \"average_block_time_from_genesis\""
type average_block_time_from_genesis_aggregate {
  aggregate: average_block_time_from_genesis_aggregate_fields
  nodes: [average_block_time_from_genesis!]!
}

"aggregate fields of \"average_block_time_from_genesis\""
type average_block_time_from_genesis_aggregate_fields {
  avg: average_block_time_from_genesis_avg_fields
  count(columns: [average_block_time_from_genesis_select_column!] distinct: Boolean): Int!
  max: average_block_time_from_genesis_max_fields
  min: average_block_time_from_genesis_min_fields
  stddev: average_block_time_from_genesis_stddev_fields
  stddev_pop: average_block_time_from_genesis_stddev_pop_fields
  stddev_samp: average_block_time_from_genesis_stddev_samp_fields
  sum: average_block_time_from_genesis_sum_fields
  var_pop: average_block_time_from_genesis_var_pop_fields
  var_samp: average_block_time_from_genesis_var_samp_fields
  variance: average_block_time_from_genesis_variance_fields
}

"aggregate avg on columns"
type average_block_time_from_genesis_avg_fields {
  average_time: Float
  height: Float
}

"Boolean expression to filter rows from the table \"average_block_time_from_genesis\". All fields are combined with a logical 'AND'."
input average_block_time_from_genesis_bool_exp {
  _and: [average_block_time_from_genesis_bool_exp!]
  _not: average_block_time_from_genesis_bool_exp
  _or: [average_block_time_from_genesis_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
}

"aggregate max on columns"
type average_block_time_from_genesis_max_fields {
  average_time: numeric
  height: bigint
}

"aggregate min on columns"
type average_block_time_from_genesis_min_fields {
  average_time: numeric
  height: bigint
}

"Ordering options when selecting data from \"average_block_time_from_genesis\"."
input average_block_time_from_genesis_order_by {
  average_time: order_by
  height: order_by
}

"select columns of table \"average_block_time_from_genesis\""
enum average_block_time_from_genesis_select_column {
  "column name"
  average_time
  "column name"
  height
}

"aggregate stddev on columns"
type average_block_time_from_genesis_stddev_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_pop on columns"
type average_block_time_from_genesis_stddev_pop_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_samp on columns"
type average_block_time_from_genesis_stddev_samp_fields {
  average_time: Float
  height: Float
}

"aggregate sum on columns"
type average_block_time_from_genesis_sum_fields {
  average_time: numeric
  height: bigint
}

"aggregate var_pop on columns"
type average_block_time_from_genesis_var_pop_fields {
  average_time: Float
  height: Float
}

"aggregate var_samp on columns"
type average_block_time_from_genesis_var_samp_fields {
  average_time: Float
  height: Float
}

"aggregate variance on columns"
type average_block_time_from_genesis_variance_fields {
  average_time: Float
  height: Float
}

"columns and relationships of \"average_block_time_per_day\""
type average_block_time_per_day {
  average_time: numeric!
  height: bigint!
}

"aggregated selection of \"average_block_time_per_day\""
type average_block_time_per_day_aggregate {
  aggregate: average_block_time_per_day_aggregate_fields
  nodes: [average_block_time_per_day!]!
}

"aggregate fields of \"average_block_time_per_day\""
type average_block_time_per_day_aggregate_fields {
  avg: average_block_time_per_day_avg_fields
  count(columns: [average_block_time_per_day_select_column!] distinct: Boolean): Int!
  max: average_block_time_per_day_max_fields
  min: average_block_time_per_day_min_fields
  stddev: average_block_time_per_day_stddev_fields
  stddev_pop: average_block_time_per_day_stddev_pop_fields
  stddev_samp: average_block_time_per_day_stddev_samp_fields
  sum: average_block_time_per_day_sum_fields
  var_pop: average_block_time_per_day_var_pop_fields
  var_samp: average_block_time_per_day_var_samp_fields
  variance: average_block_time_per_day_variance_fields
}

"aggregate avg on columns"
type average_block_time_per_day_avg_fields {
  average_time: Float
  height: Float
}

"Boolean expression to filter rows from the table \"average_block_time_per_day\". All fields are combined with a logical 'AND'."
input average_block_time_per_day_bool_exp {
  _and: [average_block_time_per_day_bool_exp!]
  _not: average_block_time_per_day_bool_exp
  _or: [average_block_time_per_day_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
}

"aggregate max on columns"
type average_block_time_per_day_max_fields {
  average_time: numeric
  height: bigint
}

"aggregate min on columns"
type average_block_time_per_day_min_fields {
  average_time: numeric
  height: bigint
}

"Ordering options when selecting data from \"average_block_time_per_day\"."
input average_block_time_per_day_order_by {
  average_time: order_by
  height: order_by
}

"select columns of table \"average_block_time_per_day\""
enum average_block_time_per_day_select_column {
  "column name"
  average_time
  "column name"
  height
}

"aggregate stddev on columns"
type average_block_time_per_day_stddev_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_pop on columns"
type average_block_time_per_day_stddev_pop_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_samp on columns"
type average_block_time_per_day_stddev_samp_fields {
  average_time: Float
  height: Float
}

"aggregate sum on columns"
type average_block_time_per_day_sum_fields {
  average_time: numeric
  height: bigint
}

"aggregate var_pop on columns"
type average_block_time_per_day_var_pop_fields {
  average_time: Float
  height: Float
}

"aggregate var_samp on columns"
type average_block_time_per_day_var_samp_fields {
  average_time: Float
  height: Float
}

"aggregate variance on columns"
type average_block_time_per_day_variance_fields {
  average_time: Float
  height: Float
}

"columns and relationships of \"average_block_time_per_hour\""
type average_block_time_per_hour {
  average_time: numeric!
  height: bigint!
}

"aggregated selection of \"average_block_time_per_hour\""
type average_block_time_per_hour_aggregate {
  aggregate: average_block_time_per_hour_aggregate_fields
  nodes: [average_block_time_per_hour!]!
}

"aggregate fields of \"average_block_time_per_hour\""
type average_block_time_per_hour_aggregate_fields {
  avg: average_block_time_per_hour_avg_fields
  count(columns: [average_block_time_per_hour_select_column!] distinct: Boolean): Int!
  max: average_block_time_per_hour_max_fields
  min: average_block_time_per_hour_min_fields
  stddev: average_block_time_per_hour_stddev_fields
  stddev_pop: average_block_time_per_hour_stddev_pop_fields
  stddev_samp: average_block_time_per_hour_stddev_samp_fields
  sum: average_block_time_per_hour_sum_fields
  var_pop: average_block_time_per_hour_var_pop_fields
  var_samp: average_block_time_per_hour_var_samp_fields
  variance: average_block_time_per_hour_variance_fields
}

"aggregate avg on columns"
type average_block_time_per_hour_avg_fields {
  average_time: Float
  height: Float
}

"Boolean expression to filter rows from the table \"average_block_time_per_hour\". All fields are combined with a logical 'AND'."
input average_block_time_per_hour_bool_exp {
  _and: [average_block_time_per_hour_bool_exp!]
  _not: average_block_time_per_hour_bool_exp
  _or: [average_block_time_per_hour_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
}

"aggregate max on columns"
type average_block_time_per_hour_max_fields {
  average_time: numeric
  height: bigint
}

"aggregate min on columns"
type average_block_time_per_hour_min_fields {
  average_time: numeric
  height: bigint
}

"Ordering options when selecting data from \"average_block_time_per_hour\"."
input average_block_time_per_hour_order_by {
  average_time: order_by
  height: order_by
}

"select columns of table \"average_block_time_per_hour\""
enum average_block_time_per_hour_select_column {
  "column name"
  average_time
  "column name"
  height
}

"aggregate stddev on columns"
type average_block_time_per_hour_stddev_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_pop on columns"
type average_block_time_per_hour_stddev_pop_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_samp on columns"
type average_block_time_per_hour_stddev_samp_fields {
  average_time: Float
  height: Float
}

"aggregate sum on columns"
type average_block_time_per_hour_sum_fields {
  average_time: numeric
  height: bigint
}

"aggregate var_pop on columns"
type average_block_time_per_hour_var_pop_fields {
  average_time: Float
  height: Float
}

"aggregate var_samp on columns"
type average_block_time_per_hour_var_samp_fields {
  average_time: Float
  height: Float
}

"aggregate variance on columns"
type average_block_time_per_hour_variance_fields {
  average_time: Float
  height: Float
}

"columns and relationships of \"average_block_time_per_minute\""
type average_block_time_per_minute {
  average_time: numeric!
  height: bigint!
}

"aggregated selection of \"average_block_time_per_minute\""
type average_block_time_per_minute_aggregate {
  aggregate: average_block_time_per_minute_aggregate_fields
  nodes: [average_block_time_per_minute!]!
}

"aggregate fields of \"average_block_time_per_minute\""
type average_block_time_per_minute_aggregate_fields {
  avg: average_block_time_per_minute_avg_fields
  count(columns: [average_block_time_per_minute_select_column!] distinct: Boolean): Int!
  max: average_block_time_per_minute_max_fields
  min: average_block_time_per_minute_min_fields
  stddev: average_block_time_per_minute_stddev_fields
  stddev_pop: average_block_time_per_minute_stddev_pop_fields
  stddev_samp: average_block_time_per_minute_stddev_samp_fields
  sum: average_block_time_per_minute_sum_fields
  var_pop: average_block_time_per_minute_var_pop_fields
  var_samp: average_block_time_per_minute_var_samp_fields
  variance: average_block_time_per_minute_variance_fields
}

"aggregate avg on columns"
type average_block_time_per_minute_avg_fields {
  average_time: Float
  height: Float
}

"Boolean expression to filter rows from the table \"average_block_time_per_minute\". All fields are combined with a logical 'AND'."
input average_block_time_per_minute_bool_exp {
  _and: [average_block_time_per_minute_bool_exp!]
  _not: average_block_time_per_minute_bool_exp
  _or: [average_block_time_per_minute_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
}

"aggregate max on columns"
type average_block_time_per_minute_max_fields {
  average_time: numeric
  height: bigint
}

"aggregate min on columns"
type average_block_time_per_minute_min_fields {
  average_time: numeric
  height: bigint
}

"Ordering options when selecting data from \"average_block_time_per_minute\"."
input average_block_time_per_minute_order_by {
  average_time: order_by
  height: order_by
}

"select columns of table \"average_block_time_per_minute\""
enum average_block_time_per_minute_select_column {
  "column name"
  average_time
  "column name"
  height
}

"aggregate stddev on columns"
type average_block_time_per_minute_stddev_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_pop on columns"
type average_block_time_per_minute_stddev_pop_fields {
  average_time: Float
  height: Float
}

"aggregate stddev_samp on columns"
type average_block_time_per_minute_stddev_samp_fields {
  average_time: Float
  height: Float
}

"aggregate sum on columns"
type average_block_time_per_minute_sum_fields {
  average_time: numeric
  height: bigint
}

"aggregate var_pop on columns"
type average_block_time_per_minute_var_pop_fields {
  average_time: Float
  height: Float
}

"aggregate var_samp on columns"
type average_block_time_per_minute_var_samp_fields {
  average_time: Float
  height: Float
}

"aggregate variance on columns"
type average_block_time_per_minute_variance_fields {
  average_time: Float
  height: Float
}

scalar bigint

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"columns and relationships of \"block\""
type block {
  hash: String!
  height: bigint!
  num_txs: Int
  "An array relationship"
  pre_commits("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): [pre_commit!]!
  "An aggregate relationship"
  pre_commits_aggregate("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): pre_commit_aggregate!
  proposer_address: String
  timestamp: timestamp!
  total_gas: bigint
  "An array relationship"
  transactions("distinct select on columns" distinct_on: [transaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [transaction_order_by!] "filter the rows returned" where: transaction_bool_exp): [transaction!]!
  "An aggregate relationship"
  transactions_aggregate("distinct select on columns" distinct_on: [transaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [transaction_order_by!] "filter the rows returned" where: transaction_bool_exp): transaction_aggregate!
  "An object relationship"
  validator: validator
  "An array relationship"
  validator_voting_powers("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): [validator_voting_power!]!
  "An aggregate relationship"
  validator_voting_powers_aggregate("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): validator_voting_power_aggregate!
}

"aggregated selection of \"block\""
type block_aggregate {
  aggregate: block_aggregate_fields
  nodes: [block!]!
}

"aggregate fields of \"block\""
type block_aggregate_fields {
  avg: block_avg_fields
  count(columns: [block_select_column!] distinct: Boolean): Int!
  max: block_max_fields
  min: block_min_fields
  stddev: block_stddev_fields
  stddev_pop: block_stddev_pop_fields
  stddev_samp: block_stddev_samp_fields
  sum: block_sum_fields
  var_pop: block_var_pop_fields
  var_samp: block_var_samp_fields
  variance: block_variance_fields
}

"order by aggregate values of table \"block\""
input block_aggregate_order_by {
  avg: block_avg_order_by
  count: order_by
  max: block_max_order_by
  min: block_min_order_by
  stddev: block_stddev_order_by
  stddev_pop: block_stddev_pop_order_by
  stddev_samp: block_stddev_samp_order_by
  sum: block_sum_order_by
  var_pop: block_var_pop_order_by
  var_samp: block_var_samp_order_by
  variance: block_variance_order_by
}

"aggregate avg on columns"
type block_avg_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by avg() on columns of table \"block\""
input block_avg_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"Boolean expression to filter rows from the table \"block\". All fields are combined with a logical 'AND'."
input block_bool_exp {
  _and: [block_bool_exp!]
  _not: block_bool_exp
  _or: [block_bool_exp!]
  hash: String_comparison_exp
  height: bigint_comparison_exp
  num_txs: Int_comparison_exp
  pre_commits: pre_commit_bool_exp
  proposer_address: String_comparison_exp
  timestamp: timestamp_comparison_exp
  total_gas: bigint_comparison_exp
  transactions: transaction_bool_exp
  validator: validator_bool_exp
  validator_voting_powers: validator_voting_power_bool_exp
}

"aggregate max on columns"
type block_max_fields {
  hash: String
  height: bigint
  num_txs: Int
  proposer_address: String
  timestamp: timestamp
  total_gas: bigint
}

"order by max() on columns of table \"block\""
input block_max_order_by {
  hash: order_by
  height: order_by
  num_txs: order_by
  proposer_address: order_by
  timestamp: order_by
  total_gas: order_by
}

"aggregate min on columns"
type block_min_fields {
  hash: String
  height: bigint
  num_txs: Int
  proposer_address: String
  timestamp: timestamp
  total_gas: bigint
}

"order by min() on columns of table \"block\""
input block_min_order_by {
  hash: order_by
  height: order_by
  num_txs: order_by
  proposer_address: order_by
  timestamp: order_by
  total_gas: order_by
}

"Ordering options when selecting data from \"block\"."
input block_order_by {
  hash: order_by
  height: order_by
  num_txs: order_by
  pre_commits_aggregate: pre_commit_aggregate_order_by
  proposer_address: order_by
  timestamp: order_by
  total_gas: order_by
  transactions_aggregate: transaction_aggregate_order_by
  validator: validator_order_by
  validator_voting_powers_aggregate: validator_voting_power_aggregate_order_by
}

"select columns of table \"block\""
enum block_select_column {
  "column name"
  hash
  "column name"
  height
  "column name"
  num_txs
  "column name"
  proposer_address
  "column name"
  timestamp
  "column name"
  total_gas
}

"aggregate stddev on columns"
type block_stddev_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by stddev() on columns of table \"block\""
input block_stddev_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"aggregate stddev_pop on columns"
type block_stddev_pop_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by stddev_pop() on columns of table \"block\""
input block_stddev_pop_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"aggregate stddev_samp on columns"
type block_stddev_samp_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by stddev_samp() on columns of table \"block\""
input block_stddev_samp_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"aggregate sum on columns"
type block_sum_fields {
  height: bigint
  num_txs: Int
  total_gas: bigint
}

"order by sum() on columns of table \"block\""
input block_sum_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"aggregate var_pop on columns"
type block_var_pop_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by var_pop() on columns of table \"block\""
input block_var_pop_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"aggregate var_samp on columns"
type block_var_samp_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by var_samp() on columns of table \"block\""
input block_var_samp_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"aggregate variance on columns"
type block_variance_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"order by variance() on columns of table \"block\""
input block_variance_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"columns and relationships of \"chain_link\""
type chain_link {
  "An object relationship"
  chain_config: chain_link_chain_config!
  chain_config_id: bigint!
  creation_time: timestamp!
  external_address: String!
  height: bigint!
  id: Int!
  "An object relationship"
  profile: profile!
  "An object relationship"
  proof: chain_link_proof
  user_address: String!
}

"aggregated selection of \"chain_link\""
type chain_link_aggregate {
  aggregate: chain_link_aggregate_fields
  nodes: [chain_link!]!
}

"aggregate fields of \"chain_link\""
type chain_link_aggregate_fields {
  avg: chain_link_avg_fields
  count(columns: [chain_link_select_column!] distinct: Boolean): Int!
  max: chain_link_max_fields
  min: chain_link_min_fields
  stddev: chain_link_stddev_fields
  stddev_pop: chain_link_stddev_pop_fields
  stddev_samp: chain_link_stddev_samp_fields
  sum: chain_link_sum_fields
  var_pop: chain_link_var_pop_fields
  var_samp: chain_link_var_samp_fields
  variance: chain_link_variance_fields
}

"order by aggregate values of table \"chain_link\""
input chain_link_aggregate_order_by {
  avg: chain_link_avg_order_by
  count: order_by
  max: chain_link_max_order_by
  min: chain_link_min_order_by
  stddev: chain_link_stddev_order_by
  stddev_pop: chain_link_stddev_pop_order_by
  stddev_samp: chain_link_stddev_samp_order_by
  sum: chain_link_sum_order_by
  var_pop: chain_link_var_pop_order_by
  var_samp: chain_link_var_samp_order_by
  variance: chain_link_variance_order_by
}

"aggregate avg on columns"
type chain_link_avg_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by avg() on columns of table \"chain_link\""
input chain_link_avg_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"chain_link\". All fields are combined with a logical 'AND'."
input chain_link_bool_exp {
  _and: [chain_link_bool_exp!]
  _not: chain_link_bool_exp
  _or: [chain_link_bool_exp!]
  chain_config: chain_link_chain_config_bool_exp
  chain_config_id: bigint_comparison_exp
  creation_time: timestamp_comparison_exp
  external_address: String_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  profile: profile_bool_exp
  proof: chain_link_proof_bool_exp
  user_address: String_comparison_exp
}

"columns and relationships of \"chain_link_chain_config\""
type chain_link_chain_config {
  "An array relationship"
  chain_links("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): [chain_link!]!
  "An aggregate relationship"
  chain_links_aggregate("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): chain_link_aggregate!
  id: Int!
  name: String!
}

"aggregated selection of \"chain_link_chain_config\""
type chain_link_chain_config_aggregate {
  aggregate: chain_link_chain_config_aggregate_fields
  nodes: [chain_link_chain_config!]!
}

"aggregate fields of \"chain_link_chain_config\""
type chain_link_chain_config_aggregate_fields {
  avg: chain_link_chain_config_avg_fields
  count(columns: [chain_link_chain_config_select_column!] distinct: Boolean): Int!
  max: chain_link_chain_config_max_fields
  min: chain_link_chain_config_min_fields
  stddev: chain_link_chain_config_stddev_fields
  stddev_pop: chain_link_chain_config_stddev_pop_fields
  stddev_samp: chain_link_chain_config_stddev_samp_fields
  sum: chain_link_chain_config_sum_fields
  var_pop: chain_link_chain_config_var_pop_fields
  var_samp: chain_link_chain_config_var_samp_fields
  variance: chain_link_chain_config_variance_fields
}

"aggregate avg on columns"
type chain_link_chain_config_avg_fields {
  id: Float
}

"Boolean expression to filter rows from the table \"chain_link_chain_config\". All fields are combined with a logical 'AND'."
input chain_link_chain_config_bool_exp {
  _and: [chain_link_chain_config_bool_exp!]
  _not: chain_link_chain_config_bool_exp
  _or: [chain_link_chain_config_bool_exp!]
  chain_links: chain_link_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"aggregate max on columns"
type chain_link_chain_config_max_fields {
  id: Int
  name: String
}

"aggregate min on columns"
type chain_link_chain_config_min_fields {
  id: Int
  name: String
}

"Ordering options when selecting data from \"chain_link_chain_config\"."
input chain_link_chain_config_order_by {
  chain_links_aggregate: chain_link_aggregate_order_by
  id: order_by
  name: order_by
}

"select columns of table \"chain_link_chain_config\""
enum chain_link_chain_config_select_column {
  "column name"
  id
  "column name"
  name
}

"aggregate stddev on columns"
type chain_link_chain_config_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type chain_link_chain_config_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type chain_link_chain_config_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type chain_link_chain_config_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type chain_link_chain_config_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type chain_link_chain_config_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type chain_link_chain_config_variance_fields {
  id: Float
}

"aggregate max on columns"
type chain_link_max_fields {
  chain_config_id: bigint
  creation_time: timestamp
  external_address: String
  height: bigint
  id: Int
  user_address: String
}

"order by max() on columns of table \"chain_link\""
input chain_link_max_order_by {
  chain_config_id: order_by
  creation_time: order_by
  external_address: order_by
  height: order_by
  id: order_by
  user_address: order_by
}

"aggregate min on columns"
type chain_link_min_fields {
  chain_config_id: bigint
  creation_time: timestamp
  external_address: String
  height: bigint
  id: Int
  user_address: String
}

"order by min() on columns of table \"chain_link\""
input chain_link_min_order_by {
  chain_config_id: order_by
  creation_time: order_by
  external_address: order_by
  height: order_by
  id: order_by
  user_address: order_by
}

"Ordering options when selecting data from \"chain_link\"."
input chain_link_order_by {
  chain_config: chain_link_chain_config_order_by
  chain_config_id: order_by
  creation_time: order_by
  external_address: order_by
  height: order_by
  id: order_by
  profile: profile_order_by
  proof: chain_link_proof_order_by
  user_address: order_by
}

"columns and relationships of \"chain_link_proof\""
type chain_link_proof {
  "An object relationship"
  chain_link: chain_link!
  chain_link_id: bigint!
  height: bigint!
  id: Int!
  plain_text: String!
  public_key("JSON select path" path: String): jsonb!
  signature: String!
}

"aggregated selection of \"chain_link_proof\""
type chain_link_proof_aggregate {
  aggregate: chain_link_proof_aggregate_fields
  nodes: [chain_link_proof!]!
}

"aggregate fields of \"chain_link_proof\""
type chain_link_proof_aggregate_fields {
  avg: chain_link_proof_avg_fields
  count(columns: [chain_link_proof_select_column!] distinct: Boolean): Int!
  max: chain_link_proof_max_fields
  min: chain_link_proof_min_fields
  stddev: chain_link_proof_stddev_fields
  stddev_pop: chain_link_proof_stddev_pop_fields
  stddev_samp: chain_link_proof_stddev_samp_fields
  sum: chain_link_proof_sum_fields
  var_pop: chain_link_proof_var_pop_fields
  var_samp: chain_link_proof_var_samp_fields
  variance: chain_link_proof_variance_fields
}

"aggregate avg on columns"
type chain_link_proof_avg_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"Boolean expression to filter rows from the table \"chain_link_proof\". All fields are combined with a logical 'AND'."
input chain_link_proof_bool_exp {
  _and: [chain_link_proof_bool_exp!]
  _not: chain_link_proof_bool_exp
  _or: [chain_link_proof_bool_exp!]
  chain_link: chain_link_bool_exp
  chain_link_id: bigint_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  plain_text: String_comparison_exp
  public_key: jsonb_comparison_exp
  signature: String_comparison_exp
}

"aggregate max on columns"
type chain_link_proof_max_fields {
  chain_link_id: bigint
  height: bigint
  id: Int
  plain_text: String
  signature: String
}

"aggregate min on columns"
type chain_link_proof_min_fields {
  chain_link_id: bigint
  height: bigint
  id: Int
  plain_text: String
  signature: String
}

"Ordering options when selecting data from \"chain_link_proof\"."
input chain_link_proof_order_by {
  chain_link: chain_link_order_by
  chain_link_id: order_by
  height: order_by
  id: order_by
  plain_text: order_by
  public_key: order_by
  signature: order_by
}

"select columns of table \"chain_link_proof\""
enum chain_link_proof_select_column {
  "column name"
  chain_link_id
  "column name"
  height
  "column name"
  id
  "column name"
  plain_text
  "column name"
  public_key
  "column name"
  signature
}

"aggregate stddev on columns"
type chain_link_proof_stddev_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"aggregate stddev_pop on columns"
type chain_link_proof_stddev_pop_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"aggregate stddev_samp on columns"
type chain_link_proof_stddev_samp_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"aggregate sum on columns"
type chain_link_proof_sum_fields {
  chain_link_id: bigint
  height: bigint
  id: Int
}

"aggregate var_pop on columns"
type chain_link_proof_var_pop_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"aggregate var_samp on columns"
type chain_link_proof_var_samp_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"aggregate variance on columns"
type chain_link_proof_variance_fields {
  chain_link_id: Float
  height: Float
  id: Float
}

"select columns of table \"chain_link\""
enum chain_link_select_column {
  "column name"
  chain_config_id
  "column name"
  creation_time
  "column name"
  external_address
  "column name"
  height
  "column name"
  id
  "column name"
  user_address
}

"aggregate stddev on columns"
type chain_link_stddev_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by stddev() on columns of table \"chain_link\""
input chain_link_stddev_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"aggregate stddev_pop on columns"
type chain_link_stddev_pop_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by stddev_pop() on columns of table \"chain_link\""
input chain_link_stddev_pop_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"aggregate stddev_samp on columns"
type chain_link_stddev_samp_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by stddev_samp() on columns of table \"chain_link\""
input chain_link_stddev_samp_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"aggregate sum on columns"
type chain_link_sum_fields {
  chain_config_id: bigint
  height: bigint
  id: Int
}

"order by sum() on columns of table \"chain_link\""
input chain_link_sum_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"aggregate var_pop on columns"
type chain_link_var_pop_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by var_pop() on columns of table \"chain_link\""
input chain_link_var_pop_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"aggregate var_samp on columns"
type chain_link_var_samp_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by var_samp() on columns of table \"chain_link\""
input chain_link_var_samp_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

"aggregate variance on columns"
type chain_link_variance_fields {
  chain_config_id: Float
  height: Float
  id: Float
}

"order by variance() on columns of table \"chain_link\""
input chain_link_variance_order_by {
  chain_config_id: order_by
  height: order_by
  id: order_by
}

scalar coin

"Boolean expression to compare columns of type \"coin\". All fields are combined with logical 'AND'."
input coin_comparison_exp {
  _eq: coin
  _gt: coin
  _gte: coin
  _in: [coin!]
  _is_null: Boolean
  _lt: coin
  _lte: coin
  _neq: coin
  _nin: [coin!]
}

"columns and relationships of \"community_pool\""
type community_pool {
  coins: _dec_coin!
  height: bigint!
}

"aggregated selection of \"community_pool\""
type community_pool_aggregate {
  aggregate: community_pool_aggregate_fields
  nodes: [community_pool!]!
}

"aggregate fields of \"community_pool\""
type community_pool_aggregate_fields {
  avg: community_pool_avg_fields
  count(columns: [community_pool_select_column!] distinct: Boolean): Int!
  max: community_pool_max_fields
  min: community_pool_min_fields
  stddev: community_pool_stddev_fields
  stddev_pop: community_pool_stddev_pop_fields
  stddev_samp: community_pool_stddev_samp_fields
  sum: community_pool_sum_fields
  var_pop: community_pool_var_pop_fields
  var_samp: community_pool_var_samp_fields
  variance: community_pool_variance_fields
}

"aggregate avg on columns"
type community_pool_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"community_pool\". All fields are combined with a logical 'AND'."
input community_pool_bool_exp {
  _and: [community_pool_bool_exp!]
  _not: community_pool_bool_exp
  _or: [community_pool_bool_exp!]
  coins: _dec_coin_comparison_exp
  height: bigint_comparison_exp
}

"aggregate max on columns"
type community_pool_max_fields {
  height: bigint
}

"aggregate min on columns"
type community_pool_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"community_pool\"."
input community_pool_order_by {
  coins: order_by
  height: order_by
}

"select columns of table \"community_pool\""
enum community_pool_select_column {
  "column name"
  coins
  "column name"
  height
}

"aggregate stddev on columns"
type community_pool_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type community_pool_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type community_pool_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type community_pool_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type community_pool_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type community_pool_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type community_pool_variance_fields {
  height: Float
}

"columns and relationships of \"delegation\""
type delegation {
  "An object relationship"
  account: account!
  amount: coin!
  delegator_address: String!
  height: bigint!
  id: Int!
  "A computed field, executes function \"is_delegation_self_delegate\""
  is_self_delegate: Boolean
  "An object relationship"
  validator: validator!
  validator_address: String!
}

"aggregated selection of \"delegation\""
type delegation_aggregate {
  aggregate: delegation_aggregate_fields
  nodes: [delegation!]!
}

"aggregate fields of \"delegation\""
type delegation_aggregate_fields {
  avg: delegation_avg_fields
  count(columns: [delegation_select_column!] distinct: Boolean): Int!
  max: delegation_max_fields
  min: delegation_min_fields
  stddev: delegation_stddev_fields
  stddev_pop: delegation_stddev_pop_fields
  stddev_samp: delegation_stddev_samp_fields
  sum: delegation_sum_fields
  var_pop: delegation_var_pop_fields
  var_samp: delegation_var_samp_fields
  variance: delegation_variance_fields
}

"order by aggregate values of table \"delegation\""
input delegation_aggregate_order_by {
  avg: delegation_avg_order_by
  count: order_by
  max: delegation_max_order_by
  min: delegation_min_order_by
  stddev: delegation_stddev_order_by
  stddev_pop: delegation_stddev_pop_order_by
  stddev_samp: delegation_stddev_samp_order_by
  sum: delegation_sum_order_by
  var_pop: delegation_var_pop_order_by
  var_samp: delegation_var_samp_order_by
  variance: delegation_variance_order_by
}

"aggregate avg on columns"
type delegation_avg_fields {
  height: Float
  id: Float
}

"order by avg() on columns of table \"delegation\""
input delegation_avg_order_by {
  height: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"delegation\". All fields are combined with a logical 'AND'."
input delegation_bool_exp {
  _and: [delegation_bool_exp!]
  _not: delegation_bool_exp
  _or: [delegation_bool_exp!]
  account: account_bool_exp
  amount: coin_comparison_exp
  delegator_address: String_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  is_self_delegate: Boolean_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"aggregate max on columns"
type delegation_max_fields {
  delegator_address: String
  height: bigint
  id: Int
  validator_address: String
}

"order by max() on columns of table \"delegation\""
input delegation_max_order_by {
  delegator_address: order_by
  height: order_by
  id: order_by
  validator_address: order_by
}

"aggregate min on columns"
type delegation_min_fields {
  delegator_address: String
  height: bigint
  id: Int
  validator_address: String
}

"order by min() on columns of table \"delegation\""
input delegation_min_order_by {
  delegator_address: order_by
  height: order_by
  id: order_by
  validator_address: order_by
}

"Ordering options when selecting data from \"delegation\"."
input delegation_order_by {
  account: account_order_by
  amount: order_by
  delegator_address: order_by
  height: order_by
  id: order_by
  validator: validator_order_by
  validator_address: order_by
}

"columns and relationships of \"delegation_reward\""
type delegation_reward {
  "An object relationship"
  account: account!
  amount: _dec_coin!
  delegator_address: String!
  height: bigint!
  "An object relationship"
  validator: validator!
  validator_address: String!
  withdraw_address: String!
}

"aggregated selection of \"delegation_reward\""
type delegation_reward_aggregate {
  aggregate: delegation_reward_aggregate_fields
  nodes: [delegation_reward!]!
}

"aggregate fields of \"delegation_reward\""
type delegation_reward_aggregate_fields {
  avg: delegation_reward_avg_fields
  count(columns: [delegation_reward_select_column!] distinct: Boolean): Int!
  max: delegation_reward_max_fields
  min: delegation_reward_min_fields
  stddev: delegation_reward_stddev_fields
  stddev_pop: delegation_reward_stddev_pop_fields
  stddev_samp: delegation_reward_stddev_samp_fields
  sum: delegation_reward_sum_fields
  var_pop: delegation_reward_var_pop_fields
  var_samp: delegation_reward_var_samp_fields
  variance: delegation_reward_variance_fields
}

"order by aggregate values of table \"delegation_reward\""
input delegation_reward_aggregate_order_by {
  avg: delegation_reward_avg_order_by
  count: order_by
  max: delegation_reward_max_order_by
  min: delegation_reward_min_order_by
  stddev: delegation_reward_stddev_order_by
  stddev_pop: delegation_reward_stddev_pop_order_by
  stddev_samp: delegation_reward_stddev_samp_order_by
  sum: delegation_reward_sum_order_by
  var_pop: delegation_reward_var_pop_order_by
  var_samp: delegation_reward_var_samp_order_by
  variance: delegation_reward_variance_order_by
}

"aggregate avg on columns"
type delegation_reward_avg_fields {
  height: Float
}

"order by avg() on columns of table \"delegation_reward\""
input delegation_reward_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"delegation_reward\". All fields are combined with a logical 'AND'."
input delegation_reward_bool_exp {
  _and: [delegation_reward_bool_exp!]
  _not: delegation_reward_bool_exp
  _or: [delegation_reward_bool_exp!]
  account: account_bool_exp
  amount: _dec_coin_comparison_exp
  delegator_address: String_comparison_exp
  height: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  withdraw_address: String_comparison_exp
}

"aggregate max on columns"
type delegation_reward_max_fields {
  delegator_address: String
  height: bigint
  validator_address: String
  withdraw_address: String
}

"order by max() on columns of table \"delegation_reward\""
input delegation_reward_max_order_by {
  delegator_address: order_by
  height: order_by
  validator_address: order_by
  withdraw_address: order_by
}

"aggregate min on columns"
type delegation_reward_min_fields {
  delegator_address: String
  height: bigint
  validator_address: String
  withdraw_address: String
}

"order by min() on columns of table \"delegation_reward\""
input delegation_reward_min_order_by {
  delegator_address: order_by
  height: order_by
  validator_address: order_by
  withdraw_address: order_by
}

"Ordering options when selecting data from \"delegation_reward\"."
input delegation_reward_order_by {
  account: account_order_by
  amount: order_by
  delegator_address: order_by
  height: order_by
  validator: validator_order_by
  validator_address: order_by
  withdraw_address: order_by
}

"select columns of table \"delegation_reward\""
enum delegation_reward_select_column {
  "column name"
  amount
  "column name"
  delegator_address
  "column name"
  height
  "column name"
  validator_address
  "column name"
  withdraw_address
}

"aggregate stddev on columns"
type delegation_reward_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"delegation_reward\""
input delegation_reward_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type delegation_reward_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"delegation_reward\""
input delegation_reward_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type delegation_reward_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"delegation_reward\""
input delegation_reward_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type delegation_reward_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"delegation_reward\""
input delegation_reward_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type delegation_reward_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"delegation_reward\""
input delegation_reward_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type delegation_reward_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"delegation_reward\""
input delegation_reward_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type delegation_reward_variance_fields {
  height: Float
}

"order by variance() on columns of table \"delegation_reward\""
input delegation_reward_variance_order_by {
  height: order_by
}

"select columns of table \"delegation\""
enum delegation_select_column {
  "column name"
  amount
  "column name"
  delegator_address
  "column name"
  height
  "column name"
  id
  "column name"
  validator_address
}

"aggregate stddev on columns"
type delegation_stddev_fields {
  height: Float
  id: Float
}

"order by stddev() on columns of table \"delegation\""
input delegation_stddev_order_by {
  height: order_by
  id: order_by
}

"aggregate stddev_pop on columns"
type delegation_stddev_pop_fields {
  height: Float
  id: Float
}

"order by stddev_pop() on columns of table \"delegation\""
input delegation_stddev_pop_order_by {
  height: order_by
  id: order_by
}

"aggregate stddev_samp on columns"
type delegation_stddev_samp_fields {
  height: Float
  id: Float
}

"order by stddev_samp() on columns of table \"delegation\""
input delegation_stddev_samp_order_by {
  height: order_by
  id: order_by
}

"aggregate sum on columns"
type delegation_sum_fields {
  height: bigint
  id: Int
}

"order by sum() on columns of table \"delegation\""
input delegation_sum_order_by {
  height: order_by
  id: order_by
}

"aggregate var_pop on columns"
type delegation_var_pop_fields {
  height: Float
  id: Float
}

"order by var_pop() on columns of table \"delegation\""
input delegation_var_pop_order_by {
  height: order_by
  id: order_by
}

"aggregate var_samp on columns"
type delegation_var_samp_fields {
  height: Float
  id: Float
}

"order by var_samp() on columns of table \"delegation\""
input delegation_var_samp_order_by {
  height: order_by
  id: order_by
}

"aggregate variance on columns"
type delegation_variance_fields {
  height: Float
  id: Float
}

"order by variance() on columns of table \"delegation\""
input delegation_variance_order_by {
  height: order_by
  id: order_by
}

"columns and relationships of \"distribution_params\""
type distribution_params {
  height: bigint!
  one_row_id: Boolean!
  params("JSON select path" path: String): jsonb!
}

"aggregated selection of \"distribution_params\""
type distribution_params_aggregate {
  aggregate: distribution_params_aggregate_fields
  nodes: [distribution_params!]!
}

"aggregate fields of \"distribution_params\""
type distribution_params_aggregate_fields {
  avg: distribution_params_avg_fields
  count(columns: [distribution_params_select_column!] distinct: Boolean): Int!
  max: distribution_params_max_fields
  min: distribution_params_min_fields
  stddev: distribution_params_stddev_fields
  stddev_pop: distribution_params_stddev_pop_fields
  stddev_samp: distribution_params_stddev_samp_fields
  sum: distribution_params_sum_fields
  var_pop: distribution_params_var_pop_fields
  var_samp: distribution_params_var_samp_fields
  variance: distribution_params_variance_fields
}

"aggregate avg on columns"
type distribution_params_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"distribution_params\". All fields are combined with a logical 'AND'."
input distribution_params_bool_exp {
  _and: [distribution_params_bool_exp!]
  _not: distribution_params_bool_exp
  _or: [distribution_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"aggregate max on columns"
type distribution_params_max_fields {
  height: bigint
}

"aggregate min on columns"
type distribution_params_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"distribution_params\"."
input distribution_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"select columns of table \"distribution_params\""
enum distribution_params_select_column {
  "column name"
  height
  "column name"
  one_row_id
  "column name"
  params
}

"aggregate stddev on columns"
type distribution_params_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type distribution_params_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type distribution_params_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type distribution_params_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type distribution_params_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type distribution_params_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type distribution_params_variance_fields {
  height: Float
}

"columns and relationships of \"double_sign_evidence\""
type double_sign_evidence {
  "An object relationship"
  doubleSignVoteByVoteAId: double_sign_vote!
  "An object relationship"
  double_sign_vote: double_sign_vote!
  height: bigint!
  vote_a_id: bigint!
  vote_b_id: bigint!
}

"aggregated selection of \"double_sign_evidence\""
type double_sign_evidence_aggregate {
  aggregate: double_sign_evidence_aggregate_fields
  nodes: [double_sign_evidence!]!
}

"aggregate fields of \"double_sign_evidence\""
type double_sign_evidence_aggregate_fields {
  avg: double_sign_evidence_avg_fields
  count(columns: [double_sign_evidence_select_column!] distinct: Boolean): Int!
  max: double_sign_evidence_max_fields
  min: double_sign_evidence_min_fields
  stddev: double_sign_evidence_stddev_fields
  stddev_pop: double_sign_evidence_stddev_pop_fields
  stddev_samp: double_sign_evidence_stddev_samp_fields
  sum: double_sign_evidence_sum_fields
  var_pop: double_sign_evidence_var_pop_fields
  var_samp: double_sign_evidence_var_samp_fields
  variance: double_sign_evidence_variance_fields
}

"order by aggregate values of table \"double_sign_evidence\""
input double_sign_evidence_aggregate_order_by {
  avg: double_sign_evidence_avg_order_by
  count: order_by
  max: double_sign_evidence_max_order_by
  min: double_sign_evidence_min_order_by
  stddev: double_sign_evidence_stddev_order_by
  stddev_pop: double_sign_evidence_stddev_pop_order_by
  stddev_samp: double_sign_evidence_stddev_samp_order_by
  sum: double_sign_evidence_sum_order_by
  var_pop: double_sign_evidence_var_pop_order_by
  var_samp: double_sign_evidence_var_samp_order_by
  variance: double_sign_evidence_variance_order_by
}

"aggregate avg on columns"
type double_sign_evidence_avg_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by avg() on columns of table \"double_sign_evidence\""
input double_sign_evidence_avg_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"Boolean expression to filter rows from the table \"double_sign_evidence\". All fields are combined with a logical 'AND'."
input double_sign_evidence_bool_exp {
  _and: [double_sign_evidence_bool_exp!]
  _not: double_sign_evidence_bool_exp
  _or: [double_sign_evidence_bool_exp!]
  doubleSignVoteByVoteAId: double_sign_vote_bool_exp
  double_sign_vote: double_sign_vote_bool_exp
  height: bigint_comparison_exp
  vote_a_id: bigint_comparison_exp
  vote_b_id: bigint_comparison_exp
}

"aggregate max on columns"
type double_sign_evidence_max_fields {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"order by max() on columns of table \"double_sign_evidence\""
input double_sign_evidence_max_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate min on columns"
type double_sign_evidence_min_fields {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"order by min() on columns of table \"double_sign_evidence\""
input double_sign_evidence_min_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"Ordering options when selecting data from \"double_sign_evidence\"."
input double_sign_evidence_order_by {
  doubleSignVoteByVoteAId: double_sign_vote_order_by
  double_sign_vote: double_sign_vote_order_by
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"select columns of table \"double_sign_evidence\""
enum double_sign_evidence_select_column {
  "column name"
  height
  "column name"
  vote_a_id
  "column name"
  vote_b_id
}

"aggregate stddev on columns"
type double_sign_evidence_stddev_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by stddev() on columns of table \"double_sign_evidence\""
input double_sign_evidence_stddev_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate stddev_pop on columns"
type double_sign_evidence_stddev_pop_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by stddev_pop() on columns of table \"double_sign_evidence\""
input double_sign_evidence_stddev_pop_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate stddev_samp on columns"
type double_sign_evidence_stddev_samp_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by stddev_samp() on columns of table \"double_sign_evidence\""
input double_sign_evidence_stddev_samp_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate sum on columns"
type double_sign_evidence_sum_fields {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"order by sum() on columns of table \"double_sign_evidence\""
input double_sign_evidence_sum_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate var_pop on columns"
type double_sign_evidence_var_pop_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by var_pop() on columns of table \"double_sign_evidence\""
input double_sign_evidence_var_pop_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate var_samp on columns"
type double_sign_evidence_var_samp_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by var_samp() on columns of table \"double_sign_evidence\""
input double_sign_evidence_var_samp_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"aggregate variance on columns"
type double_sign_evidence_variance_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"order by variance() on columns of table \"double_sign_evidence\""
input double_sign_evidence_variance_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"columns and relationships of \"double_sign_vote\""
type double_sign_vote {
  block_id: String!
  "An array relationship"
  doubleSignEvidencesByVoteBId("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): [double_sign_evidence!]!
  "An aggregate relationship"
  doubleSignEvidencesByVoteBId_aggregate("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): double_sign_evidence_aggregate!
  "An array relationship"
  double_sign_evidences("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): [double_sign_evidence!]!
  "An aggregate relationship"
  double_sign_evidences_aggregate("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): double_sign_evidence_aggregate!
  height: bigint!
  id: Int!
  round: Int!
  signature: String!
  type: smallint!
  "An object relationship"
  validator: validator!
  validator_address: String!
  validator_index: Int!
}

"aggregated selection of \"double_sign_vote\""
type double_sign_vote_aggregate {
  aggregate: double_sign_vote_aggregate_fields
  nodes: [double_sign_vote!]!
}

"aggregate fields of \"double_sign_vote\""
type double_sign_vote_aggregate_fields {
  avg: double_sign_vote_avg_fields
  count(columns: [double_sign_vote_select_column!] distinct: Boolean): Int!
  max: double_sign_vote_max_fields
  min: double_sign_vote_min_fields
  stddev: double_sign_vote_stddev_fields
  stddev_pop: double_sign_vote_stddev_pop_fields
  stddev_samp: double_sign_vote_stddev_samp_fields
  sum: double_sign_vote_sum_fields
  var_pop: double_sign_vote_var_pop_fields
  var_samp: double_sign_vote_var_samp_fields
  variance: double_sign_vote_variance_fields
}

"order by aggregate values of table \"double_sign_vote\""
input double_sign_vote_aggregate_order_by {
  avg: double_sign_vote_avg_order_by
  count: order_by
  max: double_sign_vote_max_order_by
  min: double_sign_vote_min_order_by
  stddev: double_sign_vote_stddev_order_by
  stddev_pop: double_sign_vote_stddev_pop_order_by
  stddev_samp: double_sign_vote_stddev_samp_order_by
  sum: double_sign_vote_sum_order_by
  var_pop: double_sign_vote_var_pop_order_by
  var_samp: double_sign_vote_var_samp_order_by
  variance: double_sign_vote_variance_order_by
}

"aggregate avg on columns"
type double_sign_vote_avg_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by avg() on columns of table \"double_sign_vote\""
input double_sign_vote_avg_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"Boolean expression to filter rows from the table \"double_sign_vote\". All fields are combined with a logical 'AND'."
input double_sign_vote_bool_exp {
  _and: [double_sign_vote_bool_exp!]
  _not: double_sign_vote_bool_exp
  _or: [double_sign_vote_bool_exp!]
  block_id: String_comparison_exp
  doubleSignEvidencesByVoteBId: double_sign_evidence_bool_exp
  double_sign_evidences: double_sign_evidence_bool_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  round: Int_comparison_exp
  signature: String_comparison_exp
  type: smallint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  validator_index: Int_comparison_exp
}

"aggregate max on columns"
type double_sign_vote_max_fields {
  block_id: String
  height: bigint
  id: Int
  round: Int
  signature: String
  type: smallint
  validator_address: String
  validator_index: Int
}

"order by max() on columns of table \"double_sign_vote\""
input double_sign_vote_max_order_by {
  block_id: order_by
  height: order_by
  id: order_by
  round: order_by
  signature: order_by
  type: order_by
  validator_address: order_by
  validator_index: order_by
}

"aggregate min on columns"
type double_sign_vote_min_fields {
  block_id: String
  height: bigint
  id: Int
  round: Int
  signature: String
  type: smallint
  validator_address: String
  validator_index: Int
}

"order by min() on columns of table \"double_sign_vote\""
input double_sign_vote_min_order_by {
  block_id: order_by
  height: order_by
  id: order_by
  round: order_by
  signature: order_by
  type: order_by
  validator_address: order_by
  validator_index: order_by
}

"Ordering options when selecting data from \"double_sign_vote\"."
input double_sign_vote_order_by {
  block_id: order_by
  doubleSignEvidencesByVoteBId_aggregate: double_sign_evidence_aggregate_order_by
  double_sign_evidences_aggregate: double_sign_evidence_aggregate_order_by
  height: order_by
  id: order_by
  round: order_by
  signature: order_by
  type: order_by
  validator: validator_order_by
  validator_address: order_by
  validator_index: order_by
}

"select columns of table \"double_sign_vote\""
enum double_sign_vote_select_column {
  "column name"
  block_id
  "column name"
  height
  "column name"
  id
  "column name"
  round
  "column name"
  signature
  "column name"
  type
  "column name"
  validator_address
  "column name"
  validator_index
}

"aggregate stddev on columns"
type double_sign_vote_stddev_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by stddev() on columns of table \"double_sign_vote\""
input double_sign_vote_stddev_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"aggregate stddev_pop on columns"
type double_sign_vote_stddev_pop_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by stddev_pop() on columns of table \"double_sign_vote\""
input double_sign_vote_stddev_pop_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"aggregate stddev_samp on columns"
type double_sign_vote_stddev_samp_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by stddev_samp() on columns of table \"double_sign_vote\""
input double_sign_vote_stddev_samp_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"aggregate sum on columns"
type double_sign_vote_sum_fields {
  height: bigint
  id: Int
  round: Int
  type: smallint
  validator_index: Int
}

"order by sum() on columns of table \"double_sign_vote\""
input double_sign_vote_sum_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"aggregate var_pop on columns"
type double_sign_vote_var_pop_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by var_pop() on columns of table \"double_sign_vote\""
input double_sign_vote_var_pop_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"aggregate var_samp on columns"
type double_sign_vote_var_samp_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by var_samp() on columns of table \"double_sign_vote\""
input double_sign_vote_var_samp_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"aggregate variance on columns"
type double_sign_vote_variance_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"order by variance() on columns of table \"double_sign_vote\""
input double_sign_vote_variance_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"columns and relationships of \"dtag_transfer_requests\""
type dtag_transfer_requests {
  height: bigint!
  "An object relationship"
  profile: profile!
  "An object relationship"
  profileBySenderAddress: profile!
  receiver_address: String!
  sender_address: String!
}

"aggregated selection of \"dtag_transfer_requests\""
type dtag_transfer_requests_aggregate {
  aggregate: dtag_transfer_requests_aggregate_fields
  nodes: [dtag_transfer_requests!]!
}

"aggregate fields of \"dtag_transfer_requests\""
type dtag_transfer_requests_aggregate_fields {
  avg: dtag_transfer_requests_avg_fields
  count(columns: [dtag_transfer_requests_select_column!] distinct: Boolean): Int!
  max: dtag_transfer_requests_max_fields
  min: dtag_transfer_requests_min_fields
  stddev: dtag_transfer_requests_stddev_fields
  stddev_pop: dtag_transfer_requests_stddev_pop_fields
  stddev_samp: dtag_transfer_requests_stddev_samp_fields
  sum: dtag_transfer_requests_sum_fields
  var_pop: dtag_transfer_requests_var_pop_fields
  var_samp: dtag_transfer_requests_var_samp_fields
  variance: dtag_transfer_requests_variance_fields
}

"order by aggregate values of table \"dtag_transfer_requests\""
input dtag_transfer_requests_aggregate_order_by {
  avg: dtag_transfer_requests_avg_order_by
  count: order_by
  max: dtag_transfer_requests_max_order_by
  min: dtag_transfer_requests_min_order_by
  stddev: dtag_transfer_requests_stddev_order_by
  stddev_pop: dtag_transfer_requests_stddev_pop_order_by
  stddev_samp: dtag_transfer_requests_stddev_samp_order_by
  sum: dtag_transfer_requests_sum_order_by
  var_pop: dtag_transfer_requests_var_pop_order_by
  var_samp: dtag_transfer_requests_var_samp_order_by
  variance: dtag_transfer_requests_variance_order_by
}

"aggregate avg on columns"
type dtag_transfer_requests_avg_fields {
  height: Float
}

"order by avg() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"dtag_transfer_requests\". All fields are combined with a logical 'AND'."
input dtag_transfer_requests_bool_exp {
  _and: [dtag_transfer_requests_bool_exp!]
  _not: dtag_transfer_requests_bool_exp
  _or: [dtag_transfer_requests_bool_exp!]
  height: bigint_comparison_exp
  profile: profile_bool_exp
  profileBySenderAddress: profile_bool_exp
  receiver_address: String_comparison_exp
  sender_address: String_comparison_exp
}

"aggregate max on columns"
type dtag_transfer_requests_max_fields {
  height: bigint
  receiver_address: String
  sender_address: String
}

"order by max() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_max_order_by {
  height: order_by
  receiver_address: order_by
  sender_address: order_by
}

"aggregate min on columns"
type dtag_transfer_requests_min_fields {
  height: bigint
  receiver_address: String
  sender_address: String
}

"order by min() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_min_order_by {
  height: order_by
  receiver_address: order_by
  sender_address: order_by
}

"Ordering options when selecting data from \"dtag_transfer_requests\"."
input dtag_transfer_requests_order_by {
  height: order_by
  profile: profile_order_by
  profileBySenderAddress: profile_order_by
  receiver_address: order_by
  sender_address: order_by
}

"select columns of table \"dtag_transfer_requests\""
enum dtag_transfer_requests_select_column {
  "column name"
  height
  "column name"
  receiver_address
  "column name"
  sender_address
}

"aggregate stddev on columns"
type dtag_transfer_requests_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type dtag_transfer_requests_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type dtag_transfer_requests_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type dtag_transfer_requests_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type dtag_transfer_requests_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type dtag_transfer_requests_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type dtag_transfer_requests_variance_fields {
  height: Float
}

"order by variance() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_variance_order_by {
  height: order_by
}

"columns and relationships of \"fee_grant_allowance\""
type fee_grant_allowance {
  allowance("JSON select path" path: String): jsonb!
  grantee_address: String!
  granter_address: String!
  height: bigint!
  id: Int!
}

"aggregated selection of \"fee_grant_allowance\""
type fee_grant_allowance_aggregate {
  aggregate: fee_grant_allowance_aggregate_fields
  nodes: [fee_grant_allowance!]!
}

"aggregate fields of \"fee_grant_allowance\""
type fee_grant_allowance_aggregate_fields {
  avg: fee_grant_allowance_avg_fields
  count(columns: [fee_grant_allowance_select_column!] distinct: Boolean): Int!
  max: fee_grant_allowance_max_fields
  min: fee_grant_allowance_min_fields
  stddev: fee_grant_allowance_stddev_fields
  stddev_pop: fee_grant_allowance_stddev_pop_fields
  stddev_samp: fee_grant_allowance_stddev_samp_fields
  sum: fee_grant_allowance_sum_fields
  var_pop: fee_grant_allowance_var_pop_fields
  var_samp: fee_grant_allowance_var_samp_fields
  variance: fee_grant_allowance_variance_fields
}

"aggregate avg on columns"
type fee_grant_allowance_avg_fields {
  height: Float
  id: Float
}

"Boolean expression to filter rows from the table \"fee_grant_allowance\". All fields are combined with a logical 'AND'."
input fee_grant_allowance_bool_exp {
  _and: [fee_grant_allowance_bool_exp!]
  _not: fee_grant_allowance_bool_exp
  _or: [fee_grant_allowance_bool_exp!]
  allowance: jsonb_comparison_exp
  grantee_address: String_comparison_exp
  granter_address: String_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
}

"aggregate max on columns"
type fee_grant_allowance_max_fields {
  grantee_address: String
  granter_address: String
  height: bigint
  id: Int
}

"aggregate min on columns"
type fee_grant_allowance_min_fields {
  grantee_address: String
  granter_address: String
  height: bigint
  id: Int
}

"Ordering options when selecting data from \"fee_grant_allowance\"."
input fee_grant_allowance_order_by {
  allowance: order_by
  grantee_address: order_by
  granter_address: order_by
  height: order_by
  id: order_by
}

"select columns of table \"fee_grant_allowance\""
enum fee_grant_allowance_select_column {
  "column name"
  allowance
  "column name"
  grantee_address
  "column name"
  granter_address
  "column name"
  height
  "column name"
  id
}

"aggregate stddev on columns"
type fee_grant_allowance_stddev_fields {
  height: Float
  id: Float
}

"aggregate stddev_pop on columns"
type fee_grant_allowance_stddev_pop_fields {
  height: Float
  id: Float
}

"aggregate stddev_samp on columns"
type fee_grant_allowance_stddev_samp_fields {
  height: Float
  id: Float
}

"aggregate sum on columns"
type fee_grant_allowance_sum_fields {
  height: bigint
  id: Int
}

"aggregate var_pop on columns"
type fee_grant_allowance_var_pop_fields {
  height: Float
  id: Float
}

"aggregate var_samp on columns"
type fee_grant_allowance_var_samp_fields {
  height: Float
  id: Float
}

"aggregate variance on columns"
type fee_grant_allowance_variance_fields {
  height: Float
  id: Float
}

"columns and relationships of \"genesis\""
type genesis {
  chain_id: String!
  initial_height: bigint!
  time: timestamp!
}

"aggregated selection of \"genesis\""
type genesis_aggregate {
  aggregate: genesis_aggregate_fields
  nodes: [genesis!]!
}

"aggregate fields of \"genesis\""
type genesis_aggregate_fields {
  avg: genesis_avg_fields
  count(columns: [genesis_select_column!] distinct: Boolean): Int!
  max: genesis_max_fields
  min: genesis_min_fields
  stddev: genesis_stddev_fields
  stddev_pop: genesis_stddev_pop_fields
  stddev_samp: genesis_stddev_samp_fields
  sum: genesis_sum_fields
  var_pop: genesis_var_pop_fields
  var_samp: genesis_var_samp_fields
  variance: genesis_variance_fields
}

"aggregate avg on columns"
type genesis_avg_fields {
  initial_height: Float
}

"Boolean expression to filter rows from the table \"genesis\". All fields are combined with a logical 'AND'."
input genesis_bool_exp {
  _and: [genesis_bool_exp!]
  _not: genesis_bool_exp
  _or: [genesis_bool_exp!]
  chain_id: String_comparison_exp
  initial_height: bigint_comparison_exp
  time: timestamp_comparison_exp
}

"aggregate max on columns"
type genesis_max_fields {
  chain_id: String
  initial_height: bigint
  time: timestamp
}

"aggregate min on columns"
type genesis_min_fields {
  chain_id: String
  initial_height: bigint
  time: timestamp
}

"Ordering options when selecting data from \"genesis\"."
input genesis_order_by {
  chain_id: order_by
  initial_height: order_by
  time: order_by
}

"select columns of table \"genesis\""
enum genesis_select_column {
  "column name"
  chain_id
  "column name"
  initial_height
  "column name"
  time
}

"aggregate stddev on columns"
type genesis_stddev_fields {
  initial_height: Float
}

"aggregate stddev_pop on columns"
type genesis_stddev_pop_fields {
  initial_height: Float
}

"aggregate stddev_samp on columns"
type genesis_stddev_samp_fields {
  initial_height: Float
}

"aggregate sum on columns"
type genesis_sum_fields {
  initial_height: bigint
}

"aggregate var_pop on columns"
type genesis_var_pop_fields {
  initial_height: Float
}

"aggregate var_samp on columns"
type genesis_var_samp_fields {
  initial_height: Float
}

"aggregate variance on columns"
type genesis_variance_fields {
  initial_height: Float
}

"columns and relationships of \"gov_params\""
type gov_params {
  deposit_params("JSON select path" path: String): jsonb!
  height: bigint!
  one_row_id: Boolean!
  tally_params("JSON select path" path: String): jsonb!
  voting_params("JSON select path" path: String): jsonb!
}

"aggregated selection of \"gov_params\""
type gov_params_aggregate {
  aggregate: gov_params_aggregate_fields
  nodes: [gov_params!]!
}

"aggregate fields of \"gov_params\""
type gov_params_aggregate_fields {
  avg: gov_params_avg_fields
  count(columns: [gov_params_select_column!] distinct: Boolean): Int!
  max: gov_params_max_fields
  min: gov_params_min_fields
  stddev: gov_params_stddev_fields
  stddev_pop: gov_params_stddev_pop_fields
  stddev_samp: gov_params_stddev_samp_fields
  sum: gov_params_sum_fields
  var_pop: gov_params_var_pop_fields
  var_samp: gov_params_var_samp_fields
  variance: gov_params_variance_fields
}

"aggregate avg on columns"
type gov_params_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"gov_params\". All fields are combined with a logical 'AND'."
input gov_params_bool_exp {
  _and: [gov_params_bool_exp!]
  _not: gov_params_bool_exp
  _or: [gov_params_bool_exp!]
  deposit_params: jsonb_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  tally_params: jsonb_comparison_exp
  voting_params: jsonb_comparison_exp
}

"aggregate max on columns"
type gov_params_max_fields {
  height: bigint
}

"aggregate min on columns"
type gov_params_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"gov_params\"."
input gov_params_order_by {
  deposit_params: order_by
  height: order_by
  one_row_id: order_by
  tally_params: order_by
  voting_params: order_by
}

"select columns of table \"gov_params\""
enum gov_params_select_column {
  "column name"
  deposit_params
  "column name"
  height
  "column name"
  one_row_id
  "column name"
  tally_params
  "column name"
  voting_params
}

"aggregate stddev on columns"
type gov_params_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type gov_params_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type gov_params_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type gov_params_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type gov_params_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type gov_params_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type gov_params_variance_fields {
  height: Float
}

"columns and relationships of \"inflation\""
type inflation {
  height: bigint!
  value: numeric!
}

"aggregated selection of \"inflation\""
type inflation_aggregate {
  aggregate: inflation_aggregate_fields
  nodes: [inflation!]!
}

"aggregate fields of \"inflation\""
type inflation_aggregate_fields {
  avg: inflation_avg_fields
  count(columns: [inflation_select_column!] distinct: Boolean): Int!
  max: inflation_max_fields
  min: inflation_min_fields
  stddev: inflation_stddev_fields
  stddev_pop: inflation_stddev_pop_fields
  stddev_samp: inflation_stddev_samp_fields
  sum: inflation_sum_fields
  var_pop: inflation_var_pop_fields
  var_samp: inflation_var_samp_fields
  variance: inflation_variance_fields
}

"aggregate avg on columns"
type inflation_avg_fields {
  height: Float
  value: Float
}

"Boolean expression to filter rows from the table \"inflation\". All fields are combined with a logical 'AND'."
input inflation_bool_exp {
  _and: [inflation_bool_exp!]
  _not: inflation_bool_exp
  _or: [inflation_bool_exp!]
  height: bigint_comparison_exp
  value: numeric_comparison_exp
}

"aggregate max on columns"
type inflation_max_fields {
  height: bigint
  value: numeric
}

"aggregate min on columns"
type inflation_min_fields {
  height: bigint
  value: numeric
}

"Ordering options when selecting data from \"inflation\"."
input inflation_order_by {
  height: order_by
  value: order_by
}

"select columns of table \"inflation\""
enum inflation_select_column {
  "column name"
  height
  "column name"
  value
}

"aggregate stddev on columns"
type inflation_stddev_fields {
  height: Float
  value: Float
}

"aggregate stddev_pop on columns"
type inflation_stddev_pop_fields {
  height: Float
  value: Float
}

"aggregate stddev_samp on columns"
type inflation_stddev_samp_fields {
  height: Float
  value: Float
}

"aggregate sum on columns"
type inflation_sum_fields {
  height: bigint
  value: numeric
}

"aggregate var_pop on columns"
type inflation_var_pop_fields {
  height: Float
  value: Float
}

"aggregate var_samp on columns"
type inflation_var_samp_fields {
  height: Float
  value: Float
}

"aggregate variance on columns"
type inflation_variance_fields {
  height: Float
  value: Float
}

scalar jsonb

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"columns and relationships of \"message\""
type message {
  index: bigint!
  involved_accounts_addresses: _text
  "An object relationship"
  transaction: transaction!
  transaction_hash: String!
  type: String!
  value("JSON select path" path: String): jsonb!
}

"aggregated selection of \"message\""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

"aggregate fields of \"message\""
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!] distinct: Boolean): Int!
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

"order by aggregate values of table \"message\""
input message_aggregate_order_by {
  avg: message_avg_order_by
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
  stddev: message_stddev_order_by
  stddev_pop: message_stddev_pop_order_by
  stddev_samp: message_stddev_samp_order_by
  sum: message_sum_order_by
  var_pop: message_var_pop_order_by
  var_samp: message_var_samp_order_by
  variance: message_variance_order_by
}

"aggregate avg on columns"
type message_avg_fields {
  index: Float
}

"order by avg() on columns of table \"message\""
input message_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"message\". All fields are combined with a logical 'AND'."
input message_bool_exp {
  _and: [message_bool_exp!]
  _not: message_bool_exp
  _or: [message_bool_exp!]
  index: bigint_comparison_exp
  involved_accounts_addresses: _text_comparison_exp
  transaction: transaction_bool_exp
  transaction_hash: String_comparison_exp
  type: String_comparison_exp
  value: jsonb_comparison_exp
}

"aggregate max on columns"
type message_max_fields {
  index: bigint
  transaction_hash: String
  type: String
}

"order by max() on columns of table \"message\""
input message_max_order_by {
  index: order_by
  transaction_hash: order_by
  type: order_by
}

"aggregate min on columns"
type message_min_fields {
  index: bigint
  transaction_hash: String
  type: String
}

"order by min() on columns of table \"message\""
input message_min_order_by {
  index: order_by
  transaction_hash: order_by
  type: order_by
}

"Ordering options when selecting data from \"message\"."
input message_order_by {
  index: order_by
  involved_accounts_addresses: order_by
  transaction: transaction_order_by
  transaction_hash: order_by
  type: order_by
  value: order_by
}

"select columns of table \"message\""
enum message_select_column {
  "column name"
  index
  "column name"
  involved_accounts_addresses
  "column name"
  transaction_hash
  "column name"
  type
  "column name"
  value
}

"aggregate stddev on columns"
type message_stddev_fields {
  index: Float
}

"order by stddev() on columns of table \"message\""
input message_stddev_order_by {
  index: order_by
}

"aggregate stddev_pop on columns"
type message_stddev_pop_fields {
  index: Float
}

"order by stddev_pop() on columns of table \"message\""
input message_stddev_pop_order_by {
  index: order_by
}

"aggregate stddev_samp on columns"
type message_stddev_samp_fields {
  index: Float
}

"order by stddev_samp() on columns of table \"message\""
input message_stddev_samp_order_by {
  index: order_by
}

"aggregate sum on columns"
type message_sum_fields {
  index: bigint
}

"order by sum() on columns of table \"message\""
input message_sum_order_by {
  index: order_by
}

"aggregate var_pop on columns"
type message_var_pop_fields {
  index: Float
}

"order by var_pop() on columns of table \"message\""
input message_var_pop_order_by {
  index: order_by
}

"aggregate var_samp on columns"
type message_var_samp_fields {
  index: Float
}

"order by var_samp() on columns of table \"message\""
input message_var_samp_order_by {
  index: order_by
}

"aggregate variance on columns"
type message_variance_fields {
  index: Float
}

"order by variance() on columns of table \"message\""
input message_variance_order_by {
  index: order_by
}

input messages_by_address_args {
  addresses: _text
  limit: bigint
  offset: bigint
  types: _text
}

"columns and relationships of \"mint_params\""
type mint_params {
  height: bigint!
  one_row_id: Boolean!
  params("JSON select path" path: String): jsonb!
}

"aggregated selection of \"mint_params\""
type mint_params_aggregate {
  aggregate: mint_params_aggregate_fields
  nodes: [mint_params!]!
}

"aggregate fields of \"mint_params\""
type mint_params_aggregate_fields {
  avg: mint_params_avg_fields
  count(columns: [mint_params_select_column!] distinct: Boolean): Int!
  max: mint_params_max_fields
  min: mint_params_min_fields
  stddev: mint_params_stddev_fields
  stddev_pop: mint_params_stddev_pop_fields
  stddev_samp: mint_params_stddev_samp_fields
  sum: mint_params_sum_fields
  var_pop: mint_params_var_pop_fields
  var_samp: mint_params_var_samp_fields
  variance: mint_params_variance_fields
}

"aggregate avg on columns"
type mint_params_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"mint_params\". All fields are combined with a logical 'AND'."
input mint_params_bool_exp {
  _and: [mint_params_bool_exp!]
  _not: mint_params_bool_exp
  _or: [mint_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"aggregate max on columns"
type mint_params_max_fields {
  height: bigint
}

"aggregate min on columns"
type mint_params_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"mint_params\"."
input mint_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"select columns of table \"mint_params\""
enum mint_params_select_column {
  "column name"
  height
  "column name"
  one_row_id
  "column name"
  params
}

"aggregate stddev on columns"
type mint_params_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type mint_params_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type mint_params_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type mint_params_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type mint_params_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type mint_params_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type mint_params_variance_fields {
  height: Float
}

"columns and relationships of \"modules\""
type modules {
  module_name: String!
}

"aggregated selection of \"modules\""
type modules_aggregate {
  aggregate: modules_aggregate_fields
  nodes: [modules!]!
}

"aggregate fields of \"modules\""
type modules_aggregate_fields {
  count(columns: [modules_select_column!] distinct: Boolean): Int!
  max: modules_max_fields
  min: modules_min_fields
}

"Boolean expression to filter rows from the table \"modules\". All fields are combined with a logical 'AND'."
input modules_bool_exp {
  _and: [modules_bool_exp!]
  _not: modules_bool_exp
  _or: [modules_bool_exp!]
  module_name: String_comparison_exp
}

"aggregate max on columns"
type modules_max_fields {
  module_name: String
}

"aggregate min on columns"
type modules_min_fields {
  module_name: String
}

"Ordering options when selecting data from \"modules\"."
input modules_order_by {
  module_name: order_by
}

"select columns of table \"modules\""
enum modules_select_column {
  "column name"
  module_name
}

scalar numeric

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"columns and relationships of \"poll\""
type poll {
  allows_answer_edits: Boolean!
  allows_multiple_answers: Boolean!
  end_date: timestamp!
  id: Int!
  "An array relationship"
  poll_answers("distinct select on columns" distinct_on: [poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_answer_order_by!] "filter the rows returned" where: poll_answer_bool_exp): [poll_answer!]!
  "An aggregate relationship"
  poll_answers_aggregate("distinct select on columns" distinct_on: [poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_answer_order_by!] "filter the rows returned" where: poll_answer_bool_exp): poll_answer_aggregate!
  "An object relationship"
  post: post!
  post_id: String!
  question: String!
  "An array relationship"
  user_poll_answers("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): [user_poll_answer!]!
  "An aggregate relationship"
  user_poll_answers_aggregate("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): user_poll_answer_aggregate!
}

"aggregated selection of \"poll\""
type poll_aggregate {
  aggregate: poll_aggregate_fields
  nodes: [poll!]!
}

"aggregate fields of \"poll\""
type poll_aggregate_fields {
  avg: poll_avg_fields
  count(columns: [poll_select_column!] distinct: Boolean): Int!
  max: poll_max_fields
  min: poll_min_fields
  stddev: poll_stddev_fields
  stddev_pop: poll_stddev_pop_fields
  stddev_samp: poll_stddev_samp_fields
  sum: poll_sum_fields
  var_pop: poll_var_pop_fields
  var_samp: poll_var_samp_fields
  variance: poll_variance_fields
}

"columns and relationships of \"poll_answer\""
type poll_answer {
  answer_id: String!
  answer_text: String!
  "An object relationship"
  poll: poll!
  poll_id: Int!
}

"aggregated selection of \"poll_answer\""
type poll_answer_aggregate {
  aggregate: poll_answer_aggregate_fields
  nodes: [poll_answer!]!
}

"aggregate fields of \"poll_answer\""
type poll_answer_aggregate_fields {
  avg: poll_answer_avg_fields
  count(columns: [poll_answer_select_column!] distinct: Boolean): Int!
  max: poll_answer_max_fields
  min: poll_answer_min_fields
  stddev: poll_answer_stddev_fields
  stddev_pop: poll_answer_stddev_pop_fields
  stddev_samp: poll_answer_stddev_samp_fields
  sum: poll_answer_sum_fields
  var_pop: poll_answer_var_pop_fields
  var_samp: poll_answer_var_samp_fields
  variance: poll_answer_variance_fields
}

"order by aggregate values of table \"poll_answer\""
input poll_answer_aggregate_order_by {
  avg: poll_answer_avg_order_by
  count: order_by
  max: poll_answer_max_order_by
  min: poll_answer_min_order_by
  stddev: poll_answer_stddev_order_by
  stddev_pop: poll_answer_stddev_pop_order_by
  stddev_samp: poll_answer_stddev_samp_order_by
  sum: poll_answer_sum_order_by
  var_pop: poll_answer_var_pop_order_by
  var_samp: poll_answer_var_samp_order_by
  variance: poll_answer_variance_order_by
}

"aggregate avg on columns"
type poll_answer_avg_fields {
  poll_id: Float
}

"order by avg() on columns of table \"poll_answer\""
input poll_answer_avg_order_by {
  poll_id: order_by
}

"Boolean expression to filter rows from the table \"poll_answer\". All fields are combined with a logical 'AND'."
input poll_answer_bool_exp {
  _and: [poll_answer_bool_exp!]
  _not: poll_answer_bool_exp
  _or: [poll_answer_bool_exp!]
  answer_id: String_comparison_exp
  answer_text: String_comparison_exp
  poll: poll_bool_exp
  poll_id: Int_comparison_exp
}

"aggregate max on columns"
type poll_answer_max_fields {
  answer_id: String
  answer_text: String
  poll_id: Int
}

"order by max() on columns of table \"poll_answer\""
input poll_answer_max_order_by {
  answer_id: order_by
  answer_text: order_by
  poll_id: order_by
}

"aggregate min on columns"
type poll_answer_min_fields {
  answer_id: String
  answer_text: String
  poll_id: Int
}

"order by min() on columns of table \"poll_answer\""
input poll_answer_min_order_by {
  answer_id: order_by
  answer_text: order_by
  poll_id: order_by
}

"Ordering options when selecting data from \"poll_answer\"."
input poll_answer_order_by {
  answer_id: order_by
  answer_text: order_by
  poll: poll_order_by
  poll_id: order_by
}

"select columns of table \"poll_answer\""
enum poll_answer_select_column {
  "column name"
  answer_id
  "column name"
  answer_text
  "column name"
  poll_id
}

"aggregate stddev on columns"
type poll_answer_stddev_fields {
  poll_id: Float
}

"order by stddev() on columns of table \"poll_answer\""
input poll_answer_stddev_order_by {
  poll_id: order_by
}

"aggregate stddev_pop on columns"
type poll_answer_stddev_pop_fields {
  poll_id: Float
}

"order by stddev_pop() on columns of table \"poll_answer\""
input poll_answer_stddev_pop_order_by {
  poll_id: order_by
}

"aggregate stddev_samp on columns"
type poll_answer_stddev_samp_fields {
  poll_id: Float
}

"order by stddev_samp() on columns of table \"poll_answer\""
input poll_answer_stddev_samp_order_by {
  poll_id: order_by
}

"aggregate sum on columns"
type poll_answer_sum_fields {
  poll_id: Int
}

"order by sum() on columns of table \"poll_answer\""
input poll_answer_sum_order_by {
  poll_id: order_by
}

"aggregate var_pop on columns"
type poll_answer_var_pop_fields {
  poll_id: Float
}

"order by var_pop() on columns of table \"poll_answer\""
input poll_answer_var_pop_order_by {
  poll_id: order_by
}

"aggregate var_samp on columns"
type poll_answer_var_samp_fields {
  poll_id: Float
}

"order by var_samp() on columns of table \"poll_answer\""
input poll_answer_var_samp_order_by {
  poll_id: order_by
}

"aggregate variance on columns"
type poll_answer_variance_fields {
  poll_id: Float
}

"order by variance() on columns of table \"poll_answer\""
input poll_answer_variance_order_by {
  poll_id: order_by
}

"aggregate avg on columns"
type poll_avg_fields {
  id: Float
}

"Boolean expression to filter rows from the table \"poll\". All fields are combined with a logical 'AND'."
input poll_bool_exp {
  _and: [poll_bool_exp!]
  _not: poll_bool_exp
  _or: [poll_bool_exp!]
  allows_answer_edits: Boolean_comparison_exp
  allows_multiple_answers: Boolean_comparison_exp
  end_date: timestamp_comparison_exp
  id: Int_comparison_exp
  poll_answers: poll_answer_bool_exp
  post: post_bool_exp
  post_id: String_comparison_exp
  question: String_comparison_exp
  user_poll_answers: user_poll_answer_bool_exp
}

"aggregate max on columns"
type poll_max_fields {
  end_date: timestamp
  id: Int
  post_id: String
  question: String
}

"aggregate min on columns"
type poll_min_fields {
  end_date: timestamp
  id: Int
  post_id: String
  question: String
}

"Ordering options when selecting data from \"poll\"."
input poll_order_by {
  allows_answer_edits: order_by
  allows_multiple_answers: order_by
  end_date: order_by
  id: order_by
  poll_answers_aggregate: poll_answer_aggregate_order_by
  post: post_order_by
  post_id: order_by
  question: order_by
  user_poll_answers_aggregate: user_poll_answer_aggregate_order_by
}

"select columns of table \"poll\""
enum poll_select_column {
  "column name"
  allows_answer_edits
  "column name"
  allows_multiple_answers
  "column name"
  end_date
  "column name"
  id
  "column name"
  post_id
  "column name"
  question
}

"aggregate stddev on columns"
type poll_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type poll_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type poll_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type poll_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type poll_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type poll_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type poll_variance_fields {
  id: Float
}

"columns and relationships of \"post\""
type post {
  comments_state: String!
  created: timestamp!
  creator_address: String!
  height: bigint!
  hidden: Boolean!
  id: String!
  last_edited: timestamp!
  message: String!
  parent_id: String
  "An object relationship"
  poll: poll!
  "An object relationship"
  post: post
  "An array relationship"
  post_attachments("distinct select on columns" distinct_on: [post_attachment_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_order_by!] "filter the rows returned" where: post_attachment_bool_exp): [post_attachment!]!
  "An aggregate relationship"
  post_attachments_aggregate("distinct select on columns" distinct_on: [post_attachment_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_order_by!] "filter the rows returned" where: post_attachment_bool_exp): post_attachment_aggregate!
  "An array relationship"
  post_attributes("distinct select on columns" distinct_on: [post_attribute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attribute_order_by!] "filter the rows returned" where: post_attribute_bool_exp): [post_attribute!]!
  "An aggregate relationship"
  post_attributes_aggregate("distinct select on columns" distinct_on: [post_attribute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attribute_order_by!] "filter the rows returned" where: post_attribute_bool_exp): post_attribute_aggregate!
  "An array relationship"
  post_reactions("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): [post_reaction!]!
  "An aggregate relationship"
  post_reactions_aggregate("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): post_reaction_aggregate!
  "An array relationship"
  post_reports("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): [post_report!]!
  "An aggregate relationship"
  post_reports_aggregate("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): post_report_aggregate!
  "An array relationship"
  posts("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): [post!]!
  "An aggregate relationship"
  posts_aggregate("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): post_aggregate!
  "An object relationship"
  profile: profile!
  subspace: String!
}

"aggregated selection of \"post\""
type post_aggregate {
  aggregate: post_aggregate_fields
  nodes: [post!]!
}

"aggregate fields of \"post\""
type post_aggregate_fields {
  avg: post_avg_fields
  count(columns: [post_select_column!] distinct: Boolean): Int!
  max: post_max_fields
  min: post_min_fields
  stddev: post_stddev_fields
  stddev_pop: post_stddev_pop_fields
  stddev_samp: post_stddev_samp_fields
  sum: post_sum_fields
  var_pop: post_var_pop_fields
  var_samp: post_var_samp_fields
  variance: post_variance_fields
}

"order by aggregate values of table \"post\""
input post_aggregate_order_by {
  avg: post_avg_order_by
  count: order_by
  max: post_max_order_by
  min: post_min_order_by
  stddev: post_stddev_order_by
  stddev_pop: post_stddev_pop_order_by
  stddev_samp: post_stddev_samp_order_by
  sum: post_sum_order_by
  var_pop: post_var_pop_order_by
  var_samp: post_var_samp_order_by
  variance: post_variance_order_by
}

"columns and relationships of \"post_attachment\""
type post_attachment {
  id: Int!
  mime_type: String!
  "An object relationship"
  post: post!
  "An array relationship"
  post_attachment_tags("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): [post_attachment_tag!]!
  "An aggregate relationship"
  post_attachment_tags_aggregate("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): post_attachment_tag_aggregate!
  post_id: String!
  uri: String!
}

"aggregated selection of \"post_attachment\""
type post_attachment_aggregate {
  aggregate: post_attachment_aggregate_fields
  nodes: [post_attachment!]!
}

"aggregate fields of \"post_attachment\""
type post_attachment_aggregate_fields {
  avg: post_attachment_avg_fields
  count(columns: [post_attachment_select_column!] distinct: Boolean): Int!
  max: post_attachment_max_fields
  min: post_attachment_min_fields
  stddev: post_attachment_stddev_fields
  stddev_pop: post_attachment_stddev_pop_fields
  stddev_samp: post_attachment_stddev_samp_fields
  sum: post_attachment_sum_fields
  var_pop: post_attachment_var_pop_fields
  var_samp: post_attachment_var_samp_fields
  variance: post_attachment_variance_fields
}

"order by aggregate values of table \"post_attachment\""
input post_attachment_aggregate_order_by {
  avg: post_attachment_avg_order_by
  count: order_by
  max: post_attachment_max_order_by
  min: post_attachment_min_order_by
  stddev: post_attachment_stddev_order_by
  stddev_pop: post_attachment_stddev_pop_order_by
  stddev_samp: post_attachment_stddev_samp_order_by
  sum: post_attachment_sum_order_by
  var_pop: post_attachment_var_pop_order_by
  var_samp: post_attachment_var_samp_order_by
  variance: post_attachment_variance_order_by
}

"aggregate avg on columns"
type post_attachment_avg_fields {
  id: Float
}

"order by avg() on columns of table \"post_attachment\""
input post_attachment_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"post_attachment\". All fields are combined with a logical 'AND'."
input post_attachment_bool_exp {
  _and: [post_attachment_bool_exp!]
  _not: post_attachment_bool_exp
  _or: [post_attachment_bool_exp!]
  id: Int_comparison_exp
  mime_type: String_comparison_exp
  post: post_bool_exp
  post_attachment_tags: post_attachment_tag_bool_exp
  post_id: String_comparison_exp
  uri: String_comparison_exp
}

"aggregate max on columns"
type post_attachment_max_fields {
  id: Int
  mime_type: String
  post_id: String
  uri: String
}

"order by max() on columns of table \"post_attachment\""
input post_attachment_max_order_by {
  id: order_by
  mime_type: order_by
  post_id: order_by
  uri: order_by
}

"aggregate min on columns"
type post_attachment_min_fields {
  id: Int
  mime_type: String
  post_id: String
  uri: String
}

"order by min() on columns of table \"post_attachment\""
input post_attachment_min_order_by {
  id: order_by
  mime_type: order_by
  post_id: order_by
  uri: order_by
}

"Ordering options when selecting data from \"post_attachment\"."
input post_attachment_order_by {
  id: order_by
  mime_type: order_by
  post: post_order_by
  post_attachment_tags_aggregate: post_attachment_tag_aggregate_order_by
  post_id: order_by
  uri: order_by
}

"select columns of table \"post_attachment\""
enum post_attachment_select_column {
  "column name"
  id
  "column name"
  mime_type
  "column name"
  post_id
  "column name"
  uri
}

"aggregate stddev on columns"
type post_attachment_stddev_fields {
  id: Float
}

"order by stddev() on columns of table \"post_attachment\""
input post_attachment_stddev_order_by {
  id: order_by
}

"aggregate stddev_pop on columns"
type post_attachment_stddev_pop_fields {
  id: Float
}

"order by stddev_pop() on columns of table \"post_attachment\""
input post_attachment_stddev_pop_order_by {
  id: order_by
}

"aggregate stddev_samp on columns"
type post_attachment_stddev_samp_fields {
  id: Float
}

"order by stddev_samp() on columns of table \"post_attachment\""
input post_attachment_stddev_samp_order_by {
  id: order_by
}

"aggregate sum on columns"
type post_attachment_sum_fields {
  id: Int
}

"order by sum() on columns of table \"post_attachment\""
input post_attachment_sum_order_by {
  id: order_by
}

"columns and relationships of \"post_attachment_tag\""
type post_attachment_tag {
  attachment_id: Int!
  "An object relationship"
  post_attachment: post_attachment!
  "An object relationship"
  profile: profile!
  tag_address: String!
}

"aggregated selection of \"post_attachment_tag\""
type post_attachment_tag_aggregate {
  aggregate: post_attachment_tag_aggregate_fields
  nodes: [post_attachment_tag!]!
}

"aggregate fields of \"post_attachment_tag\""
type post_attachment_tag_aggregate_fields {
  avg: post_attachment_tag_avg_fields
  count(columns: [post_attachment_tag_select_column!] distinct: Boolean): Int!
  max: post_attachment_tag_max_fields
  min: post_attachment_tag_min_fields
  stddev: post_attachment_tag_stddev_fields
  stddev_pop: post_attachment_tag_stddev_pop_fields
  stddev_samp: post_attachment_tag_stddev_samp_fields
  sum: post_attachment_tag_sum_fields
  var_pop: post_attachment_tag_var_pop_fields
  var_samp: post_attachment_tag_var_samp_fields
  variance: post_attachment_tag_variance_fields
}

"order by aggregate values of table \"post_attachment_tag\""
input post_attachment_tag_aggregate_order_by {
  avg: post_attachment_tag_avg_order_by
  count: order_by
  max: post_attachment_tag_max_order_by
  min: post_attachment_tag_min_order_by
  stddev: post_attachment_tag_stddev_order_by
  stddev_pop: post_attachment_tag_stddev_pop_order_by
  stddev_samp: post_attachment_tag_stddev_samp_order_by
  sum: post_attachment_tag_sum_order_by
  var_pop: post_attachment_tag_var_pop_order_by
  var_samp: post_attachment_tag_var_samp_order_by
  variance: post_attachment_tag_variance_order_by
}

"aggregate avg on columns"
type post_attachment_tag_avg_fields {
  attachment_id: Float
}

"order by avg() on columns of table \"post_attachment_tag\""
input post_attachment_tag_avg_order_by {
  attachment_id: order_by
}

"Boolean expression to filter rows from the table \"post_attachment_tag\". All fields are combined with a logical 'AND'."
input post_attachment_tag_bool_exp {
  _and: [post_attachment_tag_bool_exp!]
  _not: post_attachment_tag_bool_exp
  _or: [post_attachment_tag_bool_exp!]
  attachment_id: Int_comparison_exp
  post_attachment: post_attachment_bool_exp
  profile: profile_bool_exp
  tag_address: String_comparison_exp
}

"aggregate max on columns"
type post_attachment_tag_max_fields {
  attachment_id: Int
  tag_address: String
}

"order by max() on columns of table \"post_attachment_tag\""
input post_attachment_tag_max_order_by {
  attachment_id: order_by
  tag_address: order_by
}

"aggregate min on columns"
type post_attachment_tag_min_fields {
  attachment_id: Int
  tag_address: String
}

"order by min() on columns of table \"post_attachment_tag\""
input post_attachment_tag_min_order_by {
  attachment_id: order_by
  tag_address: order_by
}

"Ordering options when selecting data from \"post_attachment_tag\"."
input post_attachment_tag_order_by {
  attachment_id: order_by
  post_attachment: post_attachment_order_by
  profile: profile_order_by
  tag_address: order_by
}

"select columns of table \"post_attachment_tag\""
enum post_attachment_tag_select_column {
  "column name"
  attachment_id
  "column name"
  tag_address
}

"aggregate stddev on columns"
type post_attachment_tag_stddev_fields {
  attachment_id: Float
}

"order by stddev() on columns of table \"post_attachment_tag\""
input post_attachment_tag_stddev_order_by {
  attachment_id: order_by
}

"aggregate stddev_pop on columns"
type post_attachment_tag_stddev_pop_fields {
  attachment_id: Float
}

"order by stddev_pop() on columns of table \"post_attachment_tag\""
input post_attachment_tag_stddev_pop_order_by {
  attachment_id: order_by
}

"aggregate stddev_samp on columns"
type post_attachment_tag_stddev_samp_fields {
  attachment_id: Float
}

"order by stddev_samp() on columns of table \"post_attachment_tag\""
input post_attachment_tag_stddev_samp_order_by {
  attachment_id: order_by
}

"aggregate sum on columns"
type post_attachment_tag_sum_fields {
  attachment_id: Int
}

"order by sum() on columns of table \"post_attachment_tag\""
input post_attachment_tag_sum_order_by {
  attachment_id: order_by
}

"aggregate var_pop on columns"
type post_attachment_tag_var_pop_fields {
  attachment_id: Float
}

"order by var_pop() on columns of table \"post_attachment_tag\""
input post_attachment_tag_var_pop_order_by {
  attachment_id: order_by
}

"aggregate var_samp on columns"
type post_attachment_tag_var_samp_fields {
  attachment_id: Float
}

"order by var_samp() on columns of table \"post_attachment_tag\""
input post_attachment_tag_var_samp_order_by {
  attachment_id: order_by
}

"aggregate variance on columns"
type post_attachment_tag_variance_fields {
  attachment_id: Float
}

"order by variance() on columns of table \"post_attachment_tag\""
input post_attachment_tag_variance_order_by {
  attachment_id: order_by
}

"aggregate var_pop on columns"
type post_attachment_var_pop_fields {
  id: Float
}

"order by var_pop() on columns of table \"post_attachment\""
input post_attachment_var_pop_order_by {
  id: order_by
}

"aggregate var_samp on columns"
type post_attachment_var_samp_fields {
  id: Float
}

"order by var_samp() on columns of table \"post_attachment\""
input post_attachment_var_samp_order_by {
  id: order_by
}

"aggregate variance on columns"
type post_attachment_variance_fields {
  id: Float
}

"order by variance() on columns of table \"post_attachment\""
input post_attachment_variance_order_by {
  id: order_by
}

"columns and relationships of \"post_attribute\""
type post_attribute {
  key: String!
  "An object relationship"
  post: post!
  post_id: String!
  value: String!
}

"aggregated selection of \"post_attribute\""
type post_attribute_aggregate {
  aggregate: post_attribute_aggregate_fields
  nodes: [post_attribute!]!
}

"aggregate fields of \"post_attribute\""
type post_attribute_aggregate_fields {
  count(columns: [post_attribute_select_column!] distinct: Boolean): Int!
  max: post_attribute_max_fields
  min: post_attribute_min_fields
}

"order by aggregate values of table \"post_attribute\""
input post_attribute_aggregate_order_by {
  count: order_by
  max: post_attribute_max_order_by
  min: post_attribute_min_order_by
}

"Boolean expression to filter rows from the table \"post_attribute\". All fields are combined with a logical 'AND'."
input post_attribute_bool_exp {
  _and: [post_attribute_bool_exp!]
  _not: post_attribute_bool_exp
  _or: [post_attribute_bool_exp!]
  key: String_comparison_exp
  post: post_bool_exp
  post_id: String_comparison_exp
  value: String_comparison_exp
}

"aggregate max on columns"
type post_attribute_max_fields {
  key: String
  post_id: String
  value: String
}

"order by max() on columns of table \"post_attribute\""
input post_attribute_max_order_by {
  key: order_by
  post_id: order_by
  value: order_by
}

"aggregate min on columns"
type post_attribute_min_fields {
  key: String
  post_id: String
  value: String
}

"order by min() on columns of table \"post_attribute\""
input post_attribute_min_order_by {
  key: order_by
  post_id: order_by
  value: order_by
}

"Ordering options when selecting data from \"post_attribute\"."
input post_attribute_order_by {
  key: order_by
  post: post_order_by
  post_id: order_by
  value: order_by
}

"select columns of table \"post_attribute\""
enum post_attribute_select_column {
  "column name"
  key
  "column name"
  post_id
  "column name"
  value
}

"aggregate avg on columns"
type post_avg_fields {
  height: Float
}

"order by avg() on columns of table \"post\""
input post_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"post\". All fields are combined with a logical 'AND'."
input post_bool_exp {
  _and: [post_bool_exp!]
  _not: post_bool_exp
  _or: [post_bool_exp!]
  comments_state: String_comparison_exp
  created: timestamp_comparison_exp
  creator_address: String_comparison_exp
  height: bigint_comparison_exp
  hidden: Boolean_comparison_exp
  id: String_comparison_exp
  last_edited: timestamp_comparison_exp
  message: String_comparison_exp
  parent_id: String_comparison_exp
  poll: poll_bool_exp
  post: post_bool_exp
  post_attachments: post_attachment_bool_exp
  post_attributes: post_attribute_bool_exp
  post_reactions: post_reaction_bool_exp
  post_reports: post_report_bool_exp
  posts: post_bool_exp
  profile: profile_bool_exp
  subspace: String_comparison_exp
}

"aggregate max on columns"
type post_max_fields {
  comments_state: String
  created: timestamp
  creator_address: String
  height: bigint
  id: String
  last_edited: timestamp
  message: String
  parent_id: String
  subspace: String
}

"order by max() on columns of table \"post\""
input post_max_order_by {
  comments_state: order_by
  created: order_by
  creator_address: order_by
  height: order_by
  id: order_by
  last_edited: order_by
  message: order_by
  parent_id: order_by
  subspace: order_by
}

"aggregate min on columns"
type post_min_fields {
  comments_state: String
  created: timestamp
  creator_address: String
  height: bigint
  id: String
  last_edited: timestamp
  message: String
  parent_id: String
  subspace: String
}

"order by min() on columns of table \"post\""
input post_min_order_by {
  comments_state: order_by
  created: order_by
  creator_address: order_by
  height: order_by
  id: order_by
  last_edited: order_by
  message: order_by
  parent_id: order_by
  subspace: order_by
}

"Ordering options when selecting data from \"post\"."
input post_order_by {
  comments_state: order_by
  created: order_by
  creator_address: order_by
  height: order_by
  hidden: order_by
  id: order_by
  last_edited: order_by
  message: order_by
  parent_id: order_by
  poll: poll_order_by
  post: post_order_by
  post_attachments_aggregate: post_attachment_aggregate_order_by
  post_attributes_aggregate: post_attribute_aggregate_order_by
  post_reactions_aggregate: post_reaction_aggregate_order_by
  post_reports_aggregate: post_report_aggregate_order_by
  posts_aggregate: post_aggregate_order_by
  profile: profile_order_by
  subspace: order_by
}

"columns and relationships of \"post_reaction\""
type post_reaction {
  height: bigint!
  owner_address: String!
  "An object relationship"
  post: post!
  post_id: String!
  "An object relationship"
  profile: profile!
  short_code: String!
  value: String!
}

"aggregated selection of \"post_reaction\""
type post_reaction_aggregate {
  aggregate: post_reaction_aggregate_fields
  nodes: [post_reaction!]!
}

"aggregate fields of \"post_reaction\""
type post_reaction_aggregate_fields {
  avg: post_reaction_avg_fields
  count(columns: [post_reaction_select_column!] distinct: Boolean): Int!
  max: post_reaction_max_fields
  min: post_reaction_min_fields
  stddev: post_reaction_stddev_fields
  stddev_pop: post_reaction_stddev_pop_fields
  stddev_samp: post_reaction_stddev_samp_fields
  sum: post_reaction_sum_fields
  var_pop: post_reaction_var_pop_fields
  var_samp: post_reaction_var_samp_fields
  variance: post_reaction_variance_fields
}

"order by aggregate values of table \"post_reaction\""
input post_reaction_aggregate_order_by {
  avg: post_reaction_avg_order_by
  count: order_by
  max: post_reaction_max_order_by
  min: post_reaction_min_order_by
  stddev: post_reaction_stddev_order_by
  stddev_pop: post_reaction_stddev_pop_order_by
  stddev_samp: post_reaction_stddev_samp_order_by
  sum: post_reaction_sum_order_by
  var_pop: post_reaction_var_pop_order_by
  var_samp: post_reaction_var_samp_order_by
  variance: post_reaction_variance_order_by
}

"aggregate avg on columns"
type post_reaction_avg_fields {
  height: Float
}

"order by avg() on columns of table \"post_reaction\""
input post_reaction_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"post_reaction\". All fields are combined with a logical 'AND'."
input post_reaction_bool_exp {
  _and: [post_reaction_bool_exp!]
  _not: post_reaction_bool_exp
  _or: [post_reaction_bool_exp!]
  height: bigint_comparison_exp
  owner_address: String_comparison_exp
  post: post_bool_exp
  post_id: String_comparison_exp
  profile: profile_bool_exp
  short_code: String_comparison_exp
  value: String_comparison_exp
}

"aggregate max on columns"
type post_reaction_max_fields {
  height: bigint
  owner_address: String
  post_id: String
  short_code: String
  value: String
}

"order by max() on columns of table \"post_reaction\""
input post_reaction_max_order_by {
  height: order_by
  owner_address: order_by
  post_id: order_by
  short_code: order_by
  value: order_by
}

"aggregate min on columns"
type post_reaction_min_fields {
  height: bigint
  owner_address: String
  post_id: String
  short_code: String
  value: String
}

"order by min() on columns of table \"post_reaction\""
input post_reaction_min_order_by {
  height: order_by
  owner_address: order_by
  post_id: order_by
  short_code: order_by
  value: order_by
}

"Ordering options when selecting data from \"post_reaction\"."
input post_reaction_order_by {
  height: order_by
  owner_address: order_by
  post: post_order_by
  post_id: order_by
  profile: profile_order_by
  short_code: order_by
  value: order_by
}

"select columns of table \"post_reaction\""
enum post_reaction_select_column {
  "column name"
  height
  "column name"
  owner_address
  "column name"
  post_id
  "column name"
  short_code
  "column name"
  value
}

"aggregate stddev on columns"
type post_reaction_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"post_reaction\""
input post_reaction_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type post_reaction_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"post_reaction\""
input post_reaction_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type post_reaction_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"post_reaction\""
input post_reaction_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type post_reaction_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"post_reaction\""
input post_reaction_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type post_reaction_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"post_reaction\""
input post_reaction_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type post_reaction_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"post_reaction\""
input post_reaction_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type post_reaction_variance_fields {
  height: Float
}

"order by variance() on columns of table \"post_reaction\""
input post_reaction_variance_order_by {
  height: order_by
}

"columns and relationships of \"post_report\""
type post_report {
  height: bigint!
  id: Int!
  message: String
  "An object relationship"
  post: post!
  post_id: String!
  "An object relationship"
  profile: profile!
  reporter_address: String!
  type: String!
}

"aggregated selection of \"post_report\""
type post_report_aggregate {
  aggregate: post_report_aggregate_fields
  nodes: [post_report!]!
}

"aggregate fields of \"post_report\""
type post_report_aggregate_fields {
  avg: post_report_avg_fields
  count(columns: [post_report_select_column!] distinct: Boolean): Int!
  max: post_report_max_fields
  min: post_report_min_fields
  stddev: post_report_stddev_fields
  stddev_pop: post_report_stddev_pop_fields
  stddev_samp: post_report_stddev_samp_fields
  sum: post_report_sum_fields
  var_pop: post_report_var_pop_fields
  var_samp: post_report_var_samp_fields
  variance: post_report_variance_fields
}

"order by aggregate values of table \"post_report\""
input post_report_aggregate_order_by {
  avg: post_report_avg_order_by
  count: order_by
  max: post_report_max_order_by
  min: post_report_min_order_by
  stddev: post_report_stddev_order_by
  stddev_pop: post_report_stddev_pop_order_by
  stddev_samp: post_report_stddev_samp_order_by
  sum: post_report_sum_order_by
  var_pop: post_report_var_pop_order_by
  var_samp: post_report_var_samp_order_by
  variance: post_report_variance_order_by
}

"aggregate avg on columns"
type post_report_avg_fields {
  height: Float
  id: Float
}

"order by avg() on columns of table \"post_report\""
input post_report_avg_order_by {
  height: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"post_report\". All fields are combined with a logical 'AND'."
input post_report_bool_exp {
  _and: [post_report_bool_exp!]
  _not: post_report_bool_exp
  _or: [post_report_bool_exp!]
  height: bigint_comparison_exp
  id: Int_comparison_exp
  message: String_comparison_exp
  post: post_bool_exp
  post_id: String_comparison_exp
  profile: profile_bool_exp
  reporter_address: String_comparison_exp
  type: String_comparison_exp
}

"aggregate max on columns"
type post_report_max_fields {
  height: bigint
  id: Int
  message: String
  post_id: String
  reporter_address: String
  type: String
}

"order by max() on columns of table \"post_report\""
input post_report_max_order_by {
  height: order_by
  id: order_by
  message: order_by
  post_id: order_by
  reporter_address: order_by
  type: order_by
}

"aggregate min on columns"
type post_report_min_fields {
  height: bigint
  id: Int
  message: String
  post_id: String
  reporter_address: String
  type: String
}

"order by min() on columns of table \"post_report\""
input post_report_min_order_by {
  height: order_by
  id: order_by
  message: order_by
  post_id: order_by
  reporter_address: order_by
  type: order_by
}

"Ordering options when selecting data from \"post_report\"."
input post_report_order_by {
  height: order_by
  id: order_by
  message: order_by
  post: post_order_by
  post_id: order_by
  profile: profile_order_by
  reporter_address: order_by
  type: order_by
}

"select columns of table \"post_report\""
enum post_report_select_column {
  "column name"
  height
  "column name"
  id
  "column name"
  message
  "column name"
  post_id
  "column name"
  reporter_address
  "column name"
  type
}

"aggregate stddev on columns"
type post_report_stddev_fields {
  height: Float
  id: Float
}

"order by stddev() on columns of table \"post_report\""
input post_report_stddev_order_by {
  height: order_by
  id: order_by
}

"aggregate stddev_pop on columns"
type post_report_stddev_pop_fields {
  height: Float
  id: Float
}

"order by stddev_pop() on columns of table \"post_report\""
input post_report_stddev_pop_order_by {
  height: order_by
  id: order_by
}

"aggregate stddev_samp on columns"
type post_report_stddev_samp_fields {
  height: Float
  id: Float
}

"order by stddev_samp() on columns of table \"post_report\""
input post_report_stddev_samp_order_by {
  height: order_by
  id: order_by
}

"aggregate sum on columns"
type post_report_sum_fields {
  height: bigint
  id: Int
}

"order by sum() on columns of table \"post_report\""
input post_report_sum_order_by {
  height: order_by
  id: order_by
}

"aggregate var_pop on columns"
type post_report_var_pop_fields {
  height: Float
  id: Float
}

"order by var_pop() on columns of table \"post_report\""
input post_report_var_pop_order_by {
  height: order_by
  id: order_by
}

"aggregate var_samp on columns"
type post_report_var_samp_fields {
  height: Float
  id: Float
}

"order by var_samp() on columns of table \"post_report\""
input post_report_var_samp_order_by {
  height: order_by
  id: order_by
}

"aggregate variance on columns"
type post_report_variance_fields {
  height: Float
  id: Float
}

"order by variance() on columns of table \"post_report\""
input post_report_variance_order_by {
  height: order_by
  id: order_by
}

"select columns of table \"post\""
enum post_select_column {
  "column name"
  comments_state
  "column name"
  created
  "column name"
  creator_address
  "column name"
  height
  "column name"
  hidden
  "column name"
  id
  "column name"
  last_edited
  "column name"
  message
  "column name"
  parent_id
  "column name"
  subspace
}

"aggregate stddev on columns"
type post_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"post\""
input post_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type post_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"post\""
input post_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type post_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"post\""
input post_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type post_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"post\""
input post_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type post_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"post\""
input post_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type post_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"post\""
input post_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type post_variance_fields {
  height: Float
}

"order by variance() on columns of table \"post\""
input post_variance_order_by {
  height: order_by
}

"columns and relationships of \"pre_commit\""
type pre_commit {
  height: bigint!
  proposer_priority: bigint!
  timestamp: timestamp!
  "An object relationship"
  validator: validator!
  validator_address: String!
  voting_power: bigint!
}

"aggregated selection of \"pre_commit\""
type pre_commit_aggregate {
  aggregate: pre_commit_aggregate_fields
  nodes: [pre_commit!]!
}

"aggregate fields of \"pre_commit\""
type pre_commit_aggregate_fields {
  avg: pre_commit_avg_fields
  count(columns: [pre_commit_select_column!] distinct: Boolean): Int!
  max: pre_commit_max_fields
  min: pre_commit_min_fields
  stddev: pre_commit_stddev_fields
  stddev_pop: pre_commit_stddev_pop_fields
  stddev_samp: pre_commit_stddev_samp_fields
  sum: pre_commit_sum_fields
  var_pop: pre_commit_var_pop_fields
  var_samp: pre_commit_var_samp_fields
  variance: pre_commit_variance_fields
}

"order by aggregate values of table \"pre_commit\""
input pre_commit_aggregate_order_by {
  avg: pre_commit_avg_order_by
  count: order_by
  max: pre_commit_max_order_by
  min: pre_commit_min_order_by
  stddev: pre_commit_stddev_order_by
  stddev_pop: pre_commit_stddev_pop_order_by
  stddev_samp: pre_commit_stddev_samp_order_by
  sum: pre_commit_sum_order_by
  var_pop: pre_commit_var_pop_order_by
  var_samp: pre_commit_var_samp_order_by
  variance: pre_commit_variance_order_by
}

"aggregate avg on columns"
type pre_commit_avg_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by avg() on columns of table \"pre_commit\""
input pre_commit_avg_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"Boolean expression to filter rows from the table \"pre_commit\". All fields are combined with a logical 'AND'."
input pre_commit_bool_exp {
  _and: [pre_commit_bool_exp!]
  _not: pre_commit_bool_exp
  _or: [pre_commit_bool_exp!]
  height: bigint_comparison_exp
  proposer_priority: bigint_comparison_exp
  timestamp: timestamp_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  voting_power: bigint_comparison_exp
}

"aggregate max on columns"
type pre_commit_max_fields {
  height: bigint
  proposer_priority: bigint
  timestamp: timestamp
  validator_address: String
  voting_power: bigint
}

"order by max() on columns of table \"pre_commit\""
input pre_commit_max_order_by {
  height: order_by
  proposer_priority: order_by
  timestamp: order_by
  validator_address: order_by
  voting_power: order_by
}

"aggregate min on columns"
type pre_commit_min_fields {
  height: bigint
  proposer_priority: bigint
  timestamp: timestamp
  validator_address: String
  voting_power: bigint
}

"order by min() on columns of table \"pre_commit\""
input pre_commit_min_order_by {
  height: order_by
  proposer_priority: order_by
  timestamp: order_by
  validator_address: order_by
  voting_power: order_by
}

"Ordering options when selecting data from \"pre_commit\"."
input pre_commit_order_by {
  height: order_by
  proposer_priority: order_by
  timestamp: order_by
  validator: validator_order_by
  validator_address: order_by
  voting_power: order_by
}

"select columns of table \"pre_commit\""
enum pre_commit_select_column {
  "column name"
  height
  "column name"
  proposer_priority
  "column name"
  timestamp
  "column name"
  validator_address
  "column name"
  voting_power
}

"aggregate stddev on columns"
type pre_commit_stddev_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by stddev() on columns of table \"pre_commit\""
input pre_commit_stddev_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"aggregate stddev_pop on columns"
type pre_commit_stddev_pop_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by stddev_pop() on columns of table \"pre_commit\""
input pre_commit_stddev_pop_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"aggregate stddev_samp on columns"
type pre_commit_stddev_samp_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by stddev_samp() on columns of table \"pre_commit\""
input pre_commit_stddev_samp_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"aggregate sum on columns"
type pre_commit_sum_fields {
  height: bigint
  proposer_priority: bigint
  voting_power: bigint
}

"order by sum() on columns of table \"pre_commit\""
input pre_commit_sum_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"aggregate var_pop on columns"
type pre_commit_var_pop_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by var_pop() on columns of table \"pre_commit\""
input pre_commit_var_pop_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"aggregate var_samp on columns"
type pre_commit_var_samp_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by var_samp() on columns of table \"pre_commit\""
input pre_commit_var_samp_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"aggregate variance on columns"
type pre_commit_variance_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"order by variance() on columns of table \"pre_commit\""
input pre_commit_variance_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"columns and relationships of \"profile\""
type profile {
  address: String!
  "An array relationship"
  application_links("distinct select on columns" distinct_on: [application_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_order_by!] "filter the rows returned" where: application_link_bool_exp): [application_link!]!
  "An aggregate relationship"
  application_links_aggregate("distinct select on columns" distinct_on: [application_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_order_by!] "filter the rows returned" where: application_link_bool_exp): application_link_aggregate!
  bio: String!
  "An array relationship"
  chain_links("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): [chain_link!]!
  "An aggregate relationship"
  chain_links_aggregate("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): chain_link_aggregate!
  cover_pic: String!
  creation_time: timestamp!
  dtag: String!
  "An array relationship"
  dtagTransferRequestsBySenderAddress("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): [dtag_transfer_requests!]!
  "An aggregate relationship"
  dtagTransferRequestsBySenderAddress_aggregate("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): dtag_transfer_requests_aggregate!
  "An array relationship"
  dtag_transfer_requests("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): [dtag_transfer_requests!]!
  "An aggregate relationship"
  dtag_transfer_requests_aggregate("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): dtag_transfer_requests_aggregate!
  height: bigint!
  nickname: String!
  "An array relationship"
  post_attachment_tags("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): [post_attachment_tag!]!
  "An aggregate relationship"
  post_attachment_tags_aggregate("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): post_attachment_tag_aggregate!
  "An array relationship"
  post_reactions("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): [post_reaction!]!
  "An aggregate relationship"
  post_reactions_aggregate("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): post_reaction_aggregate!
  "An array relationship"
  post_reports("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): [post_report!]!
  "An aggregate relationship"
  post_reports_aggregate("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): post_report_aggregate!
  "An array relationship"
  posts("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): [post!]!
  "An aggregate relationship"
  posts_aggregate("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): post_aggregate!
  "An array relationship"
  profileRelationshipsBySenderAddress("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): [profile_relationship!]!
  "An aggregate relationship"
  profileRelationshipsBySenderAddress_aggregate("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): profile_relationship_aggregate!
  profile_pic: String!
  "An array relationship"
  profile_relationships("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): [profile_relationship!]!
  "An aggregate relationship"
  profile_relationships_aggregate("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): profile_relationship_aggregate!
  "An array relationship"
  registered_reactions("distinct select on columns" distinct_on: [registered_reactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [registered_reactions_order_by!] "filter the rows returned" where: registered_reactions_bool_exp): [registered_reactions!]!
  "An aggregate relationship"
  registered_reactions_aggregate("distinct select on columns" distinct_on: [registered_reactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [registered_reactions_order_by!] "filter the rows returned" where: registered_reactions_bool_exp): registered_reactions_aggregate!
  "An array relationship"
  userBlocksByBlockerAddress("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): [user_block!]!
  "An aggregate relationship"
  userBlocksByBlockerAddress_aggregate("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): user_block_aggregate!
  "An array relationship"
  user_blocks("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): [user_block!]!
  "An aggregate relationship"
  user_blocks_aggregate("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): user_block_aggregate!
  "An array relationship"
  user_poll_answers("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): [user_poll_answer!]!
  "An aggregate relationship"
  user_poll_answers_aggregate("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): user_poll_answer_aggregate!
}

"aggregated selection of \"profile\""
type profile_aggregate {
  aggregate: profile_aggregate_fields
  nodes: [profile!]!
}

"aggregate fields of \"profile\""
type profile_aggregate_fields {
  avg: profile_avg_fields
  count(columns: [profile_select_column!] distinct: Boolean): Int!
  max: profile_max_fields
  min: profile_min_fields
  stddev: profile_stddev_fields
  stddev_pop: profile_stddev_pop_fields
  stddev_samp: profile_stddev_samp_fields
  sum: profile_sum_fields
  var_pop: profile_var_pop_fields
  var_samp: profile_var_samp_fields
  variance: profile_variance_fields
}

"aggregate avg on columns"
type profile_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"profile\". All fields are combined with a logical 'AND'."
input profile_bool_exp {
  _and: [profile_bool_exp!]
  _not: profile_bool_exp
  _or: [profile_bool_exp!]
  address: String_comparison_exp
  application_links: application_link_bool_exp
  bio: String_comparison_exp
  chain_links: chain_link_bool_exp
  cover_pic: String_comparison_exp
  creation_time: timestamp_comparison_exp
  dtag: String_comparison_exp
  dtagTransferRequestsBySenderAddress: dtag_transfer_requests_bool_exp
  dtag_transfer_requests: dtag_transfer_requests_bool_exp
  height: bigint_comparison_exp
  nickname: String_comparison_exp
  post_attachment_tags: post_attachment_tag_bool_exp
  post_reactions: post_reaction_bool_exp
  post_reports: post_report_bool_exp
  posts: post_bool_exp
  profileRelationshipsBySenderAddress: profile_relationship_bool_exp
  profile_pic: String_comparison_exp
  profile_relationships: profile_relationship_bool_exp
  registered_reactions: registered_reactions_bool_exp
  userBlocksByBlockerAddress: user_block_bool_exp
  user_blocks: user_block_bool_exp
  user_poll_answers: user_poll_answer_bool_exp
}

"aggregate max on columns"
type profile_max_fields {
  address: String
  bio: String
  cover_pic: String
  creation_time: timestamp
  dtag: String
  height: bigint
  nickname: String
  profile_pic: String
}

"aggregate min on columns"
type profile_min_fields {
  address: String
  bio: String
  cover_pic: String
  creation_time: timestamp
  dtag: String
  height: bigint
  nickname: String
  profile_pic: String
}

"Ordering options when selecting data from \"profile\"."
input profile_order_by {
  address: order_by
  application_links_aggregate: application_link_aggregate_order_by
  bio: order_by
  chain_links_aggregate: chain_link_aggregate_order_by
  cover_pic: order_by
  creation_time: order_by
  dtag: order_by
  dtagTransferRequestsBySenderAddress_aggregate: dtag_transfer_requests_aggregate_order_by
  dtag_transfer_requests_aggregate: dtag_transfer_requests_aggregate_order_by
  height: order_by
  nickname: order_by
  post_attachment_tags_aggregate: post_attachment_tag_aggregate_order_by
  post_reactions_aggregate: post_reaction_aggregate_order_by
  post_reports_aggregate: post_report_aggregate_order_by
  posts_aggregate: post_aggregate_order_by
  profileRelationshipsBySenderAddress_aggregate: profile_relationship_aggregate_order_by
  profile_pic: order_by
  profile_relationships_aggregate: profile_relationship_aggregate_order_by
  registered_reactions_aggregate: registered_reactions_aggregate_order_by
  userBlocksByBlockerAddress_aggregate: user_block_aggregate_order_by
  user_blocks_aggregate: user_block_aggregate_order_by
  user_poll_answers_aggregate: user_poll_answer_aggregate_order_by
}

"columns and relationships of \"profile_relationship\""
type profile_relationship {
  height: bigint!
  "An object relationship"
  profile: profile!
  "An object relationship"
  profileBySenderAddress: profile!
  receiver_address: String!
  sender_address: String!
  subspace: String!
}

"aggregated selection of \"profile_relationship\""
type profile_relationship_aggregate {
  aggregate: profile_relationship_aggregate_fields
  nodes: [profile_relationship!]!
}

"aggregate fields of \"profile_relationship\""
type profile_relationship_aggregate_fields {
  avg: profile_relationship_avg_fields
  count(columns: [profile_relationship_select_column!] distinct: Boolean): Int!
  max: profile_relationship_max_fields
  min: profile_relationship_min_fields
  stddev: profile_relationship_stddev_fields
  stddev_pop: profile_relationship_stddev_pop_fields
  stddev_samp: profile_relationship_stddev_samp_fields
  sum: profile_relationship_sum_fields
  var_pop: profile_relationship_var_pop_fields
  var_samp: profile_relationship_var_samp_fields
  variance: profile_relationship_variance_fields
}

"order by aggregate values of table \"profile_relationship\""
input profile_relationship_aggregate_order_by {
  avg: profile_relationship_avg_order_by
  count: order_by
  max: profile_relationship_max_order_by
  min: profile_relationship_min_order_by
  stddev: profile_relationship_stddev_order_by
  stddev_pop: profile_relationship_stddev_pop_order_by
  stddev_samp: profile_relationship_stddev_samp_order_by
  sum: profile_relationship_sum_order_by
  var_pop: profile_relationship_var_pop_order_by
  var_samp: profile_relationship_var_samp_order_by
  variance: profile_relationship_variance_order_by
}

"aggregate avg on columns"
type profile_relationship_avg_fields {
  height: Float
}

"order by avg() on columns of table \"profile_relationship\""
input profile_relationship_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"profile_relationship\". All fields are combined with a logical 'AND'."
input profile_relationship_bool_exp {
  _and: [profile_relationship_bool_exp!]
  _not: profile_relationship_bool_exp
  _or: [profile_relationship_bool_exp!]
  height: bigint_comparison_exp
  profile: profile_bool_exp
  profileBySenderAddress: profile_bool_exp
  receiver_address: String_comparison_exp
  sender_address: String_comparison_exp
  subspace: String_comparison_exp
}

"aggregate max on columns"
type profile_relationship_max_fields {
  height: bigint
  receiver_address: String
  sender_address: String
  subspace: String
}

"order by max() on columns of table \"profile_relationship\""
input profile_relationship_max_order_by {
  height: order_by
  receiver_address: order_by
  sender_address: order_by
  subspace: order_by
}

"aggregate min on columns"
type profile_relationship_min_fields {
  height: bigint
  receiver_address: String
  sender_address: String
  subspace: String
}

"order by min() on columns of table \"profile_relationship\""
input profile_relationship_min_order_by {
  height: order_by
  receiver_address: order_by
  sender_address: order_by
  subspace: order_by
}

"Ordering options when selecting data from \"profile_relationship\"."
input profile_relationship_order_by {
  height: order_by
  profile: profile_order_by
  profileBySenderAddress: profile_order_by
  receiver_address: order_by
  sender_address: order_by
  subspace: order_by
}

"select columns of table \"profile_relationship\""
enum profile_relationship_select_column {
  "column name"
  height
  "column name"
  receiver_address
  "column name"
  sender_address
  "column name"
  subspace
}

"aggregate stddev on columns"
type profile_relationship_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"profile_relationship\""
input profile_relationship_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type profile_relationship_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"profile_relationship\""
input profile_relationship_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type profile_relationship_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"profile_relationship\""
input profile_relationship_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type profile_relationship_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"profile_relationship\""
input profile_relationship_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type profile_relationship_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"profile_relationship\""
input profile_relationship_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type profile_relationship_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"profile_relationship\""
input profile_relationship_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type profile_relationship_variance_fields {
  height: Float
}

"order by variance() on columns of table \"profile_relationship\""
input profile_relationship_variance_order_by {
  height: order_by
}

"select columns of table \"profile\""
enum profile_select_column {
  "column name"
  address
  "column name"
  bio
  "column name"
  cover_pic
  "column name"
  creation_time
  "column name"
  dtag
  "column name"
  height
  "column name"
  nickname
  "column name"
  profile_pic
}

"aggregate stddev on columns"
type profile_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type profile_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type profile_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type profile_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type profile_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type profile_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type profile_variance_fields {
  height: Float
}

"columns and relationships of \"profiles_params\""
type profiles_params {
  height: bigint!
  params("JSON select path" path: String): jsonb!
}

"Boolean expression to filter rows from the table \"profiles_params\". All fields are combined with a logical 'AND'."
input profiles_params_bool_exp {
  _and: [profiles_params_bool_exp!]
  _not: profiles_params_bool_exp
  _or: [profiles_params_bool_exp!]
  height: bigint_comparison_exp
  params: jsonb_comparison_exp
}

"Ordering options when selecting data from \"profiles_params\"."
input profiles_params_order_by {
  height: order_by
  params: order_by
}

"select columns of table \"profiles_params\""
enum profiles_params_select_column {
  "column name"
  height
  "column name"
  params
}

"columns and relationships of \"proposal\""
type proposal {
  content("JSON select path" path: String): jsonb!
  deposit_end_time: timestamp
  description: String!
  id: Int!
  "An array relationship"
  proposal_deposits("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): [proposal_deposit!]!
  "An aggregate relationship"
  proposal_deposits_aggregate("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): proposal_deposit_aggregate!
  proposal_route: String!
  "An object relationship"
  proposal_tally_result: proposal_tally_result
  "An array relationship"
  proposal_tally_results("distinct select on columns" distinct_on: [proposal_tally_result_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_tally_result_order_by!] "filter the rows returned" where: proposal_tally_result_bool_exp): [proposal_tally_result!]!
  "An aggregate relationship"
  proposal_tally_results_aggregate("distinct select on columns" distinct_on: [proposal_tally_result_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_tally_result_order_by!] "filter the rows returned" where: proposal_tally_result_bool_exp): proposal_tally_result_aggregate!
  proposal_type: String!
  "An array relationship"
  proposal_votes("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): [proposal_vote!]!
  "An aggregate relationship"
  proposal_votes_aggregate("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): proposal_vote_aggregate!
  "An object relationship"
  proposer: account!
  proposer_address: String!
  "An object relationship"
  staking_pool_snapshot: proposal_staking_pool_snapshot
  status: String
  submit_time: timestamp!
  title: String!
  "An array relationship"
  validator_status_snapshots("distinct select on columns" distinct_on: [proposal_validator_status_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_validator_status_snapshot_order_by!] "filter the rows returned" where: proposal_validator_status_snapshot_bool_exp): [proposal_validator_status_snapshot!]!
  "An aggregate relationship"
  validator_status_snapshots_aggregate("distinct select on columns" distinct_on: [proposal_validator_status_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_validator_status_snapshot_order_by!] "filter the rows returned" where: proposal_validator_status_snapshot_bool_exp): proposal_validator_status_snapshot_aggregate!
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"aggregated selection of \"proposal\""
type proposal_aggregate {
  aggregate: proposal_aggregate_fields
  nodes: [proposal!]!
}

"aggregate fields of \"proposal\""
type proposal_aggregate_fields {
  avg: proposal_avg_fields
  count(columns: [proposal_select_column!] distinct: Boolean): Int!
  max: proposal_max_fields
  min: proposal_min_fields
  stddev: proposal_stddev_fields
  stddev_pop: proposal_stddev_pop_fields
  stddev_samp: proposal_stddev_samp_fields
  sum: proposal_sum_fields
  var_pop: proposal_var_pop_fields
  var_samp: proposal_var_samp_fields
  variance: proposal_variance_fields
}

"order by aggregate values of table \"proposal\""
input proposal_aggregate_order_by {
  avg: proposal_avg_order_by
  count: order_by
  max: proposal_max_order_by
  min: proposal_min_order_by
  stddev: proposal_stddev_order_by
  stddev_pop: proposal_stddev_pop_order_by
  stddev_samp: proposal_stddev_samp_order_by
  sum: proposal_sum_order_by
  var_pop: proposal_var_pop_order_by
  var_samp: proposal_var_samp_order_by
  variance: proposal_variance_order_by
}

"aggregate avg on columns"
type proposal_avg_fields {
  id: Float
}

"order by avg() on columns of table \"proposal\""
input proposal_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"proposal\". All fields are combined with a logical 'AND'."
input proposal_bool_exp {
  _and: [proposal_bool_exp!]
  _not: proposal_bool_exp
  _or: [proposal_bool_exp!]
  content: jsonb_comparison_exp
  deposit_end_time: timestamp_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  proposal_deposits: proposal_deposit_bool_exp
  proposal_route: String_comparison_exp
  proposal_tally_result: proposal_tally_result_bool_exp
  proposal_tally_results: proposal_tally_result_bool_exp
  proposal_type: String_comparison_exp
  proposal_votes: proposal_vote_bool_exp
  proposer: account_bool_exp
  proposer_address: String_comparison_exp
  staking_pool_snapshot: proposal_staking_pool_snapshot_bool_exp
  status: String_comparison_exp
  submit_time: timestamp_comparison_exp
  title: String_comparison_exp
  validator_status_snapshots: proposal_validator_status_snapshot_bool_exp
  voting_end_time: timestamp_comparison_exp
  voting_start_time: timestamp_comparison_exp
}

"columns and relationships of \"proposal_deposit\""
type proposal_deposit {
  amount: _coin
  "An object relationship"
  block: block
  "An object relationship"
  depositor: account
  depositor_address: String
  height: bigint
  "An object relationship"
  proposal: proposal!
  proposal_id: Int!
}

"aggregated selection of \"proposal_deposit\""
type proposal_deposit_aggregate {
  aggregate: proposal_deposit_aggregate_fields
  nodes: [proposal_deposit!]!
}

"aggregate fields of \"proposal_deposit\""
type proposal_deposit_aggregate_fields {
  avg: proposal_deposit_avg_fields
  count(columns: [proposal_deposit_select_column!] distinct: Boolean): Int!
  max: proposal_deposit_max_fields
  min: proposal_deposit_min_fields
  stddev: proposal_deposit_stddev_fields
  stddev_pop: proposal_deposit_stddev_pop_fields
  stddev_samp: proposal_deposit_stddev_samp_fields
  sum: proposal_deposit_sum_fields
  var_pop: proposal_deposit_var_pop_fields
  var_samp: proposal_deposit_var_samp_fields
  variance: proposal_deposit_variance_fields
}

"order by aggregate values of table \"proposal_deposit\""
input proposal_deposit_aggregate_order_by {
  avg: proposal_deposit_avg_order_by
  count: order_by
  max: proposal_deposit_max_order_by
  min: proposal_deposit_min_order_by
  stddev: proposal_deposit_stddev_order_by
  stddev_pop: proposal_deposit_stddev_pop_order_by
  stddev_samp: proposal_deposit_stddev_samp_order_by
  sum: proposal_deposit_sum_order_by
  var_pop: proposal_deposit_var_pop_order_by
  var_samp: proposal_deposit_var_samp_order_by
  variance: proposal_deposit_variance_order_by
}

"aggregate avg on columns"
type proposal_deposit_avg_fields {
  height: Float
  proposal_id: Float
}

"order by avg() on columns of table \"proposal_deposit\""
input proposal_deposit_avg_order_by {
  height: order_by
  proposal_id: order_by
}

"Boolean expression to filter rows from the table \"proposal_deposit\". All fields are combined with a logical 'AND'."
input proposal_deposit_bool_exp {
  _and: [proposal_deposit_bool_exp!]
  _not: proposal_deposit_bool_exp
  _or: [proposal_deposit_bool_exp!]
  amount: _coin_comparison_exp
  block: block_bool_exp
  depositor: account_bool_exp
  depositor_address: String_comparison_exp
  height: bigint_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
}

"aggregate max on columns"
type proposal_deposit_max_fields {
  depositor_address: String
  height: bigint
  proposal_id: Int
}

"order by max() on columns of table \"proposal_deposit\""
input proposal_deposit_max_order_by {
  depositor_address: order_by
  height: order_by
  proposal_id: order_by
}

"aggregate min on columns"
type proposal_deposit_min_fields {
  depositor_address: String
  height: bigint
  proposal_id: Int
}

"order by min() on columns of table \"proposal_deposit\""
input proposal_deposit_min_order_by {
  depositor_address: order_by
  height: order_by
  proposal_id: order_by
}

"Ordering options when selecting data from \"proposal_deposit\"."
input proposal_deposit_order_by {
  amount: order_by
  block: block_order_by
  depositor: account_order_by
  depositor_address: order_by
  height: order_by
  proposal: proposal_order_by
  proposal_id: order_by
}

"select columns of table \"proposal_deposit\""
enum proposal_deposit_select_column {
  "column name"
  amount
  "column name"
  depositor_address
  "column name"
  height
  "column name"
  proposal_id
}

"aggregate stddev on columns"
type proposal_deposit_stddev_fields {
  height: Float
  proposal_id: Float
}

"order by stddev() on columns of table \"proposal_deposit\""
input proposal_deposit_stddev_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate stddev_pop on columns"
type proposal_deposit_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"order by stddev_pop() on columns of table \"proposal_deposit\""
input proposal_deposit_stddev_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate stddev_samp on columns"
type proposal_deposit_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"order by stddev_samp() on columns of table \"proposal_deposit\""
input proposal_deposit_stddev_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate sum on columns"
type proposal_deposit_sum_fields {
  height: bigint
  proposal_id: Int
}

"order by sum() on columns of table \"proposal_deposit\""
input proposal_deposit_sum_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate var_pop on columns"
type proposal_deposit_var_pop_fields {
  height: Float
  proposal_id: Float
}

"order by var_pop() on columns of table \"proposal_deposit\""
input proposal_deposit_var_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate var_samp on columns"
type proposal_deposit_var_samp_fields {
  height: Float
  proposal_id: Float
}

"order by var_samp() on columns of table \"proposal_deposit\""
input proposal_deposit_var_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate variance on columns"
type proposal_deposit_variance_fields {
  height: Float
  proposal_id: Float
}

"order by variance() on columns of table \"proposal_deposit\""
input proposal_deposit_variance_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate max on columns"
type proposal_max_fields {
  deposit_end_time: timestamp
  description: String
  id: Int
  proposal_route: String
  proposal_type: String
  proposer_address: String
  status: String
  submit_time: timestamp
  title: String
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"order by max() on columns of table \"proposal\""
input proposal_max_order_by {
  deposit_end_time: order_by
  description: order_by
  id: order_by
  proposal_route: order_by
  proposal_type: order_by
  proposer_address: order_by
  status: order_by
  submit_time: order_by
  title: order_by
  voting_end_time: order_by
  voting_start_time: order_by
}

"aggregate min on columns"
type proposal_min_fields {
  deposit_end_time: timestamp
  description: String
  id: Int
  proposal_route: String
  proposal_type: String
  proposer_address: String
  status: String
  submit_time: timestamp
  title: String
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"order by min() on columns of table \"proposal\""
input proposal_min_order_by {
  deposit_end_time: order_by
  description: order_by
  id: order_by
  proposal_route: order_by
  proposal_type: order_by
  proposer_address: order_by
  status: order_by
  submit_time: order_by
  title: order_by
  voting_end_time: order_by
  voting_start_time: order_by
}

"Ordering options when selecting data from \"proposal\"."
input proposal_order_by {
  content: order_by
  deposit_end_time: order_by
  description: order_by
  id: order_by
  proposal_deposits_aggregate: proposal_deposit_aggregate_order_by
  proposal_route: order_by
  proposal_tally_result: proposal_tally_result_order_by
  proposal_tally_results_aggregate: proposal_tally_result_aggregate_order_by
  proposal_type: order_by
  proposal_votes_aggregate: proposal_vote_aggregate_order_by
  proposer: account_order_by
  proposer_address: order_by
  staking_pool_snapshot: proposal_staking_pool_snapshot_order_by
  status: order_by
  submit_time: order_by
  title: order_by
  validator_status_snapshots_aggregate: proposal_validator_status_snapshot_aggregate_order_by
  voting_end_time: order_by
  voting_start_time: order_by
}

"select columns of table \"proposal\""
enum proposal_select_column {
  "column name"
  content
  "column name"
  deposit_end_time
  "column name"
  description
  "column name"
  id
  "column name"
  proposal_route
  "column name"
  proposal_type
  "column name"
  proposer_address
  "column name"
  status
  "column name"
  submit_time
  "column name"
  title
  "column name"
  voting_end_time
  "column name"
  voting_start_time
}

"columns and relationships of \"proposal_staking_pool_snapshot\""
type proposal_staking_pool_snapshot {
  bonded_tokens: bigint!
  height: bigint!
  not_bonded_tokens: bigint!
  "An object relationship"
  proposal: proposal!
  proposal_id: Int!
}

"aggregated selection of \"proposal_staking_pool_snapshot\""
type proposal_staking_pool_snapshot_aggregate {
  aggregate: proposal_staking_pool_snapshot_aggregate_fields
  nodes: [proposal_staking_pool_snapshot!]!
}

"aggregate fields of \"proposal_staking_pool_snapshot\""
type proposal_staking_pool_snapshot_aggregate_fields {
  avg: proposal_staking_pool_snapshot_avg_fields
  count(columns: [proposal_staking_pool_snapshot_select_column!] distinct: Boolean): Int!
  max: proposal_staking_pool_snapshot_max_fields
  min: proposal_staking_pool_snapshot_min_fields
  stddev: proposal_staking_pool_snapshot_stddev_fields
  stddev_pop: proposal_staking_pool_snapshot_stddev_pop_fields
  stddev_samp: proposal_staking_pool_snapshot_stddev_samp_fields
  sum: proposal_staking_pool_snapshot_sum_fields
  var_pop: proposal_staking_pool_snapshot_var_pop_fields
  var_samp: proposal_staking_pool_snapshot_var_samp_fields
  variance: proposal_staking_pool_snapshot_variance_fields
}

"aggregate avg on columns"
type proposal_staking_pool_snapshot_avg_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"Boolean expression to filter rows from the table \"proposal_staking_pool_snapshot\". All fields are combined with a logical 'AND'."
input proposal_staking_pool_snapshot_bool_exp {
  _and: [proposal_staking_pool_snapshot_bool_exp!]
  _not: proposal_staking_pool_snapshot_bool_exp
  _or: [proposal_staking_pool_snapshot_bool_exp!]
  bonded_tokens: bigint_comparison_exp
  height: bigint_comparison_exp
  not_bonded_tokens: bigint_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
}

"aggregate max on columns"
type proposal_staking_pool_snapshot_max_fields {
  bonded_tokens: bigint
  height: bigint
  not_bonded_tokens: bigint
  proposal_id: Int
}

"aggregate min on columns"
type proposal_staking_pool_snapshot_min_fields {
  bonded_tokens: bigint
  height: bigint
  not_bonded_tokens: bigint
  proposal_id: Int
}

"Ordering options when selecting data from \"proposal_staking_pool_snapshot\"."
input proposal_staking_pool_snapshot_order_by {
  bonded_tokens: order_by
  height: order_by
  not_bonded_tokens: order_by
  proposal: proposal_order_by
  proposal_id: order_by
}

"select columns of table \"proposal_staking_pool_snapshot\""
enum proposal_staking_pool_snapshot_select_column {
  "column name"
  bonded_tokens
  "column name"
  height
  "column name"
  not_bonded_tokens
  "column name"
  proposal_id
}

"aggregate stddev on columns"
type proposal_staking_pool_snapshot_stddev_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"aggregate stddev_pop on columns"
type proposal_staking_pool_snapshot_stddev_pop_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"aggregate stddev_samp on columns"
type proposal_staking_pool_snapshot_stddev_samp_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"aggregate sum on columns"
type proposal_staking_pool_snapshot_sum_fields {
  bonded_tokens: bigint
  height: bigint
  not_bonded_tokens: bigint
  proposal_id: Int
}

"aggregate var_pop on columns"
type proposal_staking_pool_snapshot_var_pop_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"aggregate var_samp on columns"
type proposal_staking_pool_snapshot_var_samp_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"aggregate variance on columns"
type proposal_staking_pool_snapshot_variance_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
  proposal_id: Float
}

"aggregate stddev on columns"
type proposal_stddev_fields {
  id: Float
}

"order by stddev() on columns of table \"proposal\""
input proposal_stddev_order_by {
  id: order_by
}

"aggregate stddev_pop on columns"
type proposal_stddev_pop_fields {
  id: Float
}

"order by stddev_pop() on columns of table \"proposal\""
input proposal_stddev_pop_order_by {
  id: order_by
}

"aggregate stddev_samp on columns"
type proposal_stddev_samp_fields {
  id: Float
}

"order by stddev_samp() on columns of table \"proposal\""
input proposal_stddev_samp_order_by {
  id: order_by
}

"aggregate sum on columns"
type proposal_sum_fields {
  id: Int
}

"order by sum() on columns of table \"proposal\""
input proposal_sum_order_by {
  id: order_by
}

"columns and relationships of \"proposal_tally_result\""
type proposal_tally_result {
  abstain: String!
  height: bigint!
  no: String!
  no_with_veto: String!
  "An object relationship"
  proposal: proposal!
  proposal_id: Int!
  yes: String!
}

"aggregated selection of \"proposal_tally_result\""
type proposal_tally_result_aggregate {
  aggregate: proposal_tally_result_aggregate_fields
  nodes: [proposal_tally_result!]!
}

"aggregate fields of \"proposal_tally_result\""
type proposal_tally_result_aggregate_fields {
  avg: proposal_tally_result_avg_fields
  count(columns: [proposal_tally_result_select_column!] distinct: Boolean): Int!
  max: proposal_tally_result_max_fields
  min: proposal_tally_result_min_fields
  stddev: proposal_tally_result_stddev_fields
  stddev_pop: proposal_tally_result_stddev_pop_fields
  stddev_samp: proposal_tally_result_stddev_samp_fields
  sum: proposal_tally_result_sum_fields
  var_pop: proposal_tally_result_var_pop_fields
  var_samp: proposal_tally_result_var_samp_fields
  variance: proposal_tally_result_variance_fields
}

"order by aggregate values of table \"proposal_tally_result\""
input proposal_tally_result_aggregate_order_by {
  avg: proposal_tally_result_avg_order_by
  count: order_by
  max: proposal_tally_result_max_order_by
  min: proposal_tally_result_min_order_by
  stddev: proposal_tally_result_stddev_order_by
  stddev_pop: proposal_tally_result_stddev_pop_order_by
  stddev_samp: proposal_tally_result_stddev_samp_order_by
  sum: proposal_tally_result_sum_order_by
  var_pop: proposal_tally_result_var_pop_order_by
  var_samp: proposal_tally_result_var_samp_order_by
  variance: proposal_tally_result_variance_order_by
}

"aggregate avg on columns"
type proposal_tally_result_avg_fields {
  height: Float
  proposal_id: Float
}

"order by avg() on columns of table \"proposal_tally_result\""
input proposal_tally_result_avg_order_by {
  height: order_by
  proposal_id: order_by
}

"Boolean expression to filter rows from the table \"proposal_tally_result\". All fields are combined with a logical 'AND'."
input proposal_tally_result_bool_exp {
  _and: [proposal_tally_result_bool_exp!]
  _not: proposal_tally_result_bool_exp
  _or: [proposal_tally_result_bool_exp!]
  abstain: String_comparison_exp
  height: bigint_comparison_exp
  no: String_comparison_exp
  no_with_veto: String_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
  yes: String_comparison_exp
}

"aggregate max on columns"
type proposal_tally_result_max_fields {
  abstain: String
  height: bigint
  no: String
  no_with_veto: String
  proposal_id: Int
  yes: String
}

"order by max() on columns of table \"proposal_tally_result\""
input proposal_tally_result_max_order_by {
  abstain: order_by
  height: order_by
  no: order_by
  no_with_veto: order_by
  proposal_id: order_by
  yes: order_by
}

"aggregate min on columns"
type proposal_tally_result_min_fields {
  abstain: String
  height: bigint
  no: String
  no_with_veto: String
  proposal_id: Int
  yes: String
}

"order by min() on columns of table \"proposal_tally_result\""
input proposal_tally_result_min_order_by {
  abstain: order_by
  height: order_by
  no: order_by
  no_with_veto: order_by
  proposal_id: order_by
  yes: order_by
}

"Ordering options when selecting data from \"proposal_tally_result\"."
input proposal_tally_result_order_by {
  abstain: order_by
  height: order_by
  no: order_by
  no_with_veto: order_by
  proposal: proposal_order_by
  proposal_id: order_by
  yes: order_by
}

"select columns of table \"proposal_tally_result\""
enum proposal_tally_result_select_column {
  "column name"
  abstain
  "column name"
  height
  "column name"
  no
  "column name"
  no_with_veto
  "column name"
  proposal_id
  "column name"
  yes
}

"aggregate stddev on columns"
type proposal_tally_result_stddev_fields {
  height: Float
  proposal_id: Float
}

"order by stddev() on columns of table \"proposal_tally_result\""
input proposal_tally_result_stddev_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate stddev_pop on columns"
type proposal_tally_result_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"order by stddev_pop() on columns of table \"proposal_tally_result\""
input proposal_tally_result_stddev_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate stddev_samp on columns"
type proposal_tally_result_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"order by stddev_samp() on columns of table \"proposal_tally_result\""
input proposal_tally_result_stddev_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate sum on columns"
type proposal_tally_result_sum_fields {
  height: bigint
  proposal_id: Int
}

"order by sum() on columns of table \"proposal_tally_result\""
input proposal_tally_result_sum_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate var_pop on columns"
type proposal_tally_result_var_pop_fields {
  height: Float
  proposal_id: Float
}

"order by var_pop() on columns of table \"proposal_tally_result\""
input proposal_tally_result_var_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate var_samp on columns"
type proposal_tally_result_var_samp_fields {
  height: Float
  proposal_id: Float
}

"order by var_samp() on columns of table \"proposal_tally_result\""
input proposal_tally_result_var_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate variance on columns"
type proposal_tally_result_variance_fields {
  height: Float
  proposal_id: Float
}

"order by variance() on columns of table \"proposal_tally_result\""
input proposal_tally_result_variance_order_by {
  height: order_by
  proposal_id: order_by
}

"columns and relationships of \"proposal_validator_status_snapshot\""
type proposal_validator_status_snapshot {
  height: bigint!
  id: Int!
  jailed: Boolean!
  "An object relationship"
  proposal: proposal
  proposal_id: Int
  status: Int!
  "An object relationship"
  validator: validator!
  validator_address: String!
  voting_power: bigint!
}

"aggregated selection of \"proposal_validator_status_snapshot\""
type proposal_validator_status_snapshot_aggregate {
  aggregate: proposal_validator_status_snapshot_aggregate_fields
  nodes: [proposal_validator_status_snapshot!]!
}

"aggregate fields of \"proposal_validator_status_snapshot\""
type proposal_validator_status_snapshot_aggregate_fields {
  avg: proposal_validator_status_snapshot_avg_fields
  count(columns: [proposal_validator_status_snapshot_select_column!] distinct: Boolean): Int!
  max: proposal_validator_status_snapshot_max_fields
  min: proposal_validator_status_snapshot_min_fields
  stddev: proposal_validator_status_snapshot_stddev_fields
  stddev_pop: proposal_validator_status_snapshot_stddev_pop_fields
  stddev_samp: proposal_validator_status_snapshot_stddev_samp_fields
  sum: proposal_validator_status_snapshot_sum_fields
  var_pop: proposal_validator_status_snapshot_var_pop_fields
  var_samp: proposal_validator_status_snapshot_var_samp_fields
  variance: proposal_validator_status_snapshot_variance_fields
}

"order by aggregate values of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_aggregate_order_by {
  avg: proposal_validator_status_snapshot_avg_order_by
  count: order_by
  max: proposal_validator_status_snapshot_max_order_by
  min: proposal_validator_status_snapshot_min_order_by
  stddev: proposal_validator_status_snapshot_stddev_order_by
  stddev_pop: proposal_validator_status_snapshot_stddev_pop_order_by
  stddev_samp: proposal_validator_status_snapshot_stddev_samp_order_by
  sum: proposal_validator_status_snapshot_sum_order_by
  var_pop: proposal_validator_status_snapshot_var_pop_order_by
  var_samp: proposal_validator_status_snapshot_var_samp_order_by
  variance: proposal_validator_status_snapshot_variance_order_by
}

"aggregate avg on columns"
type proposal_validator_status_snapshot_avg_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by avg() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_avg_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"Boolean expression to filter rows from the table \"proposal_validator_status_snapshot\". All fields are combined with a logical 'AND'."
input proposal_validator_status_snapshot_bool_exp {
  _and: [proposal_validator_status_snapshot_bool_exp!]
  _not: proposal_validator_status_snapshot_bool_exp
  _or: [proposal_validator_status_snapshot_bool_exp!]
  height: bigint_comparison_exp
  id: Int_comparison_exp
  jailed: Boolean_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
  status: Int_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  voting_power: bigint_comparison_exp
}

"aggregate max on columns"
type proposal_validator_status_snapshot_max_fields {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  validator_address: String
  voting_power: bigint
}

"order by max() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_max_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  validator_address: order_by
  voting_power: order_by
}

"aggregate min on columns"
type proposal_validator_status_snapshot_min_fields {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  validator_address: String
  voting_power: bigint
}

"order by min() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_min_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  validator_address: order_by
  voting_power: order_by
}

"Ordering options when selecting data from \"proposal_validator_status_snapshot\"."
input proposal_validator_status_snapshot_order_by {
  height: order_by
  id: order_by
  jailed: order_by
  proposal: proposal_order_by
  proposal_id: order_by
  status: order_by
  validator: validator_order_by
  validator_address: order_by
  voting_power: order_by
}

"select columns of table \"proposal_validator_status_snapshot\""
enum proposal_validator_status_snapshot_select_column {
  "column name"
  height
  "column name"
  id
  "column name"
  jailed
  "column name"
  proposal_id
  "column name"
  status
  "column name"
  validator_address
  "column name"
  voting_power
}

"aggregate stddev on columns"
type proposal_validator_status_snapshot_stddev_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by stddev() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_stddev_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate stddev_pop on columns"
type proposal_validator_status_snapshot_stddev_pop_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by stddev_pop() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_stddev_pop_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate stddev_samp on columns"
type proposal_validator_status_snapshot_stddev_samp_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by stddev_samp() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_stddev_samp_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate sum on columns"
type proposal_validator_status_snapshot_sum_fields {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  voting_power: bigint
}

"order by sum() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_sum_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate var_pop on columns"
type proposal_validator_status_snapshot_var_pop_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by var_pop() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_var_pop_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate var_samp on columns"
type proposal_validator_status_snapshot_var_samp_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by var_samp() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_var_samp_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate variance on columns"
type proposal_validator_status_snapshot_variance_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"order by variance() on columns of table \"proposal_validator_status_snapshot\""
input proposal_validator_status_snapshot_variance_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"aggregate var_pop on columns"
type proposal_var_pop_fields {
  id: Float
}

"order by var_pop() on columns of table \"proposal\""
input proposal_var_pop_order_by {
  id: order_by
}

"aggregate var_samp on columns"
type proposal_var_samp_fields {
  id: Float
}

"order by var_samp() on columns of table \"proposal\""
input proposal_var_samp_order_by {
  id: order_by
}

"aggregate variance on columns"
type proposal_variance_fields {
  id: Float
}

"order by variance() on columns of table \"proposal\""
input proposal_variance_order_by {
  id: order_by
}

"columns and relationships of \"proposal_vote\""
type proposal_vote {
  "An object relationship"
  account: account!
  height: bigint!
  option: String!
  "An object relationship"
  proposal: proposal!
  proposal_id: Int!
  voter_address: String!
}

"aggregated selection of \"proposal_vote\""
type proposal_vote_aggregate {
  aggregate: proposal_vote_aggregate_fields
  nodes: [proposal_vote!]!
}

"aggregate fields of \"proposal_vote\""
type proposal_vote_aggregate_fields {
  avg: proposal_vote_avg_fields
  count(columns: [proposal_vote_select_column!] distinct: Boolean): Int!
  max: proposal_vote_max_fields
  min: proposal_vote_min_fields
  stddev: proposal_vote_stddev_fields
  stddev_pop: proposal_vote_stddev_pop_fields
  stddev_samp: proposal_vote_stddev_samp_fields
  sum: proposal_vote_sum_fields
  var_pop: proposal_vote_var_pop_fields
  var_samp: proposal_vote_var_samp_fields
  variance: proposal_vote_variance_fields
}

"order by aggregate values of table \"proposal_vote\""
input proposal_vote_aggregate_order_by {
  avg: proposal_vote_avg_order_by
  count: order_by
  max: proposal_vote_max_order_by
  min: proposal_vote_min_order_by
  stddev: proposal_vote_stddev_order_by
  stddev_pop: proposal_vote_stddev_pop_order_by
  stddev_samp: proposal_vote_stddev_samp_order_by
  sum: proposal_vote_sum_order_by
  var_pop: proposal_vote_var_pop_order_by
  var_samp: proposal_vote_var_samp_order_by
  variance: proposal_vote_variance_order_by
}

"aggregate avg on columns"
type proposal_vote_avg_fields {
  height: Float
  proposal_id: Float
}

"order by avg() on columns of table \"proposal_vote\""
input proposal_vote_avg_order_by {
  height: order_by
  proposal_id: order_by
}

"Boolean expression to filter rows from the table \"proposal_vote\". All fields are combined with a logical 'AND'."
input proposal_vote_bool_exp {
  _and: [proposal_vote_bool_exp!]
  _not: proposal_vote_bool_exp
  _or: [proposal_vote_bool_exp!]
  account: account_bool_exp
  height: bigint_comparison_exp
  option: String_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
  voter_address: String_comparison_exp
}

"aggregate max on columns"
type proposal_vote_max_fields {
  height: bigint
  option: String
  proposal_id: Int
  voter_address: String
}

"order by max() on columns of table \"proposal_vote\""
input proposal_vote_max_order_by {
  height: order_by
  option: order_by
  proposal_id: order_by
  voter_address: order_by
}

"aggregate min on columns"
type proposal_vote_min_fields {
  height: bigint
  option: String
  proposal_id: Int
  voter_address: String
}

"order by min() on columns of table \"proposal_vote\""
input proposal_vote_min_order_by {
  height: order_by
  option: order_by
  proposal_id: order_by
  voter_address: order_by
}

"Ordering options when selecting data from \"proposal_vote\"."
input proposal_vote_order_by {
  account: account_order_by
  height: order_by
  option: order_by
  proposal: proposal_order_by
  proposal_id: order_by
  voter_address: order_by
}

"select columns of table \"proposal_vote\""
enum proposal_vote_select_column {
  "column name"
  height
  "column name"
  option
  "column name"
  proposal_id
  "column name"
  voter_address
}

"aggregate stddev on columns"
type proposal_vote_stddev_fields {
  height: Float
  proposal_id: Float
}

"order by stddev() on columns of table \"proposal_vote\""
input proposal_vote_stddev_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate stddev_pop on columns"
type proposal_vote_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"order by stddev_pop() on columns of table \"proposal_vote\""
input proposal_vote_stddev_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate stddev_samp on columns"
type proposal_vote_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"order by stddev_samp() on columns of table \"proposal_vote\""
input proposal_vote_stddev_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate sum on columns"
type proposal_vote_sum_fields {
  height: bigint
  proposal_id: Int
}

"order by sum() on columns of table \"proposal_vote\""
input proposal_vote_sum_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate var_pop on columns"
type proposal_vote_var_pop_fields {
  height: Float
  proposal_id: Float
}

"order by var_pop() on columns of table \"proposal_vote\""
input proposal_vote_var_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate var_samp on columns"
type proposal_vote_var_samp_fields {
  height: Float
  proposal_id: Float
}

"order by var_samp() on columns of table \"proposal_vote\""
input proposal_vote_var_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"aggregate variance on columns"
type proposal_vote_variance_fields {
  height: Float
  proposal_id: Float
}

"order by variance() on columns of table \"proposal_vote\""
input proposal_vote_variance_order_by {
  height: order_by
  proposal_id: order_by
}

type query_root {
  "fetch data from the table: \"account\""
  account("distinct select on columns" distinct_on: [account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_order_by!] "filter the rows returned" where: account_bool_exp): [account!]!
  "fetch aggregated fields from the table: \"account\""
  account_aggregate("distinct select on columns" distinct_on: [account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_order_by!] "filter the rows returned" where: account_bool_exp): account_aggregate!
  "fetch data from the table: \"account_balance\""
  account_balance("distinct select on columns" distinct_on: [account_balance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_order_by!] "filter the rows returned" where: account_balance_bool_exp): [account_balance!]!
  "fetch aggregated fields from the table: \"account_balance\""
  account_balance_aggregate("distinct select on columns" distinct_on: [account_balance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_order_by!] "filter the rows returned" where: account_balance_bool_exp): account_balance_aggregate!
  "fetch data from the table: \"account_balance\" using primary key columns"
  account_balance_by_pk(address: String!): account_balance
  "fetch data from the table: \"account_balance_history\""
  account_balance_history("distinct select on columns" distinct_on: [account_balance_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_history_order_by!] "filter the rows returned" where: account_balance_history_bool_exp): [account_balance_history!]!
  "fetch aggregated fields from the table: \"account_balance_history\""
  account_balance_history_aggregate("distinct select on columns" distinct_on: [account_balance_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_history_order_by!] "filter the rows returned" where: account_balance_history_bool_exp): account_balance_history_aggregate!
  "fetch data from the table: \"account\" using primary key columns"
  account_by_pk(address: String!): account
  "fetch data from the table: \"application_link\""
  application_link("distinct select on columns" distinct_on: [application_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_order_by!] "filter the rows returned" where: application_link_bool_exp): [application_link!]!
  "fetch aggregated fields from the table: \"application_link\""
  application_link_aggregate("distinct select on columns" distinct_on: [application_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_order_by!] "filter the rows returned" where: application_link_bool_exp): application_link_aggregate!
  "fetch data from the table: \"application_link\" using primary key columns"
  application_link_by_pk(id: Int!): application_link
  "fetch data from the table: \"application_link_oracle_request\""
  application_link_oracle_request("distinct select on columns" distinct_on: [application_link_oracle_request_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_oracle_request_order_by!] "filter the rows returned" where: application_link_oracle_request_bool_exp): [application_link_oracle_request!]!
  "fetch aggregated fields from the table: \"application_link_oracle_request\""
  application_link_oracle_request_aggregate("distinct select on columns" distinct_on: [application_link_oracle_request_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_oracle_request_order_by!] "filter the rows returned" where: application_link_oracle_request_bool_exp): application_link_oracle_request_aggregate!
  "fetch data from the table: \"application_link_oracle_request\" using primary key columns"
  application_link_oracle_request_by_pk(id: Int!): application_link_oracle_request
  "fetch data from the table: \"average_block_time_from_genesis\""
  average_block_time_from_genesis("distinct select on columns" distinct_on: [average_block_time_from_genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_from_genesis_order_by!] "filter the rows returned" where: average_block_time_from_genesis_bool_exp): [average_block_time_from_genesis!]!
  "fetch aggregated fields from the table: \"average_block_time_from_genesis\""
  average_block_time_from_genesis_aggregate("distinct select on columns" distinct_on: [average_block_time_from_genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_from_genesis_order_by!] "filter the rows returned" where: average_block_time_from_genesis_bool_exp): average_block_time_from_genesis_aggregate!
  "fetch data from the table: \"average_block_time_per_day\""
  average_block_time_per_day("distinct select on columns" distinct_on: [average_block_time_per_day_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_day_order_by!] "filter the rows returned" where: average_block_time_per_day_bool_exp): [average_block_time_per_day!]!
  "fetch aggregated fields from the table: \"average_block_time_per_day\""
  average_block_time_per_day_aggregate("distinct select on columns" distinct_on: [average_block_time_per_day_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_day_order_by!] "filter the rows returned" where: average_block_time_per_day_bool_exp): average_block_time_per_day_aggregate!
  "fetch data from the table: \"average_block_time_per_hour\""
  average_block_time_per_hour("distinct select on columns" distinct_on: [average_block_time_per_hour_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_hour_order_by!] "filter the rows returned" where: average_block_time_per_hour_bool_exp): [average_block_time_per_hour!]!
  "fetch aggregated fields from the table: \"average_block_time_per_hour\""
  average_block_time_per_hour_aggregate("distinct select on columns" distinct_on: [average_block_time_per_hour_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_hour_order_by!] "filter the rows returned" where: average_block_time_per_hour_bool_exp): average_block_time_per_hour_aggregate!
  "fetch data from the table: \"average_block_time_per_minute\""
  average_block_time_per_minute("distinct select on columns" distinct_on: [average_block_time_per_minute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_minute_order_by!] "filter the rows returned" where: average_block_time_per_minute_bool_exp): [average_block_time_per_minute!]!
  "fetch aggregated fields from the table: \"average_block_time_per_minute\""
  average_block_time_per_minute_aggregate("distinct select on columns" distinct_on: [average_block_time_per_minute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_minute_order_by!] "filter the rows returned" where: average_block_time_per_minute_bool_exp): average_block_time_per_minute_aggregate!
  "fetch data from the table: \"block\""
  block("distinct select on columns" distinct_on: [block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_order_by!] "filter the rows returned" where: block_bool_exp): [block!]!
  "fetch aggregated fields from the table: \"block\""
  block_aggregate("distinct select on columns" distinct_on: [block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_order_by!] "filter the rows returned" where: block_bool_exp): block_aggregate!
  "fetch data from the table: \"block\" using primary key columns"
  block_by_pk(height: bigint!): block
  "fetch data from the table: \"chain_link\""
  chain_link("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): [chain_link!]!
  "fetch aggregated fields from the table: \"chain_link\""
  chain_link_aggregate("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): chain_link_aggregate!
  "fetch data from the table: \"chain_link\" using primary key columns"
  chain_link_by_pk(id: Int!): chain_link
  "fetch data from the table: \"chain_link_chain_config\""
  chain_link_chain_config("distinct select on columns" distinct_on: [chain_link_chain_config_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_chain_config_order_by!] "filter the rows returned" where: chain_link_chain_config_bool_exp): [chain_link_chain_config!]!
  "fetch aggregated fields from the table: \"chain_link_chain_config\""
  chain_link_chain_config_aggregate("distinct select on columns" distinct_on: [chain_link_chain_config_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_chain_config_order_by!] "filter the rows returned" where: chain_link_chain_config_bool_exp): chain_link_chain_config_aggregate!
  "fetch data from the table: \"chain_link_chain_config\" using primary key columns"
  chain_link_chain_config_by_pk(id: Int!): chain_link_chain_config
  "fetch data from the table: \"chain_link_proof\""
  chain_link_proof("distinct select on columns" distinct_on: [chain_link_proof_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_proof_order_by!] "filter the rows returned" where: chain_link_proof_bool_exp): [chain_link_proof!]!
  "fetch aggregated fields from the table: \"chain_link_proof\""
  chain_link_proof_aggregate("distinct select on columns" distinct_on: [chain_link_proof_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_proof_order_by!] "filter the rows returned" where: chain_link_proof_bool_exp): chain_link_proof_aggregate!
  "fetch data from the table: \"community_pool\""
  community_pool("distinct select on columns" distinct_on: [community_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [community_pool_order_by!] "filter the rows returned" where: community_pool_bool_exp): [community_pool!]!
  "fetch aggregated fields from the table: \"community_pool\""
  community_pool_aggregate("distinct select on columns" distinct_on: [community_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [community_pool_order_by!] "filter the rows returned" where: community_pool_bool_exp): community_pool_aggregate!
  "fetch data from the table: \"delegation\""
  delegation("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): [delegation!]!
  "fetch aggregated fields from the table: \"delegation\""
  delegation_aggregate("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): delegation_aggregate!
  "fetch data from the table: \"delegation\" using primary key columns"
  delegation_by_pk(id: Int!): delegation
  "fetch data from the table: \"delegation_reward\""
  delegation_reward("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): [delegation_reward!]!
  "fetch aggregated fields from the table: \"delegation_reward\""
  delegation_reward_aggregate("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): delegation_reward_aggregate!
  "fetch data from the table: \"distribution_params\""
  distribution_params("distinct select on columns" distinct_on: [distribution_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [distribution_params_order_by!] "filter the rows returned" where: distribution_params_bool_exp): [distribution_params!]!
  "fetch aggregated fields from the table: \"distribution_params\""
  distribution_params_aggregate("distinct select on columns" distinct_on: [distribution_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [distribution_params_order_by!] "filter the rows returned" where: distribution_params_bool_exp): distribution_params_aggregate!
  "fetch data from the table: \"distribution_params\" using primary key columns"
  distribution_params_by_pk(one_row_id: Boolean!): distribution_params
  "fetch data from the table: \"double_sign_evidence\""
  double_sign_evidence("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): [double_sign_evidence!]!
  "fetch aggregated fields from the table: \"double_sign_evidence\""
  double_sign_evidence_aggregate("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): double_sign_evidence_aggregate!
  "fetch data from the table: \"double_sign_vote\""
  double_sign_vote("distinct select on columns" distinct_on: [double_sign_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_vote_order_by!] "filter the rows returned" where: double_sign_vote_bool_exp): [double_sign_vote!]!
  "fetch aggregated fields from the table: \"double_sign_vote\""
  double_sign_vote_aggregate("distinct select on columns" distinct_on: [double_sign_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_vote_order_by!] "filter the rows returned" where: double_sign_vote_bool_exp): double_sign_vote_aggregate!
  "fetch data from the table: \"double_sign_vote\" using primary key columns"
  double_sign_vote_by_pk(id: Int!): double_sign_vote
  "An array relationship"
  dtag_transfer_requests("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): [dtag_transfer_requests!]!
  "An aggregate relationship"
  dtag_transfer_requests_aggregate("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): dtag_transfer_requests_aggregate!
  "fetch data from the table: \"fee_grant_allowance\""
  fee_grant_allowance("distinct select on columns" distinct_on: [fee_grant_allowance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fee_grant_allowance_order_by!] "filter the rows returned" where: fee_grant_allowance_bool_exp): [fee_grant_allowance!]!
  "fetch aggregated fields from the table: \"fee_grant_allowance\""
  fee_grant_allowance_aggregate("distinct select on columns" distinct_on: [fee_grant_allowance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fee_grant_allowance_order_by!] "filter the rows returned" where: fee_grant_allowance_bool_exp): fee_grant_allowance_aggregate!
  "fetch data from the table: \"fee_grant_allowance\" using primary key columns"
  fee_grant_allowance_by_pk(id: Int!): fee_grant_allowance
  "fetch data from the table: \"genesis\""
  genesis("distinct select on columns" distinct_on: [genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [genesis_order_by!] "filter the rows returned" where: genesis_bool_exp): [genesis!]!
  "fetch aggregated fields from the table: \"genesis\""
  genesis_aggregate("distinct select on columns" distinct_on: [genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [genesis_order_by!] "filter the rows returned" where: genesis_bool_exp): genesis_aggregate!
  "fetch data from the table: \"gov_params\""
  gov_params("distinct select on columns" distinct_on: [gov_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [gov_params_order_by!] "filter the rows returned" where: gov_params_bool_exp): [gov_params!]!
  "fetch aggregated fields from the table: \"gov_params\""
  gov_params_aggregate("distinct select on columns" distinct_on: [gov_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [gov_params_order_by!] "filter the rows returned" where: gov_params_bool_exp): gov_params_aggregate!
  "fetch data from the table: \"gov_params\" using primary key columns"
  gov_params_by_pk(one_row_id: Boolean!): gov_params
  "fetch data from the table: \"inflation\""
  inflation("distinct select on columns" distinct_on: [inflation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [inflation_order_by!] "filter the rows returned" where: inflation_bool_exp): [inflation!]!
  "fetch aggregated fields from the table: \"inflation\""
  inflation_aggregate("distinct select on columns" distinct_on: [inflation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [inflation_order_by!] "filter the rows returned" where: inflation_bool_exp): inflation_aggregate!
  "fetch data from the table: \"message\""
  message("distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): [message!]!
  "fetch aggregated fields from the table: \"message\""
  message_aggregate("distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): message_aggregate!
  "execute function \"messages_by_address\" which returns \"message\""
  messages_by_address("input parameters for function \"messages_by_address\"" args: messages_by_address_args! "distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): [message!]!
  "execute function \"messages_by_address\" and query aggregates on result of table type \"message\""
  messages_by_address_aggregate("input parameters for function \"messages_by_address\"" args: messages_by_address_args! "distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): message_aggregate!
  "fetch data from the table: \"mint_params\""
  mint_params("distinct select on columns" distinct_on: [mint_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [mint_params_order_by!] "filter the rows returned" where: mint_params_bool_exp): [mint_params!]!
  "fetch aggregated fields from the table: \"mint_params\""
  mint_params_aggregate("distinct select on columns" distinct_on: [mint_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [mint_params_order_by!] "filter the rows returned" where: mint_params_bool_exp): mint_params_aggregate!
  "fetch data from the table: \"mint_params\" using primary key columns"
  mint_params_by_pk(one_row_id: Boolean!): mint_params
  "fetch data from the table: \"modules\""
  modules("distinct select on columns" distinct_on: [modules_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [modules_order_by!] "filter the rows returned" where: modules_bool_exp): [modules!]!
  "fetch aggregated fields from the table: \"modules\""
  modules_aggregate("distinct select on columns" distinct_on: [modules_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [modules_order_by!] "filter the rows returned" where: modules_bool_exp): modules_aggregate!
  "fetch data from the table: \"modules\" using primary key columns"
  modules_by_pk(module_name: String!): modules
  "fetch data from the table: \"poll\""
  poll("distinct select on columns" distinct_on: [poll_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_order_by!] "filter the rows returned" where: poll_bool_exp): [poll!]!
  "fetch aggregated fields from the table: \"poll\""
  poll_aggregate("distinct select on columns" distinct_on: [poll_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_order_by!] "filter the rows returned" where: poll_bool_exp): poll_aggregate!
  "fetch data from the table: \"poll_answer\""
  poll_answer("distinct select on columns" distinct_on: [poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_answer_order_by!] "filter the rows returned" where: poll_answer_bool_exp): [poll_answer!]!
  "fetch aggregated fields from the table: \"poll_answer\""
  poll_answer_aggregate("distinct select on columns" distinct_on: [poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_answer_order_by!] "filter the rows returned" where: poll_answer_bool_exp): poll_answer_aggregate!
  "fetch data from the table: \"poll\" using primary key columns"
  poll_by_pk(id: Int!): poll
  "fetch data from the table: \"post\""
  post("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): [post!]!
  "fetch aggregated fields from the table: \"post\""
  post_aggregate("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): post_aggregate!
  "fetch data from the table: \"post_attachment\""
  post_attachment("distinct select on columns" distinct_on: [post_attachment_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_order_by!] "filter the rows returned" where: post_attachment_bool_exp): [post_attachment!]!
  "fetch aggregated fields from the table: \"post_attachment\""
  post_attachment_aggregate("distinct select on columns" distinct_on: [post_attachment_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_order_by!] "filter the rows returned" where: post_attachment_bool_exp): post_attachment_aggregate!
  "fetch data from the table: \"post_attachment\" using primary key columns"
  post_attachment_by_pk(id: Int!): post_attachment
  "fetch data from the table: \"post_attachment_tag\""
  post_attachment_tag("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): [post_attachment_tag!]!
  "fetch aggregated fields from the table: \"post_attachment_tag\""
  post_attachment_tag_aggregate("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): post_attachment_tag_aggregate!
  "fetch data from the table: \"post_attribute\""
  post_attribute("distinct select on columns" distinct_on: [post_attribute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attribute_order_by!] "filter the rows returned" where: post_attribute_bool_exp): [post_attribute!]!
  "fetch aggregated fields from the table: \"post_attribute\""
  post_attribute_aggregate("distinct select on columns" distinct_on: [post_attribute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attribute_order_by!] "filter the rows returned" where: post_attribute_bool_exp): post_attribute_aggregate!
  "fetch data from the table: \"post\" using primary key columns"
  post_by_pk(id: String!): post
  "fetch data from the table: \"post_reaction\""
  post_reaction("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): [post_reaction!]!
  "fetch aggregated fields from the table: \"post_reaction\""
  post_reaction_aggregate("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): post_reaction_aggregate!
  "fetch data from the table: \"post_report\""
  post_report("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): [post_report!]!
  "fetch aggregated fields from the table: \"post_report\""
  post_report_aggregate("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): post_report_aggregate!
  "fetch data from the table: \"pre_commit\""
  pre_commit("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): [pre_commit!]!
  "fetch aggregated fields from the table: \"pre_commit\""
  pre_commit_aggregate("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): pre_commit_aggregate!
  "fetch data from the table: \"profile\""
  profile("distinct select on columns" distinct_on: [profile_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_order_by!] "filter the rows returned" where: profile_bool_exp): [profile!]!
  "fetch aggregated fields from the table: \"profile\""
  profile_aggregate("distinct select on columns" distinct_on: [profile_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_order_by!] "filter the rows returned" where: profile_bool_exp): profile_aggregate!
  "fetch data from the table: \"profile\" using primary key columns"
  profile_by_pk(address: String!): profile
  "fetch data from the table: \"profile_relationship\""
  profile_relationship("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): [profile_relationship!]!
  "fetch aggregated fields from the table: \"profile_relationship\""
  profile_relationship_aggregate("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): profile_relationship_aggregate!
  "fetch data from the table: \"profiles_params\""
  profiles_params("distinct select on columns" distinct_on: [profiles_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profiles_params_order_by!] "filter the rows returned" where: profiles_params_bool_exp): [profiles_params!]!
  "fetch data from the table: \"proposal\""
  proposal("distinct select on columns" distinct_on: [proposal_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_order_by!] "filter the rows returned" where: proposal_bool_exp): [proposal!]!
  "fetch aggregated fields from the table: \"proposal\""
  proposal_aggregate("distinct select on columns" distinct_on: [proposal_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_order_by!] "filter the rows returned" where: proposal_bool_exp): proposal_aggregate!
  "fetch data from the table: \"proposal\" using primary key columns"
  proposal_by_pk(id: Int!): proposal
  "fetch data from the table: \"proposal_deposit\""
  proposal_deposit("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): [proposal_deposit!]!
  "fetch aggregated fields from the table: \"proposal_deposit\""
  proposal_deposit_aggregate("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): proposal_deposit_aggregate!
  "fetch data from the table: \"proposal_staking_pool_snapshot\""
  proposal_staking_pool_snapshot("distinct select on columns" distinct_on: [proposal_staking_pool_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_staking_pool_snapshot_order_by!] "filter the rows returned" where: proposal_staking_pool_snapshot_bool_exp): [proposal_staking_pool_snapshot!]!
  "fetch aggregated fields from the table: \"proposal_staking_pool_snapshot\""
  proposal_staking_pool_snapshot_aggregate("distinct select on columns" distinct_on: [proposal_staking_pool_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_staking_pool_snapshot_order_by!] "filter the rows returned" where: proposal_staking_pool_snapshot_bool_exp): proposal_staking_pool_snapshot_aggregate!
  "fetch data from the table: \"proposal_staking_pool_snapshot\" using primary key columns"
  proposal_staking_pool_snapshot_by_pk(proposal_id: Int!): proposal_staking_pool_snapshot
  "fetch data from the table: \"proposal_tally_result\""
  proposal_tally_result("distinct select on columns" distinct_on: [proposal_tally_result_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_tally_result_order_by!] "filter the rows returned" where: proposal_tally_result_bool_exp): [proposal_tally_result!]!
  "fetch aggregated fields from the table: \"proposal_tally_result\""
  proposal_tally_result_aggregate("distinct select on columns" distinct_on: [proposal_tally_result_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_tally_result_order_by!] "filter the rows returned" where: proposal_tally_result_bool_exp): proposal_tally_result_aggregate!
  "fetch data from the table: \"proposal_tally_result\" using primary key columns"
  proposal_tally_result_by_pk(proposal_id: Int!): proposal_tally_result
  "fetch data from the table: \"proposal_validator_status_snapshot\""
  proposal_validator_status_snapshot("distinct select on columns" distinct_on: [proposal_validator_status_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_validator_status_snapshot_order_by!] "filter the rows returned" where: proposal_validator_status_snapshot_bool_exp): [proposal_validator_status_snapshot!]!
  "fetch aggregated fields from the table: \"proposal_validator_status_snapshot\""
  proposal_validator_status_snapshot_aggregate("distinct select on columns" distinct_on: [proposal_validator_status_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_validator_status_snapshot_order_by!] "filter the rows returned" where: proposal_validator_status_snapshot_bool_exp): proposal_validator_status_snapshot_aggregate!
  "fetch data from the table: \"proposal_validator_status_snapshot\" using primary key columns"
  proposal_validator_status_snapshot_by_pk(id: Int!): proposal_validator_status_snapshot
  "fetch data from the table: \"proposal_vote\""
  proposal_vote("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): [proposal_vote!]!
  "fetch aggregated fields from the table: \"proposal_vote\""
  proposal_vote_aggregate("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): proposal_vote_aggregate!
  "fetch data from the table: \"redelegation\""
  redelegation("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): [redelegation!]!
  "fetch aggregated fields from the table: \"redelegation\""
  redelegation_aggregate("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): redelegation_aggregate!
  "An array relationship"
  registered_reactions("distinct select on columns" distinct_on: [registered_reactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [registered_reactions_order_by!] "filter the rows returned" where: registered_reactions_bool_exp): [registered_reactions!]!
  "An aggregate relationship"
  registered_reactions_aggregate("distinct select on columns" distinct_on: [registered_reactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [registered_reactions_order_by!] "filter the rows returned" where: registered_reactions_bool_exp): registered_reactions_aggregate!
  "fetch data from the table: \"slashing_params\""
  slashing_params("distinct select on columns" distinct_on: [slashing_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [slashing_params_order_by!] "filter the rows returned" where: slashing_params_bool_exp): [slashing_params!]!
  "fetch aggregated fields from the table: \"slashing_params\""
  slashing_params_aggregate("distinct select on columns" distinct_on: [slashing_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [slashing_params_order_by!] "filter the rows returned" where: slashing_params_bool_exp): slashing_params_aggregate!
  "fetch data from the table: \"slashing_params\" using primary key columns"
  slashing_params_by_pk(one_row_id: Boolean!): slashing_params
  "fetch data from the table: \"staking_params\""
  staking_params("distinct select on columns" distinct_on: [staking_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_params_order_by!] "filter the rows returned" where: staking_params_bool_exp): [staking_params!]!
  "fetch aggregated fields from the table: \"staking_params\""
  staking_params_aggregate("distinct select on columns" distinct_on: [staking_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_params_order_by!] "filter the rows returned" where: staking_params_bool_exp): staking_params_aggregate!
  "fetch data from the table: \"staking_params\" using primary key columns"
  staking_params_by_pk(one_row_id: Boolean!): staking_params
  "fetch data from the table: \"staking_pool\""
  staking_pool("distinct select on columns" distinct_on: [staking_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_pool_order_by!] "filter the rows returned" where: staking_pool_bool_exp): [staking_pool!]!
  "fetch aggregated fields from the table: \"staking_pool\""
  staking_pool_aggregate("distinct select on columns" distinct_on: [staking_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_pool_order_by!] "filter the rows returned" where: staking_pool_bool_exp): staking_pool_aggregate!
  "fetch data from the table: \"supply\""
  supply("distinct select on columns" distinct_on: [supply_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [supply_order_by!] "filter the rows returned" where: supply_bool_exp): [supply!]!
  "fetch aggregated fields from the table: \"supply\""
  supply_aggregate("distinct select on columns" distinct_on: [supply_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [supply_order_by!] "filter the rows returned" where: supply_bool_exp): supply_aggregate!
  "fetch data from the table: \"token\""
  token("distinct select on columns" distinct_on: [token_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_order_by!] "filter the rows returned" where: token_bool_exp): [token!]!
  "fetch aggregated fields from the table: \"token\""
  token_aggregate("distinct select on columns" distinct_on: [token_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_order_by!] "filter the rows returned" where: token_bool_exp): token_aggregate!
  "fetch data from the table: \"token_price\""
  token_price("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): [token_price!]!
  "fetch aggregated fields from the table: \"token_price\""
  token_price_aggregate("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): token_price_aggregate!
  "fetch data from the table: \"token_price\" using primary key columns"
  token_price_by_pk(id: Int!): token_price
  "fetch data from the table: \"token_price_history\""
  token_price_history("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): [token_price_history!]!
  "fetch aggregated fields from the table: \"token_price_history\""
  token_price_history_aggregate("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): token_price_history_aggregate!
  "fetch data from the table: \"token_unit\""
  token_unit("distinct select on columns" distinct_on: [token_unit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_unit_order_by!] "filter the rows returned" where: token_unit_bool_exp): [token_unit!]!
  "fetch aggregated fields from the table: \"token_unit\""
  token_unit_aggregate("distinct select on columns" distinct_on: [token_unit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_unit_order_by!] "filter the rows returned" where: token_unit_bool_exp): token_unit_aggregate!
  "fetch data from the table: \"transaction\""
  transaction("distinct select on columns" distinct_on: [transaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [transaction_order_by!] "filter the rows returned" where: transaction_bool_exp): [transaction!]!
  "fetch aggregated fields from the table: \"transaction\""
  transaction_aggregate("distinct select on columns" distinct_on: [transaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [transaction_order_by!] "filter the rows returned" where: transaction_bool_exp): transaction_aggregate!
  "fetch data from the table: \"transaction\" using primary key columns"
  transaction_by_pk(hash: String!): transaction
  "fetch data from the table: \"unbonding_delegation\""
  unbonding_delegation("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): [unbonding_delegation!]!
  "fetch aggregated fields from the table: \"unbonding_delegation\""
  unbonding_delegation_aggregate("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): unbonding_delegation_aggregate!
  "fetch data from the table: \"user_block\""
  user_block("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): [user_block!]!
  "fetch aggregated fields from the table: \"user_block\""
  user_block_aggregate("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): user_block_aggregate!
  "fetch data from the table: \"user_poll_answer\""
  user_poll_answer("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): [user_poll_answer!]!
  "fetch aggregated fields from the table: \"user_poll_answer\""
  user_poll_answer_aggregate("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): user_poll_answer_aggregate!
  "fetch data from the table: \"validator\""
  validator("distinct select on columns" distinct_on: [validator_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_order_by!] "filter the rows returned" where: validator_bool_exp): [validator!]!
  "fetch aggregated fields from the table: \"validator\""
  validator_aggregate("distinct select on columns" distinct_on: [validator_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_order_by!] "filter the rows returned" where: validator_bool_exp): validator_aggregate!
  "fetch data from the table: \"validator\" using primary key columns"
  validator_by_pk(consensus_address: String!): validator
  "fetch data from the table: \"validator_commission\""
  validator_commission("distinct select on columns" distinct_on: [validator_commission_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_order_by!] "filter the rows returned" where: validator_commission_bool_exp): [validator_commission!]!
  "fetch aggregated fields from the table: \"validator_commission\""
  validator_commission_aggregate("distinct select on columns" distinct_on: [validator_commission_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_order_by!] "filter the rows returned" where: validator_commission_bool_exp): validator_commission_aggregate!
  "fetch data from the table: \"validator_commission_amount\""
  validator_commission_amount("distinct select on columns" distinct_on: [validator_commission_amount_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_amount_order_by!] "filter the rows returned" where: validator_commission_amount_bool_exp): [validator_commission_amount!]!
  "fetch aggregated fields from the table: \"validator_commission_amount\""
  validator_commission_amount_aggregate("distinct select on columns" distinct_on: [validator_commission_amount_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_amount_order_by!] "filter the rows returned" where: validator_commission_amount_bool_exp): validator_commission_amount_aggregate!
  "fetch data from the table: \"validator_commission_amount\" using primary key columns"
  validator_commission_amount_by_pk(validator_address: String!): validator_commission_amount
  "fetch data from the table: \"validator_commission\" using primary key columns"
  validator_commission_by_pk(validator_address: String!): validator_commission
  "fetch data from the table: \"validator_description\""
  validator_description("distinct select on columns" distinct_on: [validator_description_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_description_order_by!] "filter the rows returned" where: validator_description_bool_exp): [validator_description!]!
  "fetch aggregated fields from the table: \"validator_description\""
  validator_description_aggregate("distinct select on columns" distinct_on: [validator_description_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_description_order_by!] "filter the rows returned" where: validator_description_bool_exp): validator_description_aggregate!
  "fetch data from the table: \"validator_description\" using primary key columns"
  validator_description_by_pk(validator_address: String!): validator_description
  "fetch data from the table: \"validator_info\""
  validator_info("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): [validator_info!]!
  "fetch aggregated fields from the table: \"validator_info\""
  validator_info_aggregate("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): validator_info_aggregate!
  "fetch data from the table: \"validator_info\" using primary key columns"
  validator_info_by_pk(consensus_address: String!): validator_info
  "fetch data from the table: \"validator_signing_info\""
  validator_signing_info("distinct select on columns" distinct_on: [validator_signing_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_signing_info_order_by!] "filter the rows returned" where: validator_signing_info_bool_exp): [validator_signing_info!]!
  "fetch aggregated fields from the table: \"validator_signing_info\""
  validator_signing_info_aggregate("distinct select on columns" distinct_on: [validator_signing_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_signing_info_order_by!] "filter the rows returned" where: validator_signing_info_bool_exp): validator_signing_info_aggregate!
  "fetch data from the table: \"validator_signing_info\" using primary key columns"
  validator_signing_info_by_pk(validator_address: String!): validator_signing_info
  "fetch data from the table: \"validator_status\""
  validator_status("distinct select on columns" distinct_on: [validator_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_status_order_by!] "filter the rows returned" where: validator_status_bool_exp): [validator_status!]!
  "fetch aggregated fields from the table: \"validator_status\""
  validator_status_aggregate("distinct select on columns" distinct_on: [validator_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_status_order_by!] "filter the rows returned" where: validator_status_bool_exp): validator_status_aggregate!
  "fetch data from the table: \"validator_status\" using primary key columns"
  validator_status_by_pk(validator_address: String!): validator_status
  "fetch data from the table: \"validator_voting_power\""
  validator_voting_power("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): [validator_voting_power!]!
  "fetch aggregated fields from the table: \"validator_voting_power\""
  validator_voting_power_aggregate("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): validator_voting_power_aggregate!
  "fetch data from the table: \"validator_voting_power\" using primary key columns"
  validator_voting_power_by_pk(validator_address: String!): validator_voting_power
  "fetch data from the table: \"vesting_account\""
  vesting_account("distinct select on columns" distinct_on: [vesting_account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_account_order_by!] "filter the rows returned" where: vesting_account_bool_exp): [vesting_account!]!
  "fetch aggregated fields from the table: \"vesting_account\""
  vesting_account_aggregate("distinct select on columns" distinct_on: [vesting_account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_account_order_by!] "filter the rows returned" where: vesting_account_bool_exp): vesting_account_aggregate!
  "fetch data from the table: \"vesting_account\" using primary key columns"
  vesting_account_by_pk(id: Int!): vesting_account
  "fetch data from the table: \"vesting_period\""
  vesting_period("distinct select on columns" distinct_on: [vesting_period_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_period_order_by!] "filter the rows returned" where: vesting_period_bool_exp): [vesting_period!]!
  "fetch aggregated fields from the table: \"vesting_period\""
  vesting_period_aggregate("distinct select on columns" distinct_on: [vesting_period_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_period_order_by!] "filter the rows returned" where: vesting_period_bool_exp): vesting_period_aggregate!
}

"columns and relationships of \"redelegation\""
type redelegation {
  "An object relationship"
  account: account!
  amount: coin!
  completion_time: timestamp!
  delegator_address: String!
  dst_validator_address: String!
  height: bigint!
  src_validator_address: String!
  "An object relationship"
  validator: validator!
  "An object relationship"
  validatorByDstValidatorAddress: validator!
}

"aggregated selection of \"redelegation\""
type redelegation_aggregate {
  aggregate: redelegation_aggregate_fields
  nodes: [redelegation!]!
}

"aggregate fields of \"redelegation\""
type redelegation_aggregate_fields {
  avg: redelegation_avg_fields
  count(columns: [redelegation_select_column!] distinct: Boolean): Int!
  max: redelegation_max_fields
  min: redelegation_min_fields
  stddev: redelegation_stddev_fields
  stddev_pop: redelegation_stddev_pop_fields
  stddev_samp: redelegation_stddev_samp_fields
  sum: redelegation_sum_fields
  var_pop: redelegation_var_pop_fields
  var_samp: redelegation_var_samp_fields
  variance: redelegation_variance_fields
}

"order by aggregate values of table \"redelegation\""
input redelegation_aggregate_order_by {
  avg: redelegation_avg_order_by
  count: order_by
  max: redelegation_max_order_by
  min: redelegation_min_order_by
  stddev: redelegation_stddev_order_by
  stddev_pop: redelegation_stddev_pop_order_by
  stddev_samp: redelegation_stddev_samp_order_by
  sum: redelegation_sum_order_by
  var_pop: redelegation_var_pop_order_by
  var_samp: redelegation_var_samp_order_by
  variance: redelegation_variance_order_by
}

"aggregate avg on columns"
type redelegation_avg_fields {
  height: Float
}

"order by avg() on columns of table \"redelegation\""
input redelegation_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"redelegation\". All fields are combined with a logical 'AND'."
input redelegation_bool_exp {
  _and: [redelegation_bool_exp!]
  _not: redelegation_bool_exp
  _or: [redelegation_bool_exp!]
  account: account_bool_exp
  amount: coin_comparison_exp
  completion_time: timestamp_comparison_exp
  delegator_address: String_comparison_exp
  dst_validator_address: String_comparison_exp
  height: bigint_comparison_exp
  src_validator_address: String_comparison_exp
  validator: validator_bool_exp
  validatorByDstValidatorAddress: validator_bool_exp
}

"aggregate max on columns"
type redelegation_max_fields {
  completion_time: timestamp
  delegator_address: String
  dst_validator_address: String
  height: bigint
  src_validator_address: String
}

"order by max() on columns of table \"redelegation\""
input redelegation_max_order_by {
  completion_time: order_by
  delegator_address: order_by
  dst_validator_address: order_by
  height: order_by
  src_validator_address: order_by
}

"aggregate min on columns"
type redelegation_min_fields {
  completion_time: timestamp
  delegator_address: String
  dst_validator_address: String
  height: bigint
  src_validator_address: String
}

"order by min() on columns of table \"redelegation\""
input redelegation_min_order_by {
  completion_time: order_by
  delegator_address: order_by
  dst_validator_address: order_by
  height: order_by
  src_validator_address: order_by
}

"Ordering options when selecting data from \"redelegation\"."
input redelegation_order_by {
  account: account_order_by
  amount: order_by
  completion_time: order_by
  delegator_address: order_by
  dst_validator_address: order_by
  height: order_by
  src_validator_address: order_by
  validator: validator_order_by
  validatorByDstValidatorAddress: validator_order_by
}

"select columns of table \"redelegation\""
enum redelegation_select_column {
  "column name"
  amount
  "column name"
  completion_time
  "column name"
  delegator_address
  "column name"
  dst_validator_address
  "column name"
  height
  "column name"
  src_validator_address
}

"aggregate stddev on columns"
type redelegation_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"redelegation\""
input redelegation_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type redelegation_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"redelegation\""
input redelegation_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type redelegation_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"redelegation\""
input redelegation_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type redelegation_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"redelegation\""
input redelegation_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type redelegation_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"redelegation\""
input redelegation_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type redelegation_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"redelegation\""
input redelegation_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type redelegation_variance_fields {
  height: Float
}

"order by variance() on columns of table \"redelegation\""
input redelegation_variance_order_by {
  height: order_by
}

"columns and relationships of \"registered_reactions\""
type registered_reactions {
  height: bigint!
  owner_address: String!
  "An object relationship"
  profile: profile!
  short_code: String!
  subspace: String!
  value: String!
}

"aggregated selection of \"registered_reactions\""
type registered_reactions_aggregate {
  aggregate: registered_reactions_aggregate_fields
  nodes: [registered_reactions!]!
}

"aggregate fields of \"registered_reactions\""
type registered_reactions_aggregate_fields {
  avg: registered_reactions_avg_fields
  count(columns: [registered_reactions_select_column!] distinct: Boolean): Int!
  max: registered_reactions_max_fields
  min: registered_reactions_min_fields
  stddev: registered_reactions_stddev_fields
  stddev_pop: registered_reactions_stddev_pop_fields
  stddev_samp: registered_reactions_stddev_samp_fields
  sum: registered_reactions_sum_fields
  var_pop: registered_reactions_var_pop_fields
  var_samp: registered_reactions_var_samp_fields
  variance: registered_reactions_variance_fields
}

"order by aggregate values of table \"registered_reactions\""
input registered_reactions_aggregate_order_by {
  avg: registered_reactions_avg_order_by
  count: order_by
  max: registered_reactions_max_order_by
  min: registered_reactions_min_order_by
  stddev: registered_reactions_stddev_order_by
  stddev_pop: registered_reactions_stddev_pop_order_by
  stddev_samp: registered_reactions_stddev_samp_order_by
  sum: registered_reactions_sum_order_by
  var_pop: registered_reactions_var_pop_order_by
  var_samp: registered_reactions_var_samp_order_by
  variance: registered_reactions_variance_order_by
}

"aggregate avg on columns"
type registered_reactions_avg_fields {
  height: Float
}

"order by avg() on columns of table \"registered_reactions\""
input registered_reactions_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"registered_reactions\". All fields are combined with a logical 'AND'."
input registered_reactions_bool_exp {
  _and: [registered_reactions_bool_exp!]
  _not: registered_reactions_bool_exp
  _or: [registered_reactions_bool_exp!]
  height: bigint_comparison_exp
  owner_address: String_comparison_exp
  profile: profile_bool_exp
  short_code: String_comparison_exp
  subspace: String_comparison_exp
  value: String_comparison_exp
}

"aggregate max on columns"
type registered_reactions_max_fields {
  height: bigint
  owner_address: String
  short_code: String
  subspace: String
  value: String
}

"order by max() on columns of table \"registered_reactions\""
input registered_reactions_max_order_by {
  height: order_by
  owner_address: order_by
  short_code: order_by
  subspace: order_by
  value: order_by
}

"aggregate min on columns"
type registered_reactions_min_fields {
  height: bigint
  owner_address: String
  short_code: String
  subspace: String
  value: String
}

"order by min() on columns of table \"registered_reactions\""
input registered_reactions_min_order_by {
  height: order_by
  owner_address: order_by
  short_code: order_by
  subspace: order_by
  value: order_by
}

"Ordering options when selecting data from \"registered_reactions\"."
input registered_reactions_order_by {
  height: order_by
  owner_address: order_by
  profile: profile_order_by
  short_code: order_by
  subspace: order_by
  value: order_by
}

"select columns of table \"registered_reactions\""
enum registered_reactions_select_column {
  "column name"
  height
  "column name"
  owner_address
  "column name"
  short_code
  "column name"
  subspace
  "column name"
  value
}

"aggregate stddev on columns"
type registered_reactions_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"registered_reactions\""
input registered_reactions_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type registered_reactions_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"registered_reactions\""
input registered_reactions_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type registered_reactions_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"registered_reactions\""
input registered_reactions_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type registered_reactions_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"registered_reactions\""
input registered_reactions_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type registered_reactions_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"registered_reactions\""
input registered_reactions_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type registered_reactions_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"registered_reactions\""
input registered_reactions_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type registered_reactions_variance_fields {
  height: Float
}

"order by variance() on columns of table \"registered_reactions\""
input registered_reactions_variance_order_by {
  height: order_by
}

"columns and relationships of \"slashing_params\""
type slashing_params {
  height: bigint!
  one_row_id: Boolean!
  params("JSON select path" path: String): jsonb!
}

"aggregated selection of \"slashing_params\""
type slashing_params_aggregate {
  aggregate: slashing_params_aggregate_fields
  nodes: [slashing_params!]!
}

"aggregate fields of \"slashing_params\""
type slashing_params_aggregate_fields {
  avg: slashing_params_avg_fields
  count(columns: [slashing_params_select_column!] distinct: Boolean): Int!
  max: slashing_params_max_fields
  min: slashing_params_min_fields
  stddev: slashing_params_stddev_fields
  stddev_pop: slashing_params_stddev_pop_fields
  stddev_samp: slashing_params_stddev_samp_fields
  sum: slashing_params_sum_fields
  var_pop: slashing_params_var_pop_fields
  var_samp: slashing_params_var_samp_fields
  variance: slashing_params_variance_fields
}

"aggregate avg on columns"
type slashing_params_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"slashing_params\". All fields are combined with a logical 'AND'."
input slashing_params_bool_exp {
  _and: [slashing_params_bool_exp!]
  _not: slashing_params_bool_exp
  _or: [slashing_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"aggregate max on columns"
type slashing_params_max_fields {
  height: bigint
}

"aggregate min on columns"
type slashing_params_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"slashing_params\"."
input slashing_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"select columns of table \"slashing_params\""
enum slashing_params_select_column {
  "column name"
  height
  "column name"
  one_row_id
  "column name"
  params
}

"aggregate stddev on columns"
type slashing_params_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type slashing_params_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type slashing_params_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type slashing_params_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type slashing_params_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type slashing_params_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type slashing_params_variance_fields {
  height: Float
}

scalar smallint

"Boolean expression to compare columns of type \"smallint\". All fields are combined with logical 'AND'."
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"columns and relationships of \"staking_params\""
type staking_params {
  height: bigint!
  one_row_id: Boolean!
  params("JSON select path" path: String): jsonb!
}

"aggregated selection of \"staking_params\""
type staking_params_aggregate {
  aggregate: staking_params_aggregate_fields
  nodes: [staking_params!]!
}

"aggregate fields of \"staking_params\""
type staking_params_aggregate_fields {
  avg: staking_params_avg_fields
  count(columns: [staking_params_select_column!] distinct: Boolean): Int!
  max: staking_params_max_fields
  min: staking_params_min_fields
  stddev: staking_params_stddev_fields
  stddev_pop: staking_params_stddev_pop_fields
  stddev_samp: staking_params_stddev_samp_fields
  sum: staking_params_sum_fields
  var_pop: staking_params_var_pop_fields
  var_samp: staking_params_var_samp_fields
  variance: staking_params_variance_fields
}

"aggregate avg on columns"
type staking_params_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"staking_params\". All fields are combined with a logical 'AND'."
input staking_params_bool_exp {
  _and: [staking_params_bool_exp!]
  _not: staking_params_bool_exp
  _or: [staking_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"aggregate max on columns"
type staking_params_max_fields {
  height: bigint
}

"aggregate min on columns"
type staking_params_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"staking_params\"."
input staking_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"select columns of table \"staking_params\""
enum staking_params_select_column {
  "column name"
  height
  "column name"
  one_row_id
  "column name"
  params
}

"aggregate stddev on columns"
type staking_params_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type staking_params_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type staking_params_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type staking_params_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type staking_params_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type staking_params_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type staking_params_variance_fields {
  height: Float
}

"columns and relationships of \"staking_pool\""
type staking_pool {
  bonded_tokens: bigint!
  height: bigint!
  not_bonded_tokens: bigint!
}

"aggregated selection of \"staking_pool\""
type staking_pool_aggregate {
  aggregate: staking_pool_aggregate_fields
  nodes: [staking_pool!]!
}

"aggregate fields of \"staking_pool\""
type staking_pool_aggregate_fields {
  avg: staking_pool_avg_fields
  count(columns: [staking_pool_select_column!] distinct: Boolean): Int!
  max: staking_pool_max_fields
  min: staking_pool_min_fields
  stddev: staking_pool_stddev_fields
  stddev_pop: staking_pool_stddev_pop_fields
  stddev_samp: staking_pool_stddev_samp_fields
  sum: staking_pool_sum_fields
  var_pop: staking_pool_var_pop_fields
  var_samp: staking_pool_var_samp_fields
  variance: staking_pool_variance_fields
}

"aggregate avg on columns"
type staking_pool_avg_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

"Boolean expression to filter rows from the table \"staking_pool\". All fields are combined with a logical 'AND'."
input staking_pool_bool_exp {
  _and: [staking_pool_bool_exp!]
  _not: staking_pool_bool_exp
  _or: [staking_pool_bool_exp!]
  bonded_tokens: bigint_comparison_exp
  height: bigint_comparison_exp
  not_bonded_tokens: bigint_comparison_exp
}

"aggregate max on columns"
type staking_pool_max_fields {
  bonded_tokens: bigint
  height: bigint
  not_bonded_tokens: bigint
}

"aggregate min on columns"
type staking_pool_min_fields {
  bonded_tokens: bigint
  height: bigint
  not_bonded_tokens: bigint
}

"Ordering options when selecting data from \"staking_pool\"."
input staking_pool_order_by {
  bonded_tokens: order_by
  height: order_by
  not_bonded_tokens: order_by
}

"select columns of table \"staking_pool\""
enum staking_pool_select_column {
  "column name"
  bonded_tokens
  "column name"
  height
  "column name"
  not_bonded_tokens
}

"aggregate stddev on columns"
type staking_pool_stddev_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

"aggregate stddev_pop on columns"
type staking_pool_stddev_pop_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

"aggregate stddev_samp on columns"
type staking_pool_stddev_samp_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

"aggregate sum on columns"
type staking_pool_sum_fields {
  bonded_tokens: bigint
  height: bigint
  not_bonded_tokens: bigint
}

"aggregate var_pop on columns"
type staking_pool_var_pop_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

"aggregate var_samp on columns"
type staking_pool_var_samp_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

"aggregate variance on columns"
type staking_pool_variance_fields {
  bonded_tokens: Float
  height: Float
  not_bonded_tokens: Float
}

type subscription_root {
  "fetch data from the table: \"account\""
  account("distinct select on columns" distinct_on: [account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_order_by!] "filter the rows returned" where: account_bool_exp): [account!]!
  "fetch aggregated fields from the table: \"account\""
  account_aggregate("distinct select on columns" distinct_on: [account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_order_by!] "filter the rows returned" where: account_bool_exp): account_aggregate!
  "fetch data from the table: \"account_balance\""
  account_balance("distinct select on columns" distinct_on: [account_balance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_order_by!] "filter the rows returned" where: account_balance_bool_exp): [account_balance!]!
  "fetch aggregated fields from the table: \"account_balance\""
  account_balance_aggregate("distinct select on columns" distinct_on: [account_balance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_order_by!] "filter the rows returned" where: account_balance_bool_exp): account_balance_aggregate!
  "fetch data from the table: \"account_balance\" using primary key columns"
  account_balance_by_pk(address: String!): account_balance
  "fetch data from the table: \"account_balance_history\""
  account_balance_history("distinct select on columns" distinct_on: [account_balance_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_history_order_by!] "filter the rows returned" where: account_balance_history_bool_exp): [account_balance_history!]!
  "fetch aggregated fields from the table: \"account_balance_history\""
  account_balance_history_aggregate("distinct select on columns" distinct_on: [account_balance_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_balance_history_order_by!] "filter the rows returned" where: account_balance_history_bool_exp): account_balance_history_aggregate!
  "fetch data from the table: \"account\" using primary key columns"
  account_by_pk(address: String!): account
  "fetch data from the table: \"application_link\""
  application_link("distinct select on columns" distinct_on: [application_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_order_by!] "filter the rows returned" where: application_link_bool_exp): [application_link!]!
  "fetch aggregated fields from the table: \"application_link\""
  application_link_aggregate("distinct select on columns" distinct_on: [application_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_order_by!] "filter the rows returned" where: application_link_bool_exp): application_link_aggregate!
  "fetch data from the table: \"application_link\" using primary key columns"
  application_link_by_pk(id: Int!): application_link
  "fetch data from the table: \"application_link_oracle_request\""
  application_link_oracle_request("distinct select on columns" distinct_on: [application_link_oracle_request_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_oracle_request_order_by!] "filter the rows returned" where: application_link_oracle_request_bool_exp): [application_link_oracle_request!]!
  "fetch aggregated fields from the table: \"application_link_oracle_request\""
  application_link_oracle_request_aggregate("distinct select on columns" distinct_on: [application_link_oracle_request_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [application_link_oracle_request_order_by!] "filter the rows returned" where: application_link_oracle_request_bool_exp): application_link_oracle_request_aggregate!
  "fetch data from the table: \"application_link_oracle_request\" using primary key columns"
  application_link_oracle_request_by_pk(id: Int!): application_link_oracle_request
  "fetch data from the table: \"average_block_time_from_genesis\""
  average_block_time_from_genesis("distinct select on columns" distinct_on: [average_block_time_from_genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_from_genesis_order_by!] "filter the rows returned" where: average_block_time_from_genesis_bool_exp): [average_block_time_from_genesis!]!
  "fetch aggregated fields from the table: \"average_block_time_from_genesis\""
  average_block_time_from_genesis_aggregate("distinct select on columns" distinct_on: [average_block_time_from_genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_from_genesis_order_by!] "filter the rows returned" where: average_block_time_from_genesis_bool_exp): average_block_time_from_genesis_aggregate!
  "fetch data from the table: \"average_block_time_per_day\""
  average_block_time_per_day("distinct select on columns" distinct_on: [average_block_time_per_day_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_day_order_by!] "filter the rows returned" where: average_block_time_per_day_bool_exp): [average_block_time_per_day!]!
  "fetch aggregated fields from the table: \"average_block_time_per_day\""
  average_block_time_per_day_aggregate("distinct select on columns" distinct_on: [average_block_time_per_day_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_day_order_by!] "filter the rows returned" where: average_block_time_per_day_bool_exp): average_block_time_per_day_aggregate!
  "fetch data from the table: \"average_block_time_per_hour\""
  average_block_time_per_hour("distinct select on columns" distinct_on: [average_block_time_per_hour_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_hour_order_by!] "filter the rows returned" where: average_block_time_per_hour_bool_exp): [average_block_time_per_hour!]!
  "fetch aggregated fields from the table: \"average_block_time_per_hour\""
  average_block_time_per_hour_aggregate("distinct select on columns" distinct_on: [average_block_time_per_hour_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_hour_order_by!] "filter the rows returned" where: average_block_time_per_hour_bool_exp): average_block_time_per_hour_aggregate!
  "fetch data from the table: \"average_block_time_per_minute\""
  average_block_time_per_minute("distinct select on columns" distinct_on: [average_block_time_per_minute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_minute_order_by!] "filter the rows returned" where: average_block_time_per_minute_bool_exp): [average_block_time_per_minute!]!
  "fetch aggregated fields from the table: \"average_block_time_per_minute\""
  average_block_time_per_minute_aggregate("distinct select on columns" distinct_on: [average_block_time_per_minute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [average_block_time_per_minute_order_by!] "filter the rows returned" where: average_block_time_per_minute_bool_exp): average_block_time_per_minute_aggregate!
  "fetch data from the table: \"block\""
  block("distinct select on columns" distinct_on: [block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_order_by!] "filter the rows returned" where: block_bool_exp): [block!]!
  "fetch aggregated fields from the table: \"block\""
  block_aggregate("distinct select on columns" distinct_on: [block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_order_by!] "filter the rows returned" where: block_bool_exp): block_aggregate!
  "fetch data from the table: \"block\" using primary key columns"
  block_by_pk(height: bigint!): block
  "fetch data from the table: \"chain_link\""
  chain_link("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): [chain_link!]!
  "fetch aggregated fields from the table: \"chain_link\""
  chain_link_aggregate("distinct select on columns" distinct_on: [chain_link_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_order_by!] "filter the rows returned" where: chain_link_bool_exp): chain_link_aggregate!
  "fetch data from the table: \"chain_link\" using primary key columns"
  chain_link_by_pk(id: Int!): chain_link
  "fetch data from the table: \"chain_link_chain_config\""
  chain_link_chain_config("distinct select on columns" distinct_on: [chain_link_chain_config_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_chain_config_order_by!] "filter the rows returned" where: chain_link_chain_config_bool_exp): [chain_link_chain_config!]!
  "fetch aggregated fields from the table: \"chain_link_chain_config\""
  chain_link_chain_config_aggregate("distinct select on columns" distinct_on: [chain_link_chain_config_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_chain_config_order_by!] "filter the rows returned" where: chain_link_chain_config_bool_exp): chain_link_chain_config_aggregate!
  "fetch data from the table: \"chain_link_chain_config\" using primary key columns"
  chain_link_chain_config_by_pk(id: Int!): chain_link_chain_config
  "fetch data from the table: \"chain_link_proof\""
  chain_link_proof("distinct select on columns" distinct_on: [chain_link_proof_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_proof_order_by!] "filter the rows returned" where: chain_link_proof_bool_exp): [chain_link_proof!]!
  "fetch aggregated fields from the table: \"chain_link_proof\""
  chain_link_proof_aggregate("distinct select on columns" distinct_on: [chain_link_proof_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [chain_link_proof_order_by!] "filter the rows returned" where: chain_link_proof_bool_exp): chain_link_proof_aggregate!
  "fetch data from the table: \"community_pool\""
  community_pool("distinct select on columns" distinct_on: [community_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [community_pool_order_by!] "filter the rows returned" where: community_pool_bool_exp): [community_pool!]!
  "fetch aggregated fields from the table: \"community_pool\""
  community_pool_aggregate("distinct select on columns" distinct_on: [community_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [community_pool_order_by!] "filter the rows returned" where: community_pool_bool_exp): community_pool_aggregate!
  "fetch data from the table: \"delegation\""
  delegation("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): [delegation!]!
  "fetch aggregated fields from the table: \"delegation\""
  delegation_aggregate("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): delegation_aggregate!
  "fetch data from the table: \"delegation\" using primary key columns"
  delegation_by_pk(id: Int!): delegation
  "fetch data from the table: \"delegation_reward\""
  delegation_reward("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): [delegation_reward!]!
  "fetch aggregated fields from the table: \"delegation_reward\""
  delegation_reward_aggregate("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): delegation_reward_aggregate!
  "fetch data from the table: \"distribution_params\""
  distribution_params("distinct select on columns" distinct_on: [distribution_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [distribution_params_order_by!] "filter the rows returned" where: distribution_params_bool_exp): [distribution_params!]!
  "fetch aggregated fields from the table: \"distribution_params\""
  distribution_params_aggregate("distinct select on columns" distinct_on: [distribution_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [distribution_params_order_by!] "filter the rows returned" where: distribution_params_bool_exp): distribution_params_aggregate!
  "fetch data from the table: \"distribution_params\" using primary key columns"
  distribution_params_by_pk(one_row_id: Boolean!): distribution_params
  "fetch data from the table: \"double_sign_evidence\""
  double_sign_evidence("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): [double_sign_evidence!]!
  "fetch aggregated fields from the table: \"double_sign_evidence\""
  double_sign_evidence_aggregate("distinct select on columns" distinct_on: [double_sign_evidence_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_evidence_order_by!] "filter the rows returned" where: double_sign_evidence_bool_exp): double_sign_evidence_aggregate!
  "fetch data from the table: \"double_sign_vote\""
  double_sign_vote("distinct select on columns" distinct_on: [double_sign_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_vote_order_by!] "filter the rows returned" where: double_sign_vote_bool_exp): [double_sign_vote!]!
  "fetch aggregated fields from the table: \"double_sign_vote\""
  double_sign_vote_aggregate("distinct select on columns" distinct_on: [double_sign_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_vote_order_by!] "filter the rows returned" where: double_sign_vote_bool_exp): double_sign_vote_aggregate!
  "fetch data from the table: \"double_sign_vote\" using primary key columns"
  double_sign_vote_by_pk(id: Int!): double_sign_vote
  "An array relationship"
  dtag_transfer_requests("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): [dtag_transfer_requests!]!
  "An aggregate relationship"
  dtag_transfer_requests_aggregate("distinct select on columns" distinct_on: [dtag_transfer_requests_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [dtag_transfer_requests_order_by!] "filter the rows returned" where: dtag_transfer_requests_bool_exp): dtag_transfer_requests_aggregate!
  "fetch data from the table: \"fee_grant_allowance\""
  fee_grant_allowance("distinct select on columns" distinct_on: [fee_grant_allowance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fee_grant_allowance_order_by!] "filter the rows returned" where: fee_grant_allowance_bool_exp): [fee_grant_allowance!]!
  "fetch aggregated fields from the table: \"fee_grant_allowance\""
  fee_grant_allowance_aggregate("distinct select on columns" distinct_on: [fee_grant_allowance_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fee_grant_allowance_order_by!] "filter the rows returned" where: fee_grant_allowance_bool_exp): fee_grant_allowance_aggregate!
  "fetch data from the table: \"fee_grant_allowance\" using primary key columns"
  fee_grant_allowance_by_pk(id: Int!): fee_grant_allowance
  "fetch data from the table: \"genesis\""
  genesis("distinct select on columns" distinct_on: [genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [genesis_order_by!] "filter the rows returned" where: genesis_bool_exp): [genesis!]!
  "fetch aggregated fields from the table: \"genesis\""
  genesis_aggregate("distinct select on columns" distinct_on: [genesis_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [genesis_order_by!] "filter the rows returned" where: genesis_bool_exp): genesis_aggregate!
  "fetch data from the table: \"gov_params\""
  gov_params("distinct select on columns" distinct_on: [gov_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [gov_params_order_by!] "filter the rows returned" where: gov_params_bool_exp): [gov_params!]!
  "fetch aggregated fields from the table: \"gov_params\""
  gov_params_aggregate("distinct select on columns" distinct_on: [gov_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [gov_params_order_by!] "filter the rows returned" where: gov_params_bool_exp): gov_params_aggregate!
  "fetch data from the table: \"gov_params\" using primary key columns"
  gov_params_by_pk(one_row_id: Boolean!): gov_params
  "fetch data from the table: \"inflation\""
  inflation("distinct select on columns" distinct_on: [inflation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [inflation_order_by!] "filter the rows returned" where: inflation_bool_exp): [inflation!]!
  "fetch aggregated fields from the table: \"inflation\""
  inflation_aggregate("distinct select on columns" distinct_on: [inflation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [inflation_order_by!] "filter the rows returned" where: inflation_bool_exp): inflation_aggregate!
  "fetch data from the table: \"message\""
  message("distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): [message!]!
  "fetch aggregated fields from the table: \"message\""
  message_aggregate("distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): message_aggregate!
  "execute function \"messages_by_address\" which returns \"message\""
  messages_by_address("input parameters for function \"messages_by_address\"" args: messages_by_address_args! "distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): [message!]!
  "execute function \"messages_by_address\" and query aggregates on result of table type \"message\""
  messages_by_address_aggregate("input parameters for function \"messages_by_address\"" args: messages_by_address_args! "distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): message_aggregate!
  "fetch data from the table: \"mint_params\""
  mint_params("distinct select on columns" distinct_on: [mint_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [mint_params_order_by!] "filter the rows returned" where: mint_params_bool_exp): [mint_params!]!
  "fetch aggregated fields from the table: \"mint_params\""
  mint_params_aggregate("distinct select on columns" distinct_on: [mint_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [mint_params_order_by!] "filter the rows returned" where: mint_params_bool_exp): mint_params_aggregate!
  "fetch data from the table: \"mint_params\" using primary key columns"
  mint_params_by_pk(one_row_id: Boolean!): mint_params
  "fetch data from the table: \"modules\""
  modules("distinct select on columns" distinct_on: [modules_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [modules_order_by!] "filter the rows returned" where: modules_bool_exp): [modules!]!
  "fetch aggregated fields from the table: \"modules\""
  modules_aggregate("distinct select on columns" distinct_on: [modules_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [modules_order_by!] "filter the rows returned" where: modules_bool_exp): modules_aggregate!
  "fetch data from the table: \"modules\" using primary key columns"
  modules_by_pk(module_name: String!): modules
  "fetch data from the table: \"poll\""
  poll("distinct select on columns" distinct_on: [poll_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_order_by!] "filter the rows returned" where: poll_bool_exp): [poll!]!
  "fetch aggregated fields from the table: \"poll\""
  poll_aggregate("distinct select on columns" distinct_on: [poll_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_order_by!] "filter the rows returned" where: poll_bool_exp): poll_aggregate!
  "fetch data from the table: \"poll_answer\""
  poll_answer("distinct select on columns" distinct_on: [poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_answer_order_by!] "filter the rows returned" where: poll_answer_bool_exp): [poll_answer!]!
  "fetch aggregated fields from the table: \"poll_answer\""
  poll_answer_aggregate("distinct select on columns" distinct_on: [poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [poll_answer_order_by!] "filter the rows returned" where: poll_answer_bool_exp): poll_answer_aggregate!
  "fetch data from the table: \"poll\" using primary key columns"
  poll_by_pk(id: Int!): poll
  "fetch data from the table: \"post\""
  post("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): [post!]!
  "fetch aggregated fields from the table: \"post\""
  post_aggregate("distinct select on columns" distinct_on: [post_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_order_by!] "filter the rows returned" where: post_bool_exp): post_aggregate!
  "fetch data from the table: \"post_attachment\""
  post_attachment("distinct select on columns" distinct_on: [post_attachment_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_order_by!] "filter the rows returned" where: post_attachment_bool_exp): [post_attachment!]!
  "fetch aggregated fields from the table: \"post_attachment\""
  post_attachment_aggregate("distinct select on columns" distinct_on: [post_attachment_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_order_by!] "filter the rows returned" where: post_attachment_bool_exp): post_attachment_aggregate!
  "fetch data from the table: \"post_attachment\" using primary key columns"
  post_attachment_by_pk(id: Int!): post_attachment
  "fetch data from the table: \"post_attachment_tag\""
  post_attachment_tag("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): [post_attachment_tag!]!
  "fetch aggregated fields from the table: \"post_attachment_tag\""
  post_attachment_tag_aggregate("distinct select on columns" distinct_on: [post_attachment_tag_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attachment_tag_order_by!] "filter the rows returned" where: post_attachment_tag_bool_exp): post_attachment_tag_aggregate!
  "fetch data from the table: \"post_attribute\""
  post_attribute("distinct select on columns" distinct_on: [post_attribute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attribute_order_by!] "filter the rows returned" where: post_attribute_bool_exp): [post_attribute!]!
  "fetch aggregated fields from the table: \"post_attribute\""
  post_attribute_aggregate("distinct select on columns" distinct_on: [post_attribute_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_attribute_order_by!] "filter the rows returned" where: post_attribute_bool_exp): post_attribute_aggregate!
  "fetch data from the table: \"post\" using primary key columns"
  post_by_pk(id: String!): post
  "fetch data from the table: \"post_reaction\""
  post_reaction("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): [post_reaction!]!
  "fetch aggregated fields from the table: \"post_reaction\""
  post_reaction_aggregate("distinct select on columns" distinct_on: [post_reaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_reaction_order_by!] "filter the rows returned" where: post_reaction_bool_exp): post_reaction_aggregate!
  "fetch data from the table: \"post_report\""
  post_report("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): [post_report!]!
  "fetch aggregated fields from the table: \"post_report\""
  post_report_aggregate("distinct select on columns" distinct_on: [post_report_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [post_report_order_by!] "filter the rows returned" where: post_report_bool_exp): post_report_aggregate!
  "fetch data from the table: \"pre_commit\""
  pre_commit("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): [pre_commit!]!
  "fetch aggregated fields from the table: \"pre_commit\""
  pre_commit_aggregate("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): pre_commit_aggregate!
  "fetch data from the table: \"profile\""
  profile("distinct select on columns" distinct_on: [profile_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_order_by!] "filter the rows returned" where: profile_bool_exp): [profile!]!
  "fetch aggregated fields from the table: \"profile\""
  profile_aggregate("distinct select on columns" distinct_on: [profile_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_order_by!] "filter the rows returned" where: profile_bool_exp): profile_aggregate!
  "fetch data from the table: \"profile\" using primary key columns"
  profile_by_pk(address: String!): profile
  "fetch data from the table: \"profile_relationship\""
  profile_relationship("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): [profile_relationship!]!
  "fetch aggregated fields from the table: \"profile_relationship\""
  profile_relationship_aggregate("distinct select on columns" distinct_on: [profile_relationship_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profile_relationship_order_by!] "filter the rows returned" where: profile_relationship_bool_exp): profile_relationship_aggregate!
  "fetch data from the table: \"profiles_params\""
  profiles_params("distinct select on columns" distinct_on: [profiles_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [profiles_params_order_by!] "filter the rows returned" where: profiles_params_bool_exp): [profiles_params!]!
  "fetch data from the table: \"proposal\""
  proposal("distinct select on columns" distinct_on: [proposal_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_order_by!] "filter the rows returned" where: proposal_bool_exp): [proposal!]!
  "fetch aggregated fields from the table: \"proposal\""
  proposal_aggregate("distinct select on columns" distinct_on: [proposal_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_order_by!] "filter the rows returned" where: proposal_bool_exp): proposal_aggregate!
  "fetch data from the table: \"proposal\" using primary key columns"
  proposal_by_pk(id: Int!): proposal
  "fetch data from the table: \"proposal_deposit\""
  proposal_deposit("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): [proposal_deposit!]!
  "fetch aggregated fields from the table: \"proposal_deposit\""
  proposal_deposit_aggregate("distinct select on columns" distinct_on: [proposal_deposit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_deposit_order_by!] "filter the rows returned" where: proposal_deposit_bool_exp): proposal_deposit_aggregate!
  "fetch data from the table: \"proposal_staking_pool_snapshot\""
  proposal_staking_pool_snapshot("distinct select on columns" distinct_on: [proposal_staking_pool_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_staking_pool_snapshot_order_by!] "filter the rows returned" where: proposal_staking_pool_snapshot_bool_exp): [proposal_staking_pool_snapshot!]!
  "fetch aggregated fields from the table: \"proposal_staking_pool_snapshot\""
  proposal_staking_pool_snapshot_aggregate("distinct select on columns" distinct_on: [proposal_staking_pool_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_staking_pool_snapshot_order_by!] "filter the rows returned" where: proposal_staking_pool_snapshot_bool_exp): proposal_staking_pool_snapshot_aggregate!
  "fetch data from the table: \"proposal_staking_pool_snapshot\" using primary key columns"
  proposal_staking_pool_snapshot_by_pk(proposal_id: Int!): proposal_staking_pool_snapshot
  "fetch data from the table: \"proposal_tally_result\""
  proposal_tally_result("distinct select on columns" distinct_on: [proposal_tally_result_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_tally_result_order_by!] "filter the rows returned" where: proposal_tally_result_bool_exp): [proposal_tally_result!]!
  "fetch aggregated fields from the table: \"proposal_tally_result\""
  proposal_tally_result_aggregate("distinct select on columns" distinct_on: [proposal_tally_result_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_tally_result_order_by!] "filter the rows returned" where: proposal_tally_result_bool_exp): proposal_tally_result_aggregate!
  "fetch data from the table: \"proposal_tally_result\" using primary key columns"
  proposal_tally_result_by_pk(proposal_id: Int!): proposal_tally_result
  "fetch data from the table: \"proposal_validator_status_snapshot\""
  proposal_validator_status_snapshot("distinct select on columns" distinct_on: [proposal_validator_status_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_validator_status_snapshot_order_by!] "filter the rows returned" where: proposal_validator_status_snapshot_bool_exp): [proposal_validator_status_snapshot!]!
  "fetch aggregated fields from the table: \"proposal_validator_status_snapshot\""
  proposal_validator_status_snapshot_aggregate("distinct select on columns" distinct_on: [proposal_validator_status_snapshot_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_validator_status_snapshot_order_by!] "filter the rows returned" where: proposal_validator_status_snapshot_bool_exp): proposal_validator_status_snapshot_aggregate!
  "fetch data from the table: \"proposal_validator_status_snapshot\" using primary key columns"
  proposal_validator_status_snapshot_by_pk(id: Int!): proposal_validator_status_snapshot
  "fetch data from the table: \"proposal_vote\""
  proposal_vote("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): [proposal_vote!]!
  "fetch aggregated fields from the table: \"proposal_vote\""
  proposal_vote_aggregate("distinct select on columns" distinct_on: [proposal_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_vote_order_by!] "filter the rows returned" where: proposal_vote_bool_exp): proposal_vote_aggregate!
  "fetch data from the table: \"redelegation\""
  redelegation("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): [redelegation!]!
  "fetch aggregated fields from the table: \"redelegation\""
  redelegation_aggregate("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): redelegation_aggregate!
  "An array relationship"
  registered_reactions("distinct select on columns" distinct_on: [registered_reactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [registered_reactions_order_by!] "filter the rows returned" where: registered_reactions_bool_exp): [registered_reactions!]!
  "An aggregate relationship"
  registered_reactions_aggregate("distinct select on columns" distinct_on: [registered_reactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [registered_reactions_order_by!] "filter the rows returned" where: registered_reactions_bool_exp): registered_reactions_aggregate!
  "fetch data from the table: \"slashing_params\""
  slashing_params("distinct select on columns" distinct_on: [slashing_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [slashing_params_order_by!] "filter the rows returned" where: slashing_params_bool_exp): [slashing_params!]!
  "fetch aggregated fields from the table: \"slashing_params\""
  slashing_params_aggregate("distinct select on columns" distinct_on: [slashing_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [slashing_params_order_by!] "filter the rows returned" where: slashing_params_bool_exp): slashing_params_aggregate!
  "fetch data from the table: \"slashing_params\" using primary key columns"
  slashing_params_by_pk(one_row_id: Boolean!): slashing_params
  "fetch data from the table: \"staking_params\""
  staking_params("distinct select on columns" distinct_on: [staking_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_params_order_by!] "filter the rows returned" where: staking_params_bool_exp): [staking_params!]!
  "fetch aggregated fields from the table: \"staking_params\""
  staking_params_aggregate("distinct select on columns" distinct_on: [staking_params_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_params_order_by!] "filter the rows returned" where: staking_params_bool_exp): staking_params_aggregate!
  "fetch data from the table: \"staking_params\" using primary key columns"
  staking_params_by_pk(one_row_id: Boolean!): staking_params
  "fetch data from the table: \"staking_pool\""
  staking_pool("distinct select on columns" distinct_on: [staking_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_pool_order_by!] "filter the rows returned" where: staking_pool_bool_exp): [staking_pool!]!
  "fetch aggregated fields from the table: \"staking_pool\""
  staking_pool_aggregate("distinct select on columns" distinct_on: [staking_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [staking_pool_order_by!] "filter the rows returned" where: staking_pool_bool_exp): staking_pool_aggregate!
  "fetch data from the table: \"supply\""
  supply("distinct select on columns" distinct_on: [supply_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [supply_order_by!] "filter the rows returned" where: supply_bool_exp): [supply!]!
  "fetch aggregated fields from the table: \"supply\""
  supply_aggregate("distinct select on columns" distinct_on: [supply_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [supply_order_by!] "filter the rows returned" where: supply_bool_exp): supply_aggregate!
  "fetch data from the table: \"token\""
  token("distinct select on columns" distinct_on: [token_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_order_by!] "filter the rows returned" where: token_bool_exp): [token!]!
  "fetch aggregated fields from the table: \"token\""
  token_aggregate("distinct select on columns" distinct_on: [token_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_order_by!] "filter the rows returned" where: token_bool_exp): token_aggregate!
  "fetch data from the table: \"token_price\""
  token_price("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): [token_price!]!
  "fetch aggregated fields from the table: \"token_price\""
  token_price_aggregate("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): token_price_aggregate!
  "fetch data from the table: \"token_price\" using primary key columns"
  token_price_by_pk(id: Int!): token_price
  "fetch data from the table: \"token_price_history\""
  token_price_history("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): [token_price_history!]!
  "fetch aggregated fields from the table: \"token_price_history\""
  token_price_history_aggregate("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): token_price_history_aggregate!
  "fetch data from the table: \"token_unit\""
  token_unit("distinct select on columns" distinct_on: [token_unit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_unit_order_by!] "filter the rows returned" where: token_unit_bool_exp): [token_unit!]!
  "fetch aggregated fields from the table: \"token_unit\""
  token_unit_aggregate("distinct select on columns" distinct_on: [token_unit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_unit_order_by!] "filter the rows returned" where: token_unit_bool_exp): token_unit_aggregate!
  "fetch data from the table: \"transaction\""
  transaction("distinct select on columns" distinct_on: [transaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [transaction_order_by!] "filter the rows returned" where: transaction_bool_exp): [transaction!]!
  "fetch aggregated fields from the table: \"transaction\""
  transaction_aggregate("distinct select on columns" distinct_on: [transaction_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [transaction_order_by!] "filter the rows returned" where: transaction_bool_exp): transaction_aggregate!
  "fetch data from the table: \"transaction\" using primary key columns"
  transaction_by_pk(hash: String!): transaction
  "fetch data from the table: \"unbonding_delegation\""
  unbonding_delegation("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): [unbonding_delegation!]!
  "fetch aggregated fields from the table: \"unbonding_delegation\""
  unbonding_delegation_aggregate("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): unbonding_delegation_aggregate!
  "fetch data from the table: \"user_block\""
  user_block("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): [user_block!]!
  "fetch aggregated fields from the table: \"user_block\""
  user_block_aggregate("distinct select on columns" distinct_on: [user_block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_block_order_by!] "filter the rows returned" where: user_block_bool_exp): user_block_aggregate!
  "fetch data from the table: \"user_poll_answer\""
  user_poll_answer("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): [user_poll_answer!]!
  "fetch aggregated fields from the table: \"user_poll_answer\""
  user_poll_answer_aggregate("distinct select on columns" distinct_on: [user_poll_answer_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_poll_answer_order_by!] "filter the rows returned" where: user_poll_answer_bool_exp): user_poll_answer_aggregate!
  "fetch data from the table: \"validator\""
  validator("distinct select on columns" distinct_on: [validator_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_order_by!] "filter the rows returned" where: validator_bool_exp): [validator!]!
  "fetch aggregated fields from the table: \"validator\""
  validator_aggregate("distinct select on columns" distinct_on: [validator_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_order_by!] "filter the rows returned" where: validator_bool_exp): validator_aggregate!
  "fetch data from the table: \"validator\" using primary key columns"
  validator_by_pk(consensus_address: String!): validator
  "fetch data from the table: \"validator_commission\""
  validator_commission("distinct select on columns" distinct_on: [validator_commission_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_order_by!] "filter the rows returned" where: validator_commission_bool_exp): [validator_commission!]!
  "fetch aggregated fields from the table: \"validator_commission\""
  validator_commission_aggregate("distinct select on columns" distinct_on: [validator_commission_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_order_by!] "filter the rows returned" where: validator_commission_bool_exp): validator_commission_aggregate!
  "fetch data from the table: \"validator_commission_amount\""
  validator_commission_amount("distinct select on columns" distinct_on: [validator_commission_amount_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_amount_order_by!] "filter the rows returned" where: validator_commission_amount_bool_exp): [validator_commission_amount!]!
  "fetch aggregated fields from the table: \"validator_commission_amount\""
  validator_commission_amount_aggregate("distinct select on columns" distinct_on: [validator_commission_amount_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_amount_order_by!] "filter the rows returned" where: validator_commission_amount_bool_exp): validator_commission_amount_aggregate!
  "fetch data from the table: \"validator_commission_amount\" using primary key columns"
  validator_commission_amount_by_pk(validator_address: String!): validator_commission_amount
  "fetch data from the table: \"validator_commission\" using primary key columns"
  validator_commission_by_pk(validator_address: String!): validator_commission
  "fetch data from the table: \"validator_description\""
  validator_description("distinct select on columns" distinct_on: [validator_description_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_description_order_by!] "filter the rows returned" where: validator_description_bool_exp): [validator_description!]!
  "fetch aggregated fields from the table: \"validator_description\""
  validator_description_aggregate("distinct select on columns" distinct_on: [validator_description_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_description_order_by!] "filter the rows returned" where: validator_description_bool_exp): validator_description_aggregate!
  "fetch data from the table: \"validator_description\" using primary key columns"
  validator_description_by_pk(validator_address: String!): validator_description
  "fetch data from the table: \"validator_info\""
  validator_info("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): [validator_info!]!
  "fetch aggregated fields from the table: \"validator_info\""
  validator_info_aggregate("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): validator_info_aggregate!
  "fetch data from the table: \"validator_info\" using primary key columns"
  validator_info_by_pk(consensus_address: String!): validator_info
  "fetch data from the table: \"validator_signing_info\""
  validator_signing_info("distinct select on columns" distinct_on: [validator_signing_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_signing_info_order_by!] "filter the rows returned" where: validator_signing_info_bool_exp): [validator_signing_info!]!
  "fetch aggregated fields from the table: \"validator_signing_info\""
  validator_signing_info_aggregate("distinct select on columns" distinct_on: [validator_signing_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_signing_info_order_by!] "filter the rows returned" where: validator_signing_info_bool_exp): validator_signing_info_aggregate!
  "fetch data from the table: \"validator_signing_info\" using primary key columns"
  validator_signing_info_by_pk(validator_address: String!): validator_signing_info
  "fetch data from the table: \"validator_status\""
  validator_status("distinct select on columns" distinct_on: [validator_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_status_order_by!] "filter the rows returned" where: validator_status_bool_exp): [validator_status!]!
  "fetch aggregated fields from the table: \"validator_status\""
  validator_status_aggregate("distinct select on columns" distinct_on: [validator_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_status_order_by!] "filter the rows returned" where: validator_status_bool_exp): validator_status_aggregate!
  "fetch data from the table: \"validator_status\" using primary key columns"
  validator_status_by_pk(validator_address: String!): validator_status
  "fetch data from the table: \"validator_voting_power\""
  validator_voting_power("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): [validator_voting_power!]!
  "fetch aggregated fields from the table: \"validator_voting_power\""
  validator_voting_power_aggregate("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): validator_voting_power_aggregate!
  "fetch data from the table: \"validator_voting_power\" using primary key columns"
  validator_voting_power_by_pk(validator_address: String!): validator_voting_power
  "fetch data from the table: \"vesting_account\""
  vesting_account("distinct select on columns" distinct_on: [vesting_account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_account_order_by!] "filter the rows returned" where: vesting_account_bool_exp): [vesting_account!]!
  "fetch aggregated fields from the table: \"vesting_account\""
  vesting_account_aggregate("distinct select on columns" distinct_on: [vesting_account_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_account_order_by!] "filter the rows returned" where: vesting_account_bool_exp): vesting_account_aggregate!
  "fetch data from the table: \"vesting_account\" using primary key columns"
  vesting_account_by_pk(id: Int!): vesting_account
  "fetch data from the table: \"vesting_period\""
  vesting_period("distinct select on columns" distinct_on: [vesting_period_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_period_order_by!] "filter the rows returned" where: vesting_period_bool_exp): [vesting_period!]!
  "fetch aggregated fields from the table: \"vesting_period\""
  vesting_period_aggregate("distinct select on columns" distinct_on: [vesting_period_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_period_order_by!] "filter the rows returned" where: vesting_period_bool_exp): vesting_period_aggregate!
}

"columns and relationships of \"supply\""
type supply {
  coins: _coin!
  height: bigint!
}

"aggregated selection of \"supply\""
type supply_aggregate {
  aggregate: supply_aggregate_fields
  nodes: [supply!]!
}

"aggregate fields of \"supply\""
type supply_aggregate_fields {
  avg: supply_avg_fields
  count(columns: [supply_select_column!] distinct: Boolean): Int!
  max: supply_max_fields
  min: supply_min_fields
  stddev: supply_stddev_fields
  stddev_pop: supply_stddev_pop_fields
  stddev_samp: supply_stddev_samp_fields
  sum: supply_sum_fields
  var_pop: supply_var_pop_fields
  var_samp: supply_var_samp_fields
  variance: supply_variance_fields
}

"aggregate avg on columns"
type supply_avg_fields {
  height: Float
}

"Boolean expression to filter rows from the table \"supply\". All fields are combined with a logical 'AND'."
input supply_bool_exp {
  _and: [supply_bool_exp!]
  _not: supply_bool_exp
  _or: [supply_bool_exp!]
  coins: _coin_comparison_exp
  height: bigint_comparison_exp
}

"aggregate max on columns"
type supply_max_fields {
  height: bigint
}

"aggregate min on columns"
type supply_min_fields {
  height: bigint
}

"Ordering options when selecting data from \"supply\"."
input supply_order_by {
  coins: order_by
  height: order_by
}

"select columns of table \"supply\""
enum supply_select_column {
  "column name"
  coins
  "column name"
  height
}

"aggregate stddev on columns"
type supply_stddev_fields {
  height: Float
}

"aggregate stddev_pop on columns"
type supply_stddev_pop_fields {
  height: Float
}

"aggregate stddev_samp on columns"
type supply_stddev_samp_fields {
  height: Float
}

"aggregate sum on columns"
type supply_sum_fields {
  height: bigint
}

"aggregate var_pop on columns"
type supply_var_pop_fields {
  height: Float
}

"aggregate var_samp on columns"
type supply_var_samp_fields {
  height: Float
}

"aggregate variance on columns"
type supply_variance_fields {
  height: Float
}

scalar timestamp

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"columns and relationships of \"token\""
type token {
  name: String!
  "An array relationship"
  token_units("distinct select on columns" distinct_on: [token_unit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_unit_order_by!] "filter the rows returned" where: token_unit_bool_exp): [token_unit!]!
  "An aggregate relationship"
  token_units_aggregate("distinct select on columns" distinct_on: [token_unit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_unit_order_by!] "filter the rows returned" where: token_unit_bool_exp): token_unit_aggregate!
}

"aggregated selection of \"token\""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

"aggregate fields of \"token\""
type token_aggregate_fields {
  count(columns: [token_select_column!] distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
}

"Boolean expression to filter rows from the table \"token\". All fields are combined with a logical 'AND'."
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  name: String_comparison_exp
  token_units: token_unit_bool_exp
}

"aggregate max on columns"
type token_max_fields {
  name: String
}

"aggregate min on columns"
type token_min_fields {
  name: String
}

"Ordering options when selecting data from \"token\"."
input token_order_by {
  name: order_by
  token_units_aggregate: token_unit_aggregate_order_by
}

"columns and relationships of \"token_price\""
type token_price {
  id: Int!
  market_cap: bigint!
  price: numeric!
  timestamp: timestamp!
  "An object relationship"
  token_unit: token_unit!
  unit_name: String!
}

"aggregated selection of \"token_price\""
type token_price_aggregate {
  aggregate: token_price_aggregate_fields
  nodes: [token_price!]!
}

"aggregate fields of \"token_price\""
type token_price_aggregate_fields {
  avg: token_price_avg_fields
  count(columns: [token_price_select_column!] distinct: Boolean): Int!
  max: token_price_max_fields
  min: token_price_min_fields
  stddev: token_price_stddev_fields
  stddev_pop: token_price_stddev_pop_fields
  stddev_samp: token_price_stddev_samp_fields
  sum: token_price_sum_fields
  var_pop: token_price_var_pop_fields
  var_samp: token_price_var_samp_fields
  variance: token_price_variance_fields
}

"order by aggregate values of table \"token_price\""
input token_price_aggregate_order_by {
  avg: token_price_avg_order_by
  count: order_by
  max: token_price_max_order_by
  min: token_price_min_order_by
  stddev: token_price_stddev_order_by
  stddev_pop: token_price_stddev_pop_order_by
  stddev_samp: token_price_stddev_samp_order_by
  sum: token_price_sum_order_by
  var_pop: token_price_var_pop_order_by
  var_samp: token_price_var_samp_order_by
  variance: token_price_variance_order_by
}

"aggregate avg on columns"
type token_price_avg_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by avg() on columns of table \"token_price\""
input token_price_avg_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"Boolean expression to filter rows from the table \"token_price\". All fields are combined with a logical 'AND'."
input token_price_bool_exp {
  _and: [token_price_bool_exp!]
  _not: token_price_bool_exp
  _or: [token_price_bool_exp!]
  id: Int_comparison_exp
  market_cap: bigint_comparison_exp
  price: numeric_comparison_exp
  timestamp: timestamp_comparison_exp
  token_unit: token_unit_bool_exp
  unit_name: String_comparison_exp
}

"columns and relationships of \"token_price_history\""
type token_price_history {
  market_cap: bigint!
  price: numeric!
  timestamp: timestamp!
  "An object relationship"
  token_unit: token_unit!
  unit_name: String!
}

"aggregated selection of \"token_price_history\""
type token_price_history_aggregate {
  aggregate: token_price_history_aggregate_fields
  nodes: [token_price_history!]!
}

"aggregate fields of \"token_price_history\""
type token_price_history_aggregate_fields {
  avg: token_price_history_avg_fields
  count(columns: [token_price_history_select_column!] distinct: Boolean): Int!
  max: token_price_history_max_fields
  min: token_price_history_min_fields
  stddev: token_price_history_stddev_fields
  stddev_pop: token_price_history_stddev_pop_fields
  stddev_samp: token_price_history_stddev_samp_fields
  sum: token_price_history_sum_fields
  var_pop: token_price_history_var_pop_fields
  var_samp: token_price_history_var_samp_fields
  variance: token_price_history_variance_fields
}

"order by aggregate values of table \"token_price_history\""
input token_price_history_aggregate_order_by {
  avg: token_price_history_avg_order_by
  count: order_by
  max: token_price_history_max_order_by
  min: token_price_history_min_order_by
  stddev: token_price_history_stddev_order_by
  stddev_pop: token_price_history_stddev_pop_order_by
  stddev_samp: token_price_history_stddev_samp_order_by
  sum: token_price_history_sum_order_by
  var_pop: token_price_history_var_pop_order_by
  var_samp: token_price_history_var_samp_order_by
  variance: token_price_history_variance_order_by
}

"aggregate avg on columns"
type token_price_history_avg_fields {
  market_cap: Float
  price: Float
}

"order by avg() on columns of table \"token_price_history\""
input token_price_history_avg_order_by {
  market_cap: order_by
  price: order_by
}

"Boolean expression to filter rows from the table \"token_price_history\". All fields are combined with a logical 'AND'."
input token_price_history_bool_exp {
  _and: [token_price_history_bool_exp!]
  _not: token_price_history_bool_exp
  _or: [token_price_history_bool_exp!]
  market_cap: bigint_comparison_exp
  price: numeric_comparison_exp
  timestamp: timestamp_comparison_exp
  token_unit: token_unit_bool_exp
  unit_name: String_comparison_exp
}

"aggregate max on columns"
type token_price_history_max_fields {
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"order by max() on columns of table \"token_price_history\""
input token_price_history_max_order_by {
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"aggregate min on columns"
type token_price_history_min_fields {
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"order by min() on columns of table \"token_price_history\""
input token_price_history_min_order_by {
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"Ordering options when selecting data from \"token_price_history\"."
input token_price_history_order_by {
  market_cap: order_by
  price: order_by
  timestamp: order_by
  token_unit: token_unit_order_by
  unit_name: order_by
}

"select columns of table \"token_price_history\""
enum token_price_history_select_column {
  "column name"
  market_cap
  "column name"
  price
  "column name"
  timestamp
  "column name"
  unit_name
}

"aggregate stddev on columns"
type token_price_history_stddev_fields {
  market_cap: Float
  price: Float
}

"order by stddev() on columns of table \"token_price_history\""
input token_price_history_stddev_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate stddev_pop on columns"
type token_price_history_stddev_pop_fields {
  market_cap: Float
  price: Float
}

"order by stddev_pop() on columns of table \"token_price_history\""
input token_price_history_stddev_pop_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate stddev_samp on columns"
type token_price_history_stddev_samp_fields {
  market_cap: Float
  price: Float
}

"order by stddev_samp() on columns of table \"token_price_history\""
input token_price_history_stddev_samp_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate sum on columns"
type token_price_history_sum_fields {
  market_cap: bigint
  price: numeric
}

"order by sum() on columns of table \"token_price_history\""
input token_price_history_sum_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate var_pop on columns"
type token_price_history_var_pop_fields {
  market_cap: Float
  price: Float
}

"order by var_pop() on columns of table \"token_price_history\""
input token_price_history_var_pop_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate var_samp on columns"
type token_price_history_var_samp_fields {
  market_cap: Float
  price: Float
}

"order by var_samp() on columns of table \"token_price_history\""
input token_price_history_var_samp_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate variance on columns"
type token_price_history_variance_fields {
  market_cap: Float
  price: Float
}

"order by variance() on columns of table \"token_price_history\""
input token_price_history_variance_order_by {
  market_cap: order_by
  price: order_by
}

"aggregate max on columns"
type token_price_max_fields {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"order by max() on columns of table \"token_price\""
input token_price_max_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"aggregate min on columns"
type token_price_min_fields {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"order by min() on columns of table \"token_price\""
input token_price_min_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"Ordering options when selecting data from \"token_price\"."
input token_price_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  token_unit: token_unit_order_by
  unit_name: order_by
}

"select columns of table \"token_price\""
enum token_price_select_column {
  "column name"
  id
  "column name"
  market_cap
  "column name"
  price
  "column name"
  timestamp
  "column name"
  unit_name
}

"aggregate stddev on columns"
type token_price_stddev_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by stddev() on columns of table \"token_price\""
input token_price_stddev_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"aggregate stddev_pop on columns"
type token_price_stddev_pop_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by stddev_pop() on columns of table \"token_price\""
input token_price_stddev_pop_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"aggregate stddev_samp on columns"
type token_price_stddev_samp_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by stddev_samp() on columns of table \"token_price\""
input token_price_stddev_samp_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"aggregate sum on columns"
type token_price_sum_fields {
  id: Int
  market_cap: bigint
  price: numeric
}

"order by sum() on columns of table \"token_price\""
input token_price_sum_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"aggregate var_pop on columns"
type token_price_var_pop_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by var_pop() on columns of table \"token_price\""
input token_price_var_pop_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"aggregate var_samp on columns"
type token_price_var_samp_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by var_samp() on columns of table \"token_price\""
input token_price_var_samp_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"aggregate variance on columns"
type token_price_variance_fields {
  id: Float
  market_cap: Float
  price: Float
}

"order by variance() on columns of table \"token_price\""
input token_price_variance_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"select columns of table \"token\""
enum token_select_column {
  "column name"
  name
}

"columns and relationships of \"token_unit\""
type token_unit {
  aliases: _text
  denom: String!
  exponent: Int!
  price_id: String
  "An object relationship"
  token: token!
  token_name: String!
  "An object relationship"
  token_price: token_price
  "An array relationship"
  token_price_histories("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): [token_price_history!]!
  "An aggregate relationship"
  token_price_histories_aggregate("distinct select on columns" distinct_on: [token_price_history_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_history_order_by!] "filter the rows returned" where: token_price_history_bool_exp): token_price_history_aggregate!
  "An array relationship"
  token_prices("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): [token_price!]!
  "An aggregate relationship"
  token_prices_aggregate("distinct select on columns" distinct_on: [token_price_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_price_order_by!] "filter the rows returned" where: token_price_bool_exp): token_price_aggregate!
}

"aggregated selection of \"token_unit\""
type token_unit_aggregate {
  aggregate: token_unit_aggregate_fields
  nodes: [token_unit!]!
}

"aggregate fields of \"token_unit\""
type token_unit_aggregate_fields {
  avg: token_unit_avg_fields
  count(columns: [token_unit_select_column!] distinct: Boolean): Int!
  max: token_unit_max_fields
  min: token_unit_min_fields
  stddev: token_unit_stddev_fields
  stddev_pop: token_unit_stddev_pop_fields
  stddev_samp: token_unit_stddev_samp_fields
  sum: token_unit_sum_fields
  var_pop: token_unit_var_pop_fields
  var_samp: token_unit_var_samp_fields
  variance: token_unit_variance_fields
}

"order by aggregate values of table \"token_unit\""
input token_unit_aggregate_order_by {
  avg: token_unit_avg_order_by
  count: order_by
  max: token_unit_max_order_by
  min: token_unit_min_order_by
  stddev: token_unit_stddev_order_by
  stddev_pop: token_unit_stddev_pop_order_by
  stddev_samp: token_unit_stddev_samp_order_by
  sum: token_unit_sum_order_by
  var_pop: token_unit_var_pop_order_by
  var_samp: token_unit_var_samp_order_by
  variance: token_unit_variance_order_by
}

"aggregate avg on columns"
type token_unit_avg_fields {
  exponent: Float
}

"order by avg() on columns of table \"token_unit\""
input token_unit_avg_order_by {
  exponent: order_by
}

"Boolean expression to filter rows from the table \"token_unit\". All fields are combined with a logical 'AND'."
input token_unit_bool_exp {
  _and: [token_unit_bool_exp!]
  _not: token_unit_bool_exp
  _or: [token_unit_bool_exp!]
  aliases: _text_comparison_exp
  denom: String_comparison_exp
  exponent: Int_comparison_exp
  price_id: String_comparison_exp
  token: token_bool_exp
  token_name: String_comparison_exp
  token_price: token_price_bool_exp
  token_price_histories: token_price_history_bool_exp
  token_prices: token_price_bool_exp
}

"aggregate max on columns"
type token_unit_max_fields {
  denom: String
  exponent: Int
  price_id: String
  token_name: String
}

"order by max() on columns of table \"token_unit\""
input token_unit_max_order_by {
  denom: order_by
  exponent: order_by
  price_id: order_by
  token_name: order_by
}

"aggregate min on columns"
type token_unit_min_fields {
  denom: String
  exponent: Int
  price_id: String
  token_name: String
}

"order by min() on columns of table \"token_unit\""
input token_unit_min_order_by {
  denom: order_by
  exponent: order_by
  price_id: order_by
  token_name: order_by
}

"Ordering options when selecting data from \"token_unit\"."
input token_unit_order_by {
  aliases: order_by
  denom: order_by
  exponent: order_by
  price_id: order_by
  token: token_order_by
  token_name: order_by
  token_price: token_price_order_by
  token_price_histories_aggregate: token_price_history_aggregate_order_by
  token_prices_aggregate: token_price_aggregate_order_by
}

"select columns of table \"token_unit\""
enum token_unit_select_column {
  "column name"
  aliases
  "column name"
  denom
  "column name"
  exponent
  "column name"
  price_id
  "column name"
  token_name
}

"aggregate stddev on columns"
type token_unit_stddev_fields {
  exponent: Float
}

"order by stddev() on columns of table \"token_unit\""
input token_unit_stddev_order_by {
  exponent: order_by
}

"aggregate stddev_pop on columns"
type token_unit_stddev_pop_fields {
  exponent: Float
}

"order by stddev_pop() on columns of table \"token_unit\""
input token_unit_stddev_pop_order_by {
  exponent: order_by
}

"aggregate stddev_samp on columns"
type token_unit_stddev_samp_fields {
  exponent: Float
}

"order by stddev_samp() on columns of table \"token_unit\""
input token_unit_stddev_samp_order_by {
  exponent: order_by
}

"aggregate sum on columns"
type token_unit_sum_fields {
  exponent: Int
}

"order by sum() on columns of table \"token_unit\""
input token_unit_sum_order_by {
  exponent: order_by
}

"aggregate var_pop on columns"
type token_unit_var_pop_fields {
  exponent: Float
}

"order by var_pop() on columns of table \"token_unit\""
input token_unit_var_pop_order_by {
  exponent: order_by
}

"aggregate var_samp on columns"
type token_unit_var_samp_fields {
  exponent: Float
}

"order by var_samp() on columns of table \"token_unit\""
input token_unit_var_samp_order_by {
  exponent: order_by
}

"aggregate variance on columns"
type token_unit_variance_fields {
  exponent: Float
}

"order by variance() on columns of table \"token_unit\""
input token_unit_variance_order_by {
  exponent: order_by
}

"columns and relationships of \"transaction\""
type transaction {
  "An object relationship"
  block: block!
  fee("JSON select path" path: String): jsonb!
  gas_used: bigint
  gas_wanted: bigint
  hash: String!
  height: bigint!
  logs("JSON select path" path: String): jsonb
  memo: String
  messages("JSON select path" path: String): jsonb!
  "An array relationship"
  messagesByTransactionHash("distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): [message!]!
  "An aggregate relationship"
  messagesByTransactionHash_aggregate("distinct select on columns" distinct_on: [message_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [message_order_by!] "filter the rows returned" where: message_bool_exp): message_aggregate!
  raw_log: String
  signatures: _text!
  signer_infos("JSON select path" path: String): jsonb!
  success: Boolean!
}

"aggregated selection of \"transaction\""
type transaction_aggregate {
  aggregate: transaction_aggregate_fields
  nodes: [transaction!]!
}

"aggregate fields of \"transaction\""
type transaction_aggregate_fields {
  avg: transaction_avg_fields
  count(columns: [transaction_select_column!] distinct: Boolean): Int!
  max: transaction_max_fields
  min: transaction_min_fields
  stddev: transaction_stddev_fields
  stddev_pop: transaction_stddev_pop_fields
  stddev_samp: transaction_stddev_samp_fields
  sum: transaction_sum_fields
  var_pop: transaction_var_pop_fields
  var_samp: transaction_var_samp_fields
  variance: transaction_variance_fields
}

"order by aggregate values of table \"transaction\""
input transaction_aggregate_order_by {
  avg: transaction_avg_order_by
  count: order_by
  max: transaction_max_order_by
  min: transaction_min_order_by
  stddev: transaction_stddev_order_by
  stddev_pop: transaction_stddev_pop_order_by
  stddev_samp: transaction_stddev_samp_order_by
  sum: transaction_sum_order_by
  var_pop: transaction_var_pop_order_by
  var_samp: transaction_var_samp_order_by
  variance: transaction_variance_order_by
}

"aggregate avg on columns"
type transaction_avg_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by avg() on columns of table \"transaction\""
input transaction_avg_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"Boolean expression to filter rows from the table \"transaction\". All fields are combined with a logical 'AND'."
input transaction_bool_exp {
  _and: [transaction_bool_exp!]
  _not: transaction_bool_exp
  _or: [transaction_bool_exp!]
  block: block_bool_exp
  fee: jsonb_comparison_exp
  gas_used: bigint_comparison_exp
  gas_wanted: bigint_comparison_exp
  hash: String_comparison_exp
  height: bigint_comparison_exp
  logs: jsonb_comparison_exp
  memo: String_comparison_exp
  messages: jsonb_comparison_exp
  messagesByTransactionHash: message_bool_exp
  raw_log: String_comparison_exp
  signatures: _text_comparison_exp
  signer_infos: jsonb_comparison_exp
  success: Boolean_comparison_exp
}

"aggregate max on columns"
type transaction_max_fields {
  gas_used: bigint
  gas_wanted: bigint
  hash: String
  height: bigint
  memo: String
  raw_log: String
}

"order by max() on columns of table \"transaction\""
input transaction_max_order_by {
  gas_used: order_by
  gas_wanted: order_by
  hash: order_by
  height: order_by
  memo: order_by
  raw_log: order_by
}

"aggregate min on columns"
type transaction_min_fields {
  gas_used: bigint
  gas_wanted: bigint
  hash: String
  height: bigint
  memo: String
  raw_log: String
}

"order by min() on columns of table \"transaction\""
input transaction_min_order_by {
  gas_used: order_by
  gas_wanted: order_by
  hash: order_by
  height: order_by
  memo: order_by
  raw_log: order_by
}

"Ordering options when selecting data from \"transaction\"."
input transaction_order_by {
  block: block_order_by
  fee: order_by
  gas_used: order_by
  gas_wanted: order_by
  hash: order_by
  height: order_by
  logs: order_by
  memo: order_by
  messages: order_by
  messagesByTransactionHash_aggregate: message_aggregate_order_by
  raw_log: order_by
  signatures: order_by
  signer_infos: order_by
  success: order_by
}

"select columns of table \"transaction\""
enum transaction_select_column {
  "column name"
  fee
  "column name"
  gas_used
  "column name"
  gas_wanted
  "column name"
  hash
  "column name"
  height
  "column name"
  logs
  "column name"
  memo
  "column name"
  messages
  "column name"
  raw_log
  "column name"
  signatures
  "column name"
  signer_infos
  "column name"
  success
}

"aggregate stddev on columns"
type transaction_stddev_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by stddev() on columns of table \"transaction\""
input transaction_stddev_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"aggregate stddev_pop on columns"
type transaction_stddev_pop_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by stddev_pop() on columns of table \"transaction\""
input transaction_stddev_pop_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"aggregate stddev_samp on columns"
type transaction_stddev_samp_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by stddev_samp() on columns of table \"transaction\""
input transaction_stddev_samp_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"aggregate sum on columns"
type transaction_sum_fields {
  gas_used: bigint
  gas_wanted: bigint
  height: bigint
}

"order by sum() on columns of table \"transaction\""
input transaction_sum_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"aggregate var_pop on columns"
type transaction_var_pop_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by var_pop() on columns of table \"transaction\""
input transaction_var_pop_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"aggregate var_samp on columns"
type transaction_var_samp_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by var_samp() on columns of table \"transaction\""
input transaction_var_samp_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"aggregate variance on columns"
type transaction_variance_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
}

"order by variance() on columns of table \"transaction\""
input transaction_variance_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
}

"columns and relationships of \"unbonding_delegation\""
type unbonding_delegation {
  "An object relationship"
  account: account!
  amount: coin!
  completion_timestamp: timestamp!
  delegator_address: String!
  height: bigint!
  "An object relationship"
  validator: validator!
  validator_address: String!
}

"aggregated selection of \"unbonding_delegation\""
type unbonding_delegation_aggregate {
  aggregate: unbonding_delegation_aggregate_fields
  nodes: [unbonding_delegation!]!
}

"aggregate fields of \"unbonding_delegation\""
type unbonding_delegation_aggregate_fields {
  avg: unbonding_delegation_avg_fields
  count(columns: [unbonding_delegation_select_column!] distinct: Boolean): Int!
  max: unbonding_delegation_max_fields
  min: unbonding_delegation_min_fields
  stddev: unbonding_delegation_stddev_fields
  stddev_pop: unbonding_delegation_stddev_pop_fields
  stddev_samp: unbonding_delegation_stddev_samp_fields
  sum: unbonding_delegation_sum_fields
  var_pop: unbonding_delegation_var_pop_fields
  var_samp: unbonding_delegation_var_samp_fields
  variance: unbonding_delegation_variance_fields
}

"order by aggregate values of table \"unbonding_delegation\""
input unbonding_delegation_aggregate_order_by {
  avg: unbonding_delegation_avg_order_by
  count: order_by
  max: unbonding_delegation_max_order_by
  min: unbonding_delegation_min_order_by
  stddev: unbonding_delegation_stddev_order_by
  stddev_pop: unbonding_delegation_stddev_pop_order_by
  stddev_samp: unbonding_delegation_stddev_samp_order_by
  sum: unbonding_delegation_sum_order_by
  var_pop: unbonding_delegation_var_pop_order_by
  var_samp: unbonding_delegation_var_samp_order_by
  variance: unbonding_delegation_variance_order_by
}

"aggregate avg on columns"
type unbonding_delegation_avg_fields {
  height: Float
}

"order by avg() on columns of table \"unbonding_delegation\""
input unbonding_delegation_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"unbonding_delegation\". All fields are combined with a logical 'AND'."
input unbonding_delegation_bool_exp {
  _and: [unbonding_delegation_bool_exp!]
  _not: unbonding_delegation_bool_exp
  _or: [unbonding_delegation_bool_exp!]
  account: account_bool_exp
  amount: coin_comparison_exp
  completion_timestamp: timestamp_comparison_exp
  delegator_address: String_comparison_exp
  height: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"aggregate max on columns"
type unbonding_delegation_max_fields {
  completion_timestamp: timestamp
  delegator_address: String
  height: bigint
  validator_address: String
}

"order by max() on columns of table \"unbonding_delegation\""
input unbonding_delegation_max_order_by {
  completion_timestamp: order_by
  delegator_address: order_by
  height: order_by
  validator_address: order_by
}

"aggregate min on columns"
type unbonding_delegation_min_fields {
  completion_timestamp: timestamp
  delegator_address: String
  height: bigint
  validator_address: String
}

"order by min() on columns of table \"unbonding_delegation\""
input unbonding_delegation_min_order_by {
  completion_timestamp: order_by
  delegator_address: order_by
  height: order_by
  validator_address: order_by
}

"Ordering options when selecting data from \"unbonding_delegation\"."
input unbonding_delegation_order_by {
  account: account_order_by
  amount: order_by
  completion_timestamp: order_by
  delegator_address: order_by
  height: order_by
  validator: validator_order_by
  validator_address: order_by
}

"select columns of table \"unbonding_delegation\""
enum unbonding_delegation_select_column {
  "column name"
  amount
  "column name"
  completion_timestamp
  "column name"
  delegator_address
  "column name"
  height
  "column name"
  validator_address
}

"aggregate stddev on columns"
type unbonding_delegation_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"unbonding_delegation\""
input unbonding_delegation_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type unbonding_delegation_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"unbonding_delegation\""
input unbonding_delegation_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type unbonding_delegation_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"unbonding_delegation\""
input unbonding_delegation_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type unbonding_delegation_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"unbonding_delegation\""
input unbonding_delegation_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type unbonding_delegation_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"unbonding_delegation\""
input unbonding_delegation_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type unbonding_delegation_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"unbonding_delegation\""
input unbonding_delegation_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type unbonding_delegation_variance_fields {
  height: Float
}

"order by variance() on columns of table \"unbonding_delegation\""
input unbonding_delegation_variance_order_by {
  height: order_by
}

"columns and relationships of \"user_block\""
type user_block {
  blocked_user_address: String!
  blocker_address: String!
  height: bigint!
  "An object relationship"
  profile: profile!
  "An object relationship"
  profileByBlockerAddress: profile!
  reason: String
  subspace: String!
}

"aggregated selection of \"user_block\""
type user_block_aggregate {
  aggregate: user_block_aggregate_fields
  nodes: [user_block!]!
}

"aggregate fields of \"user_block\""
type user_block_aggregate_fields {
  avg: user_block_avg_fields
  count(columns: [user_block_select_column!] distinct: Boolean): Int!
  max: user_block_max_fields
  min: user_block_min_fields
  stddev: user_block_stddev_fields
  stddev_pop: user_block_stddev_pop_fields
  stddev_samp: user_block_stddev_samp_fields
  sum: user_block_sum_fields
  var_pop: user_block_var_pop_fields
  var_samp: user_block_var_samp_fields
  variance: user_block_variance_fields
}

"order by aggregate values of table \"user_block\""
input user_block_aggregate_order_by {
  avg: user_block_avg_order_by
  count: order_by
  max: user_block_max_order_by
  min: user_block_min_order_by
  stddev: user_block_stddev_order_by
  stddev_pop: user_block_stddev_pop_order_by
  stddev_samp: user_block_stddev_samp_order_by
  sum: user_block_sum_order_by
  var_pop: user_block_var_pop_order_by
  var_samp: user_block_var_samp_order_by
  variance: user_block_variance_order_by
}

"aggregate avg on columns"
type user_block_avg_fields {
  height: Float
}

"order by avg() on columns of table \"user_block\""
input user_block_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"user_block\". All fields are combined with a logical 'AND'."
input user_block_bool_exp {
  _and: [user_block_bool_exp!]
  _not: user_block_bool_exp
  _or: [user_block_bool_exp!]
  blocked_user_address: String_comparison_exp
  blocker_address: String_comparison_exp
  height: bigint_comparison_exp
  profile: profile_bool_exp
  profileByBlockerAddress: profile_bool_exp
  reason: String_comparison_exp
  subspace: String_comparison_exp
}

"aggregate max on columns"
type user_block_max_fields {
  blocked_user_address: String
  blocker_address: String
  height: bigint
  reason: String
  subspace: String
}

"order by max() on columns of table \"user_block\""
input user_block_max_order_by {
  blocked_user_address: order_by
  blocker_address: order_by
  height: order_by
  reason: order_by
  subspace: order_by
}

"aggregate min on columns"
type user_block_min_fields {
  blocked_user_address: String
  blocker_address: String
  height: bigint
  reason: String
  subspace: String
}

"order by min() on columns of table \"user_block\""
input user_block_min_order_by {
  blocked_user_address: order_by
  blocker_address: order_by
  height: order_by
  reason: order_by
  subspace: order_by
}

"Ordering options when selecting data from \"user_block\"."
input user_block_order_by {
  blocked_user_address: order_by
  blocker_address: order_by
  height: order_by
  profile: profile_order_by
  profileByBlockerAddress: profile_order_by
  reason: order_by
  subspace: order_by
}

"select columns of table \"user_block\""
enum user_block_select_column {
  "column name"
  blocked_user_address
  "column name"
  blocker_address
  "column name"
  height
  "column name"
  reason
  "column name"
  subspace
}

"aggregate stddev on columns"
type user_block_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"user_block\""
input user_block_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type user_block_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"user_block\""
input user_block_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type user_block_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"user_block\""
input user_block_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type user_block_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"user_block\""
input user_block_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type user_block_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"user_block\""
input user_block_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type user_block_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"user_block\""
input user_block_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type user_block_variance_fields {
  height: Float
}

"order by variance() on columns of table \"user_block\""
input user_block_variance_order_by {
  height: order_by
}

"columns and relationships of \"user_poll_answer\""
type user_poll_answer {
  answer: Int!
  answerer_address: String!
  height: bigint!
  "An object relationship"
  poll: poll!
  poll_id: Int!
  "An object relationship"
  profile: profile!
}

"aggregated selection of \"user_poll_answer\""
type user_poll_answer_aggregate {
  aggregate: user_poll_answer_aggregate_fields
  nodes: [user_poll_answer!]!
}

"aggregate fields of \"user_poll_answer\""
type user_poll_answer_aggregate_fields {
  avg: user_poll_answer_avg_fields
  count(columns: [user_poll_answer_select_column!] distinct: Boolean): Int!
  max: user_poll_answer_max_fields
  min: user_poll_answer_min_fields
  stddev: user_poll_answer_stddev_fields
  stddev_pop: user_poll_answer_stddev_pop_fields
  stddev_samp: user_poll_answer_stddev_samp_fields
  sum: user_poll_answer_sum_fields
  var_pop: user_poll_answer_var_pop_fields
  var_samp: user_poll_answer_var_samp_fields
  variance: user_poll_answer_variance_fields
}

"order by aggregate values of table \"user_poll_answer\""
input user_poll_answer_aggregate_order_by {
  avg: user_poll_answer_avg_order_by
  count: order_by
  max: user_poll_answer_max_order_by
  min: user_poll_answer_min_order_by
  stddev: user_poll_answer_stddev_order_by
  stddev_pop: user_poll_answer_stddev_pop_order_by
  stddev_samp: user_poll_answer_stddev_samp_order_by
  sum: user_poll_answer_sum_order_by
  var_pop: user_poll_answer_var_pop_order_by
  var_samp: user_poll_answer_var_samp_order_by
  variance: user_poll_answer_variance_order_by
}

"aggregate avg on columns"
type user_poll_answer_avg_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by avg() on columns of table \"user_poll_answer\""
input user_poll_answer_avg_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"Boolean expression to filter rows from the table \"user_poll_answer\". All fields are combined with a logical 'AND'."
input user_poll_answer_bool_exp {
  _and: [user_poll_answer_bool_exp!]
  _not: user_poll_answer_bool_exp
  _or: [user_poll_answer_bool_exp!]
  answer: Int_comparison_exp
  answerer_address: String_comparison_exp
  height: bigint_comparison_exp
  poll: poll_bool_exp
  poll_id: Int_comparison_exp
  profile: profile_bool_exp
}

"aggregate max on columns"
type user_poll_answer_max_fields {
  answer: Int
  answerer_address: String
  height: bigint
  poll_id: Int
}

"order by max() on columns of table \"user_poll_answer\""
input user_poll_answer_max_order_by {
  answer: order_by
  answerer_address: order_by
  height: order_by
  poll_id: order_by
}

"aggregate min on columns"
type user_poll_answer_min_fields {
  answer: Int
  answerer_address: String
  height: bigint
  poll_id: Int
}

"order by min() on columns of table \"user_poll_answer\""
input user_poll_answer_min_order_by {
  answer: order_by
  answerer_address: order_by
  height: order_by
  poll_id: order_by
}

"Ordering options when selecting data from \"user_poll_answer\"."
input user_poll_answer_order_by {
  answer: order_by
  answerer_address: order_by
  height: order_by
  poll: poll_order_by
  poll_id: order_by
  profile: profile_order_by
}

"select columns of table \"user_poll_answer\""
enum user_poll_answer_select_column {
  "column name"
  answer
  "column name"
  answerer_address
  "column name"
  height
  "column name"
  poll_id
}

"aggregate stddev on columns"
type user_poll_answer_stddev_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by stddev() on columns of table \"user_poll_answer\""
input user_poll_answer_stddev_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"aggregate stddev_pop on columns"
type user_poll_answer_stddev_pop_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by stddev_pop() on columns of table \"user_poll_answer\""
input user_poll_answer_stddev_pop_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"aggregate stddev_samp on columns"
type user_poll_answer_stddev_samp_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by stddev_samp() on columns of table \"user_poll_answer\""
input user_poll_answer_stddev_samp_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"aggregate sum on columns"
type user_poll_answer_sum_fields {
  answer: Int
  height: bigint
  poll_id: Int
}

"order by sum() on columns of table \"user_poll_answer\""
input user_poll_answer_sum_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"aggregate var_pop on columns"
type user_poll_answer_var_pop_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by var_pop() on columns of table \"user_poll_answer\""
input user_poll_answer_var_pop_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"aggregate var_samp on columns"
type user_poll_answer_var_samp_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by var_samp() on columns of table \"user_poll_answer\""
input user_poll_answer_var_samp_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"aggregate variance on columns"
type user_poll_answer_variance_fields {
  answer: Float
  height: Float
  poll_id: Float
}

"order by variance() on columns of table \"user_poll_answer\""
input user_poll_answer_variance_order_by {
  answer: order_by
  height: order_by
  poll_id: order_by
}

"columns and relationships of \"validator\""
type validator {
  "An array relationship"
  blocks("distinct select on columns" distinct_on: [block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_order_by!] "filter the rows returned" where: block_bool_exp): [block!]!
  "An aggregate relationship"
  blocks_aggregate("distinct select on columns" distinct_on: [block_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_order_by!] "filter the rows returned" where: block_bool_exp): block_aggregate!
  consensus_address: String!
  consensus_pubkey: String!
  "An array relationship"
  delegation_rewards("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): [delegation_reward!]!
  "An aggregate relationship"
  delegation_rewards_aggregate("distinct select on columns" distinct_on: [delegation_reward_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_reward_order_by!] "filter the rows returned" where: delegation_reward_bool_exp): delegation_reward_aggregate!
  "An array relationship"
  delegations("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): [delegation!]!
  "An aggregate relationship"
  delegations_aggregate("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): delegation_aggregate!
  "An array relationship"
  double_sign_votes("distinct select on columns" distinct_on: [double_sign_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_vote_order_by!] "filter the rows returned" where: double_sign_vote_bool_exp): [double_sign_vote!]!
  "An aggregate relationship"
  double_sign_votes_aggregate("distinct select on columns" distinct_on: [double_sign_vote_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [double_sign_vote_order_by!] "filter the rows returned" where: double_sign_vote_bool_exp): double_sign_vote_aggregate!
  "An array relationship"
  pre_commits("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): [pre_commit!]!
  "An aggregate relationship"
  pre_commits_aggregate("distinct select on columns" distinct_on: [pre_commit_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [pre_commit_order_by!] "filter the rows returned" where: pre_commit_bool_exp): pre_commit_aggregate!
  "An array relationship"
  redelegationsByDstValidatorAddress("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): [redelegation!]!
  "An aggregate relationship"
  redelegationsByDstValidatorAddress_aggregate("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): redelegation_aggregate!
  "An array relationship"
  redelegationsBySrcValidatorAddress("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): [redelegation!]!
  "An aggregate relationship"
  redelegationsBySrcValidatorAddress_aggregate("distinct select on columns" distinct_on: [redelegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [redelegation_order_by!] "filter the rows returned" where: redelegation_bool_exp): redelegation_aggregate!
  "A computed field, executes function \"self_delegations\""
  self_delegations("distinct select on columns" distinct_on: [delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegation_order_by!] "filter the rows returned" where: delegation_bool_exp): [delegation!]
  "An array relationship"
  unbonding_delegations("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): [unbonding_delegation!]!
  "An aggregate relationship"
  unbonding_delegations_aggregate("distinct select on columns" distinct_on: [unbonding_delegation_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [unbonding_delegation_order_by!] "filter the rows returned" where: unbonding_delegation_bool_exp): unbonding_delegation_aggregate!
  "An array relationship"
  validator_commission_amounts("distinct select on columns" distinct_on: [validator_commission_amount_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_amount_order_by!] "filter the rows returned" where: validator_commission_amount_bool_exp): [validator_commission_amount!]!
  "An aggregate relationship"
  validator_commission_amounts_aggregate("distinct select on columns" distinct_on: [validator_commission_amount_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_amount_order_by!] "filter the rows returned" where: validator_commission_amount_bool_exp): validator_commission_amount_aggregate!
  "An array relationship"
  validator_commissions("distinct select on columns" distinct_on: [validator_commission_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_order_by!] "filter the rows returned" where: validator_commission_bool_exp): [validator_commission!]!
  "An aggregate relationship"
  validator_commissions_aggregate("distinct select on columns" distinct_on: [validator_commission_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_commission_order_by!] "filter the rows returned" where: validator_commission_bool_exp): validator_commission_aggregate!
  "An array relationship"
  validator_descriptions("distinct select on columns" distinct_on: [validator_description_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_description_order_by!] "filter the rows returned" where: validator_description_bool_exp): [validator_description!]!
  "An aggregate relationship"
  validator_descriptions_aggregate("distinct select on columns" distinct_on: [validator_description_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_description_order_by!] "filter the rows returned" where: validator_description_bool_exp): validator_description_aggregate!
  "An object relationship"
  validator_info: validator_info
  "An array relationship"
  validator_infos("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): [validator_info!]!
  "An aggregate relationship"
  validator_infos_aggregate("distinct select on columns" distinct_on: [validator_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_info_order_by!] "filter the rows returned" where: validator_info_bool_exp): validator_info_aggregate!
  "An array relationship"
  validator_signing_infos("distinct select on columns" distinct_on: [validator_signing_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_signing_info_order_by!] "filter the rows returned" where: validator_signing_info_bool_exp): [validator_signing_info!]!
  "An aggregate relationship"
  validator_signing_infos_aggregate("distinct select on columns" distinct_on: [validator_signing_info_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_signing_info_order_by!] "filter the rows returned" where: validator_signing_info_bool_exp): validator_signing_info_aggregate!
  "An array relationship"
  validator_statuses("distinct select on columns" distinct_on: [validator_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_status_order_by!] "filter the rows returned" where: validator_status_bool_exp): [validator_status!]!
  "An aggregate relationship"
  validator_statuses_aggregate("distinct select on columns" distinct_on: [validator_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_status_order_by!] "filter the rows returned" where: validator_status_bool_exp): validator_status_aggregate!
  "An array relationship"
  validator_voting_powers("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): [validator_voting_power!]!
  "An aggregate relationship"
  validator_voting_powers_aggregate("distinct select on columns" distinct_on: [validator_voting_power_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [validator_voting_power_order_by!] "filter the rows returned" where: validator_voting_power_bool_exp): validator_voting_power_aggregate!
}

"aggregated selection of \"validator\""
type validator_aggregate {
  aggregate: validator_aggregate_fields
  nodes: [validator!]!
}

"aggregate fields of \"validator\""
type validator_aggregate_fields {
  count(columns: [validator_select_column!] distinct: Boolean): Int!
  max: validator_max_fields
  min: validator_min_fields
}

"Boolean expression to filter rows from the table \"validator\". All fields are combined with a logical 'AND'."
input validator_bool_exp {
  _and: [validator_bool_exp!]
  _not: validator_bool_exp
  _or: [validator_bool_exp!]
  blocks: block_bool_exp
  consensus_address: String_comparison_exp
  consensus_pubkey: String_comparison_exp
  delegation_rewards: delegation_reward_bool_exp
  delegations: delegation_bool_exp
  double_sign_votes: double_sign_vote_bool_exp
  pre_commits: pre_commit_bool_exp
  redelegationsByDstValidatorAddress: redelegation_bool_exp
  redelegationsBySrcValidatorAddress: redelegation_bool_exp
  self_delegations: delegation_bool_exp
  unbonding_delegations: unbonding_delegation_bool_exp
  validator_commission_amounts: validator_commission_amount_bool_exp
  validator_commissions: validator_commission_bool_exp
  validator_descriptions: validator_description_bool_exp
  validator_info: validator_info_bool_exp
  validator_infos: validator_info_bool_exp
  validator_signing_infos: validator_signing_info_bool_exp
  validator_statuses: validator_status_bool_exp
  validator_voting_powers: validator_voting_power_bool_exp
}

"columns and relationships of \"validator_commission\""
type validator_commission {
  commission: numeric!
  height: bigint!
  min_self_delegation: bigint!
  "An object relationship"
  validator: validator!
  validator_address: String!
}

"aggregated selection of \"validator_commission\""
type validator_commission_aggregate {
  aggregate: validator_commission_aggregate_fields
  nodes: [validator_commission!]!
}

"aggregate fields of \"validator_commission\""
type validator_commission_aggregate_fields {
  avg: validator_commission_avg_fields
  count(columns: [validator_commission_select_column!] distinct: Boolean): Int!
  max: validator_commission_max_fields
  min: validator_commission_min_fields
  stddev: validator_commission_stddev_fields
  stddev_pop: validator_commission_stddev_pop_fields
  stddev_samp: validator_commission_stddev_samp_fields
  sum: validator_commission_sum_fields
  var_pop: validator_commission_var_pop_fields
  var_samp: validator_commission_var_samp_fields
  variance: validator_commission_variance_fields
}

"order by aggregate values of table \"validator_commission\""
input validator_commission_aggregate_order_by {
  avg: validator_commission_avg_order_by
  count: order_by
  max: validator_commission_max_order_by
  min: validator_commission_min_order_by
  stddev: validator_commission_stddev_order_by
  stddev_pop: validator_commission_stddev_pop_order_by
  stddev_samp: validator_commission_stddev_samp_order_by
  sum: validator_commission_sum_order_by
  var_pop: validator_commission_var_pop_order_by
  var_samp: validator_commission_var_samp_order_by
  variance: validator_commission_variance_order_by
}

"columns and relationships of \"validator_commission_amount\""
type validator_commission_amount {
  amount: _dec_coin!
  height: bigint!
  "An object relationship"
  validator: validator!
  validator_address: String!
}

"aggregated selection of \"validator_commission_amount\""
type validator_commission_amount_aggregate {
  aggregate: validator_commission_amount_aggregate_fields
  nodes: [validator_commission_amount!]!
}

"aggregate fields of \"validator_commission_amount\""
type validator_commission_amount_aggregate_fields {
  avg: validator_commission_amount_avg_fields
  count(columns: [validator_commission_amount_select_column!] distinct: Boolean): Int!
  max: validator_commission_amount_max_fields
  min: validator_commission_amount_min_fields
  stddev: validator_commission_amount_stddev_fields
  stddev_pop: validator_commission_amount_stddev_pop_fields
  stddev_samp: validator_commission_amount_stddev_samp_fields
  sum: validator_commission_amount_sum_fields
  var_pop: validator_commission_amount_var_pop_fields
  var_samp: validator_commission_amount_var_samp_fields
  variance: validator_commission_amount_variance_fields
}

"order by aggregate values of table \"validator_commission_amount\""
input validator_commission_amount_aggregate_order_by {
  avg: validator_commission_amount_avg_order_by
  count: order_by
  max: validator_commission_amount_max_order_by
  min: validator_commission_amount_min_order_by
  stddev: validator_commission_amount_stddev_order_by
  stddev_pop: validator_commission_amount_stddev_pop_order_by
  stddev_samp: validator_commission_amount_stddev_samp_order_by
  sum: validator_commission_amount_sum_order_by
  var_pop: validator_commission_amount_var_pop_order_by
  var_samp: validator_commission_amount_var_samp_order_by
  variance: validator_commission_amount_variance_order_by
}

"aggregate avg on columns"
type validator_commission_amount_avg_fields {
  height: Float
}

"order by avg() on columns of table \"validator_commission_amount\""
input validator_commission_amount_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"validator_commission_amount\". All fields are combined with a logical 'AND'."
input validator_commission_amount_bool_exp {
  _and: [validator_commission_amount_bool_exp!]
  _not: validator_commission_amount_bool_exp
  _or: [validator_commission_amount_bool_exp!]
  amount: _dec_coin_comparison_exp
  height: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"aggregate max on columns"
type validator_commission_amount_max_fields {
  height: bigint
  validator_address: String
}

"order by max() on columns of table \"validator_commission_amount\""
input validator_commission_amount_max_order_by {
  height: order_by
  validator_address: order_by
}

"aggregate min on columns"
type validator_commission_amount_min_fields {
  height: bigint
  validator_address: String
}

"order by min() on columns of table \"validator_commission_amount\""
input validator_commission_amount_min_order_by {
  height: order_by
  validator_address: order_by
}

"Ordering options when selecting data from \"validator_commission_amount\"."
input validator_commission_amount_order_by {
  amount: order_by
  height: order_by
  validator: validator_order_by
  validator_address: order_by
}

"select columns of table \"validator_commission_amount\""
enum validator_commission_amount_select_column {
  "column name"
  amount
  "column name"
  height
  "column name"
  validator_address
}

"aggregate stddev on columns"
type validator_commission_amount_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"validator_commission_amount\""
input validator_commission_amount_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type validator_commission_amount_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"validator_commission_amount\""
input validator_commission_amount_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type validator_commission_amount_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"validator_commission_amount\""
input validator_commission_amount_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type validator_commission_amount_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"validator_commission_amount\""
input validator_commission_amount_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type validator_commission_amount_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"validator_commission_amount\""
input validator_commission_amount_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type validator_commission_amount_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"validator_commission_amount\""
input validator_commission_amount_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type validator_commission_amount_variance_fields {
  height: Float
}

"order by variance() on columns of table \"validator_commission_amount\""
input validator_commission_amount_variance_order_by {
  height: order_by
}

"aggregate avg on columns"
type validator_commission_avg_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by avg() on columns of table \"validator_commission\""
input validator_commission_avg_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"Boolean expression to filter rows from the table \"validator_commission\". All fields are combined with a logical 'AND'."
input validator_commission_bool_exp {
  _and: [validator_commission_bool_exp!]
  _not: validator_commission_bool_exp
  _or: [validator_commission_bool_exp!]
  commission: numeric_comparison_exp
  height: bigint_comparison_exp
  min_self_delegation: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"aggregate max on columns"
type validator_commission_max_fields {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
  validator_address: String
}

"order by max() on columns of table \"validator_commission\""
input validator_commission_max_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
  validator_address: order_by
}

"aggregate min on columns"
type validator_commission_min_fields {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
  validator_address: String
}

"order by min() on columns of table \"validator_commission\""
input validator_commission_min_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
  validator_address: order_by
}

"Ordering options when selecting data from \"validator_commission\"."
input validator_commission_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
  validator: validator_order_by
  validator_address: order_by
}

"select columns of table \"validator_commission\""
enum validator_commission_select_column {
  "column name"
  commission
  "column name"
  height
  "column name"
  min_self_delegation
  "column name"
  validator_address
}

"aggregate stddev on columns"
type validator_commission_stddev_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by stddev() on columns of table \"validator_commission\""
input validator_commission_stddev_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"aggregate stddev_pop on columns"
type validator_commission_stddev_pop_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by stddev_pop() on columns of table \"validator_commission\""
input validator_commission_stddev_pop_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"aggregate stddev_samp on columns"
type validator_commission_stddev_samp_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by stddev_samp() on columns of table \"validator_commission\""
input validator_commission_stddev_samp_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"aggregate sum on columns"
type validator_commission_sum_fields {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
}

"order by sum() on columns of table \"validator_commission\""
input validator_commission_sum_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"aggregate var_pop on columns"
type validator_commission_var_pop_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by var_pop() on columns of table \"validator_commission\""
input validator_commission_var_pop_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"aggregate var_samp on columns"
type validator_commission_var_samp_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by var_samp() on columns of table \"validator_commission\""
input validator_commission_var_samp_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"aggregate variance on columns"
type validator_commission_variance_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"order by variance() on columns of table \"validator_commission\""
input validator_commission_variance_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"columns and relationships of \"validator_description\""
type validator_description {
  avatar_url: String
  details: String
  height: bigint!
  identity: String
  moniker: String
  security_contact: String
  "An object relationship"
  validator: validator!
  validator_address: String!
  website: String
}

"aggregated selection of \"validator_description\""
type validator_description_aggregate {
  aggregate: validator_description_aggregate_fields
  nodes: [validator_description!]!
}

"aggregate fields of \"validator_description\""
type validator_description_aggregate_fields {
  avg: validator_description_avg_fields
  count(columns: [validator_description_select_column!] distinct: Boolean): Int!
  max: validator_description_max_fields
  min: validator_description_min_fields
  stddev: validator_description_stddev_fields
  stddev_pop: validator_description_stddev_pop_fields
  stddev_samp: validator_description_stddev_samp_fields
  sum: validator_description_sum_fields
  var_pop: validator_description_var_pop_fields
  var_samp: validator_description_var_samp_fields
  variance: validator_description_variance_fields
}

"order by aggregate values of table \"validator_description\""
input validator_description_aggregate_order_by {
  avg: validator_description_avg_order_by
  count: order_by
  max: validator_description_max_order_by
  min: validator_description_min_order_by
  stddev: validator_description_stddev_order_by
  stddev_pop: validator_description_stddev_pop_order_by
  stddev_samp: validator_description_stddev_samp_order_by
  sum: validator_description_sum_order_by
  var_pop: validator_description_var_pop_order_by
  var_samp: validator_description_var_samp_order_by
  variance: validator_description_variance_order_by
}

"aggregate avg on columns"
type validator_description_avg_fields {
  height: Float
}

"order by avg() on columns of table \"validator_description\""
input validator_description_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"validator_description\". All fields are combined with a logical 'AND'."
input validator_description_bool_exp {
  _and: [validator_description_bool_exp!]
  _not: validator_description_bool_exp
  _or: [validator_description_bool_exp!]
  avatar_url: String_comparison_exp
  details: String_comparison_exp
  height: bigint_comparison_exp
  identity: String_comparison_exp
  moniker: String_comparison_exp
  security_contact: String_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  website: String_comparison_exp
}

"aggregate max on columns"
type validator_description_max_fields {
  avatar_url: String
  details: String
  height: bigint
  identity: String
  moniker: String
  security_contact: String
  validator_address: String
  website: String
}

"order by max() on columns of table \"validator_description\""
input validator_description_max_order_by {
  avatar_url: order_by
  details: order_by
  height: order_by
  identity: order_by
  moniker: order_by
  security_contact: order_by
  validator_address: order_by
  website: order_by
}

"aggregate min on columns"
type validator_description_min_fields {
  avatar_url: String
  details: String
  height: bigint
  identity: String
  moniker: String
  security_contact: String
  validator_address: String
  website: String
}

"order by min() on columns of table \"validator_description\""
input validator_description_min_order_by {
  avatar_url: order_by
  details: order_by
  height: order_by
  identity: order_by
  moniker: order_by
  security_contact: order_by
  validator_address: order_by
  website: order_by
}

"Ordering options when selecting data from \"validator_description\"."
input validator_description_order_by {
  avatar_url: order_by
  details: order_by
  height: order_by
  identity: order_by
  moniker: order_by
  security_contact: order_by
  validator: validator_order_by
  validator_address: order_by
  website: order_by
}

"select columns of table \"validator_description\""
enum validator_description_select_column {
  "column name"
  avatar_url
  "column name"
  details
  "column name"
  height
  "column name"
  identity
  "column name"
  moniker
  "column name"
  security_contact
  "column name"
  validator_address
  "column name"
  website
}

"aggregate stddev on columns"
type validator_description_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"validator_description\""
input validator_description_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type validator_description_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"validator_description\""
input validator_description_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type validator_description_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"validator_description\""
input validator_description_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type validator_description_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"validator_description\""
input validator_description_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type validator_description_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"validator_description\""
input validator_description_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type validator_description_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"validator_description\""
input validator_description_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type validator_description_variance_fields {
  height: Float
}

"order by variance() on columns of table \"validator_description\""
input validator_description_variance_order_by {
  height: order_by
}

"columns and relationships of \"validator_info\""
type validator_info {
  "An object relationship"
  account: account
  consensus_address: String!
  height: bigint!
  max_change_rate: String!
  max_rate: String!
  operator_address: String!
  self_delegate_address: String
  "An object relationship"
  validator: validator!
}

"aggregated selection of \"validator_info\""
type validator_info_aggregate {
  aggregate: validator_info_aggregate_fields
  nodes: [validator_info!]!
}

"aggregate fields of \"validator_info\""
type validator_info_aggregate_fields {
  avg: validator_info_avg_fields
  count(columns: [validator_info_select_column!] distinct: Boolean): Int!
  max: validator_info_max_fields
  min: validator_info_min_fields
  stddev: validator_info_stddev_fields
  stddev_pop: validator_info_stddev_pop_fields
  stddev_samp: validator_info_stddev_samp_fields
  sum: validator_info_sum_fields
  var_pop: validator_info_var_pop_fields
  var_samp: validator_info_var_samp_fields
  variance: validator_info_variance_fields
}

"order by aggregate values of table \"validator_info\""
input validator_info_aggregate_order_by {
  avg: validator_info_avg_order_by
  count: order_by
  max: validator_info_max_order_by
  min: validator_info_min_order_by
  stddev: validator_info_stddev_order_by
  stddev_pop: validator_info_stddev_pop_order_by
  stddev_samp: validator_info_stddev_samp_order_by
  sum: validator_info_sum_order_by
  var_pop: validator_info_var_pop_order_by
  var_samp: validator_info_var_samp_order_by
  variance: validator_info_variance_order_by
}

"aggregate avg on columns"
type validator_info_avg_fields {
  height: Float
}

"order by avg() on columns of table \"validator_info\""
input validator_info_avg_order_by {
  height: order_by
}

"Boolean expression to filter rows from the table \"validator_info\". All fields are combined with a logical 'AND'."
input validator_info_bool_exp {
  _and: [validator_info_bool_exp!]
  _not: validator_info_bool_exp
  _or: [validator_info_bool_exp!]
  account: account_bool_exp
  consensus_address: String_comparison_exp
  height: bigint_comparison_exp
  max_change_rate: String_comparison_exp
  max_rate: String_comparison_exp
  operator_address: String_comparison_exp
  self_delegate_address: String_comparison_exp
  validator: validator_bool_exp
}

"aggregate max on columns"
type validator_info_max_fields {
  consensus_address: String
  height: bigint
  max_change_rate: String
  max_rate: String
  operator_address: String
  self_delegate_address: String
}

"order by max() on columns of table \"validator_info\""
input validator_info_max_order_by {
  consensus_address: order_by
  height: order_by
  max_change_rate: order_by
  max_rate: order_by
  operator_address: order_by
  self_delegate_address: order_by
}

"aggregate min on columns"
type validator_info_min_fields {
  consensus_address: String
  height: bigint
  max_change_rate: String
  max_rate: String
  operator_address: String
  self_delegate_address: String
}

"order by min() on columns of table \"validator_info\""
input validator_info_min_order_by {
  consensus_address: order_by
  height: order_by
  max_change_rate: order_by
  max_rate: order_by
  operator_address: order_by
  self_delegate_address: order_by
}

"Ordering options when selecting data from \"validator_info\"."
input validator_info_order_by {
  account: account_order_by
  consensus_address: order_by
  height: order_by
  max_change_rate: order_by
  max_rate: order_by
  operator_address: order_by
  self_delegate_address: order_by
  validator: validator_order_by
}

"select columns of table \"validator_info\""
enum validator_info_select_column {
  "column name"
  consensus_address
  "column name"
  height
  "column name"
  max_change_rate
  "column name"
  max_rate
  "column name"
  operator_address
  "column name"
  self_delegate_address
}

"aggregate stddev on columns"
type validator_info_stddev_fields {
  height: Float
}

"order by stddev() on columns of table \"validator_info\""
input validator_info_stddev_order_by {
  height: order_by
}

"aggregate stddev_pop on columns"
type validator_info_stddev_pop_fields {
  height: Float
}

"order by stddev_pop() on columns of table \"validator_info\""
input validator_info_stddev_pop_order_by {
  height: order_by
}

"aggregate stddev_samp on columns"
type validator_info_stddev_samp_fields {
  height: Float
}

"order by stddev_samp() on columns of table \"validator_info\""
input validator_info_stddev_samp_order_by {
  height: order_by
}

"aggregate sum on columns"
type validator_info_sum_fields {
  height: bigint
}

"order by sum() on columns of table \"validator_info\""
input validator_info_sum_order_by {
  height: order_by
}

"aggregate var_pop on columns"
type validator_info_var_pop_fields {
  height: Float
}

"order by var_pop() on columns of table \"validator_info\""
input validator_info_var_pop_order_by {
  height: order_by
}

"aggregate var_samp on columns"
type validator_info_var_samp_fields {
  height: Float
}

"order by var_samp() on columns of table \"validator_info\""
input validator_info_var_samp_order_by {
  height: order_by
}

"aggregate variance on columns"
type validator_info_variance_fields {
  height: Float
}

"order by variance() on columns of table \"validator_info\""
input validator_info_variance_order_by {
  height: order_by
}

"aggregate max on columns"
type validator_max_fields {
  consensus_address: String
  consensus_pubkey: String
}

"aggregate min on columns"
type validator_min_fields {
  consensus_address: String
  consensus_pubkey: String
}

"Ordering options when selecting data from \"validator\"."
input validator_order_by {
  blocks_aggregate: block_aggregate_order_by
  consensus_address: order_by
  consensus_pubkey: order_by
  delegation_rewards_aggregate: delegation_reward_aggregate_order_by
  delegations_aggregate: delegation_aggregate_order_by
  double_sign_votes_aggregate: double_sign_vote_aggregate_order_by
  pre_commits_aggregate: pre_commit_aggregate_order_by
  redelegationsByDstValidatorAddress_aggregate: redelegation_aggregate_order_by
  redelegationsBySrcValidatorAddress_aggregate: redelegation_aggregate_order_by
  unbonding_delegations_aggregate: unbonding_delegation_aggregate_order_by
  validator_commission_amounts_aggregate: validator_commission_amount_aggregate_order_by
  validator_commissions_aggregate: validator_commission_aggregate_order_by
  validator_descriptions_aggregate: validator_description_aggregate_order_by
  validator_info: validator_info_order_by
  validator_infos_aggregate: validator_info_aggregate_order_by
  validator_signing_infos_aggregate: validator_signing_info_aggregate_order_by
  validator_statuses_aggregate: validator_status_aggregate_order_by
  validator_voting_powers_aggregate: validator_voting_power_aggregate_order_by
}

"select columns of table \"validator\""
enum validator_select_column {
  "column name"
  consensus_address
  "column name"
  consensus_pubkey
}

"columns and relationships of \"validator_signing_info\""
type validator_signing_info {
  height: bigint!
  index_offset: bigint!
  jailed_until: timestamp!
  missed_blocks_counter: bigint!
  start_height: bigint!
  tombstoned: Boolean!
  validator_address: String!
}

"aggregated selection of \"validator_signing_info\""
type validator_signing_info_aggregate {
  aggregate: validator_signing_info_aggregate_fields
  nodes: [validator_signing_info!]!
}

"aggregate fields of \"validator_signing_info\""
type validator_signing_info_aggregate_fields {
  avg: validator_signing_info_avg_fields
  count(columns: [validator_signing_info_select_column!] distinct: Boolean): Int!
  max: validator_signing_info_max_fields
  min: validator_signing_info_min_fields
  stddev: validator_signing_info_stddev_fields
  stddev_pop: validator_signing_info_stddev_pop_fields
  stddev_samp: validator_signing_info_stddev_samp_fields
  sum: validator_signing_info_sum_fields
  var_pop: validator_signing_info_var_pop_fields
  var_samp: validator_signing_info_var_samp_fields
  variance: validator_signing_info_variance_fields
}

"order by aggregate values of table \"validator_signing_info\""
input validator_signing_info_aggregate_order_by {
  avg: validator_signing_info_avg_order_by
  count: order_by
  max: validator_signing_info_max_order_by
  min: validator_signing_info_min_order_by
  stddev: validator_signing_info_stddev_order_by
  stddev_pop: validator_signing_info_stddev_pop_order_by
  stddev_samp: validator_signing_info_stddev_samp_order_by
  sum: validator_signing_info_sum_order_by
  var_pop: validator_signing_info_var_pop_order_by
  var_samp: validator_signing_info_var_samp_order_by
  variance: validator_signing_info_variance_order_by
}

"aggregate avg on columns"
type validator_signing_info_avg_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by avg() on columns of table \"validator_signing_info\""
input validator_signing_info_avg_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"Boolean expression to filter rows from the table \"validator_signing_info\". All fields are combined with a logical 'AND'."
input validator_signing_info_bool_exp {
  _and: [validator_signing_info_bool_exp!]
  _not: validator_signing_info_bool_exp
  _or: [validator_signing_info_bool_exp!]
  height: bigint_comparison_exp
  index_offset: bigint_comparison_exp
  jailed_until: timestamp_comparison_exp
  missed_blocks_counter: bigint_comparison_exp
  start_height: bigint_comparison_exp
  tombstoned: Boolean_comparison_exp
  validator_address: String_comparison_exp
}

"aggregate max on columns"
type validator_signing_info_max_fields {
  height: bigint
  index_offset: bigint
  jailed_until: timestamp
  missed_blocks_counter: bigint
  start_height: bigint
  validator_address: String
}

"order by max() on columns of table \"validator_signing_info\""
input validator_signing_info_max_order_by {
  height: order_by
  index_offset: order_by
  jailed_until: order_by
  missed_blocks_counter: order_by
  start_height: order_by
  validator_address: order_by
}

"aggregate min on columns"
type validator_signing_info_min_fields {
  height: bigint
  index_offset: bigint
  jailed_until: timestamp
  missed_blocks_counter: bigint
  start_height: bigint
  validator_address: String
}

"order by min() on columns of table \"validator_signing_info\""
input validator_signing_info_min_order_by {
  height: order_by
  index_offset: order_by
  jailed_until: order_by
  missed_blocks_counter: order_by
  start_height: order_by
  validator_address: order_by
}

"Ordering options when selecting data from \"validator_signing_info\"."
input validator_signing_info_order_by {
  height: order_by
  index_offset: order_by
  jailed_until: order_by
  missed_blocks_counter: order_by
  start_height: order_by
  tombstoned: order_by
  validator_address: order_by
}

"select columns of table \"validator_signing_info\""
enum validator_signing_info_select_column {
  "column name"
  height
  "column name"
  index_offset
  "column name"
  jailed_until
  "column name"
  missed_blocks_counter
  "column name"
  start_height
  "column name"
  tombstoned
  "column name"
  validator_address
}

"aggregate stddev on columns"
type validator_signing_info_stddev_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by stddev() on columns of table \"validator_signing_info\""
input validator_signing_info_stddev_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"aggregate stddev_pop on columns"
type validator_signing_info_stddev_pop_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by stddev_pop() on columns of table \"validator_signing_info\""
input validator_signing_info_stddev_pop_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"aggregate stddev_samp on columns"
type validator_signing_info_stddev_samp_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by stddev_samp() on columns of table \"validator_signing_info\""
input validator_signing_info_stddev_samp_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"aggregate sum on columns"
type validator_signing_info_sum_fields {
  height: bigint
  index_offset: bigint
  missed_blocks_counter: bigint
  start_height: bigint
}

"order by sum() on columns of table \"validator_signing_info\""
input validator_signing_info_sum_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"aggregate var_pop on columns"
type validator_signing_info_var_pop_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by var_pop() on columns of table \"validator_signing_info\""
input validator_signing_info_var_pop_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"aggregate var_samp on columns"
type validator_signing_info_var_samp_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by var_samp() on columns of table \"validator_signing_info\""
input validator_signing_info_var_samp_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"aggregate variance on columns"
type validator_signing_info_variance_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"order by variance() on columns of table \"validator_signing_info\""
input validator_signing_info_variance_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"columns and relationships of \"validator_status\""
type validator_status {
  height: bigint!
  jailed: Boolean!
  status: Int!
  tombstoned: Boolean!
  "An object relationship"
  validator: validator!
  validator_address: String!
}

"aggregated selection of \"validator_status\""
type validator_status_aggregate {
  aggregate: validator_status_aggregate_fields
  nodes: [validator_status!]!
}

"aggregate fields of \"validator_status\""
type validator_status_aggregate_fields {
  avg: validator_status_avg_fields
  count(columns: [validator_status_select_column!] distinct: Boolean): Int!
  max: validator_status_max_fields
  min: validator_status_min_fields
  stddev: validator_status_stddev_fields
  stddev_pop: validator_status_stddev_pop_fields
  stddev_samp: validator_status_stddev_samp_fields
  sum: validator_status_sum_fields
  var_pop: validator_status_var_pop_fields
  var_samp: validator_status_var_samp_fields
  variance: validator_status_variance_fields
}

"order by aggregate values of table \"validator_status\""
input validator_status_aggregate_order_by {
  avg: validator_status_avg_order_by
  count: order_by
  max: validator_status_max_order_by
  min: validator_status_min_order_by
  stddev: validator_status_stddev_order_by
  stddev_pop: validator_status_stddev_pop_order_by
  stddev_samp: validator_status_stddev_samp_order_by
  sum: validator_status_sum_order_by
  var_pop: validator_status_var_pop_order_by
  var_samp: validator_status_var_samp_order_by
  variance: validator_status_variance_order_by
}

"aggregate avg on columns"
type validator_status_avg_fields {
  height: Float
  status: Float
}

"order by avg() on columns of table \"validator_status\""
input validator_status_avg_order_by {
  height: order_by
  status: order_by
}

"Boolean expression to filter rows from the table \"validator_status\". All fields are combined with a logical 'AND'."
input validator_status_bool_exp {
  _and: [validator_status_bool_exp!]
  _not: validator_status_bool_exp
  _or: [validator_status_bool_exp!]
  height: bigint_comparison_exp
  jailed: Boolean_comparison_exp
  status: Int_comparison_exp
  tombstoned: Boolean_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"aggregate max on columns"
type validator_status_max_fields {
  height: bigint
  status: Int
  validator_address: String
}

"order by max() on columns of table \"validator_status\""
input validator_status_max_order_by {
  height: order_by
  status: order_by
  validator_address: order_by
}

"aggregate min on columns"
type validator_status_min_fields {
  height: bigint
  status: Int
  validator_address: String
}

"order by min() on columns of table \"validator_status\""
input validator_status_min_order_by {
  height: order_by
  status: order_by
  validator_address: order_by
}

"Ordering options when selecting data from \"validator_status\"."
input validator_status_order_by {
  height: order_by
  jailed: order_by
  status: order_by
  tombstoned: order_by
  validator: validator_order_by
  validator_address: order_by
}

"select columns of table \"validator_status\""
enum validator_status_select_column {
  "column name"
  height
  "column name"
  jailed
  "column name"
  status
  "column name"
  tombstoned
  "column name"
  validator_address
}

"aggregate stddev on columns"
type validator_status_stddev_fields {
  height: Float
  status: Float
}

"order by stddev() on columns of table \"validator_status\""
input validator_status_stddev_order_by {
  height: order_by
  status: order_by
}

"aggregate stddev_pop on columns"
type validator_status_stddev_pop_fields {
  height: Float
  status: Float
}

"order by stddev_pop() on columns of table \"validator_status\""
input validator_status_stddev_pop_order_by {
  height: order_by
  status: order_by
}

"aggregate stddev_samp on columns"
type validator_status_stddev_samp_fields {
  height: Float
  status: Float
}

"order by stddev_samp() on columns of table \"validator_status\""
input validator_status_stddev_samp_order_by {
  height: order_by
  status: order_by
}

"aggregate sum on columns"
type validator_status_sum_fields {
  height: bigint
  status: Int
}

"order by sum() on columns of table \"validator_status\""
input validator_status_sum_order_by {
  height: order_by
  status: order_by
}

"aggregate var_pop on columns"
type validator_status_var_pop_fields {
  height: Float
  status: Float
}

"order by var_pop() on columns of table \"validator_status\""
input validator_status_var_pop_order_by {
  height: order_by
  status: order_by
}

"aggregate var_samp on columns"
type validator_status_var_samp_fields {
  height: Float
  status: Float
}

"order by var_samp() on columns of table \"validator_status\""
input validator_status_var_samp_order_by {
  height: order_by
  status: order_by
}

"aggregate variance on columns"
type validator_status_variance_fields {
  height: Float
  status: Float
}

"order by variance() on columns of table \"validator_status\""
input validator_status_variance_order_by {
  height: order_by
  status: order_by
}

"columns and relationships of \"validator_voting_power\""
type validator_voting_power {
  height: bigint!
  "An object relationship"
  validator: validator!
  validator_address: String!
  voting_power: bigint!
}

"aggregated selection of \"validator_voting_power\""
type validator_voting_power_aggregate {
  aggregate: validator_voting_power_aggregate_fields
  nodes: [validator_voting_power!]!
}

"aggregate fields of \"validator_voting_power\""
type validator_voting_power_aggregate_fields {
  avg: validator_voting_power_avg_fields
  count(columns: [validator_voting_power_select_column!] distinct: Boolean): Int!
  max: validator_voting_power_max_fields
  min: validator_voting_power_min_fields
  stddev: validator_voting_power_stddev_fields
  stddev_pop: validator_voting_power_stddev_pop_fields
  stddev_samp: validator_voting_power_stddev_samp_fields
  sum: validator_voting_power_sum_fields
  var_pop: validator_voting_power_var_pop_fields
  var_samp: validator_voting_power_var_samp_fields
  variance: validator_voting_power_variance_fields
}

"order by aggregate values of table \"validator_voting_power\""
input validator_voting_power_aggregate_order_by {
  avg: validator_voting_power_avg_order_by
  count: order_by
  max: validator_voting_power_max_order_by
  min: validator_voting_power_min_order_by
  stddev: validator_voting_power_stddev_order_by
  stddev_pop: validator_voting_power_stddev_pop_order_by
  stddev_samp: validator_voting_power_stddev_samp_order_by
  sum: validator_voting_power_sum_order_by
  var_pop: validator_voting_power_var_pop_order_by
  var_samp: validator_voting_power_var_samp_order_by
  variance: validator_voting_power_variance_order_by
}

"aggregate avg on columns"
type validator_voting_power_avg_fields {
  height: Float
  voting_power: Float
}

"order by avg() on columns of table \"validator_voting_power\""
input validator_voting_power_avg_order_by {
  height: order_by
  voting_power: order_by
}

"Boolean expression to filter rows from the table \"validator_voting_power\". All fields are combined with a logical 'AND'."
input validator_voting_power_bool_exp {
  _and: [validator_voting_power_bool_exp!]
  _not: validator_voting_power_bool_exp
  _or: [validator_voting_power_bool_exp!]
  height: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  voting_power: bigint_comparison_exp
}

"aggregate max on columns"
type validator_voting_power_max_fields {
  height: bigint
  validator_address: String
  voting_power: bigint
}

"order by max() on columns of table \"validator_voting_power\""
input validator_voting_power_max_order_by {
  height: order_by
  validator_address: order_by
  voting_power: order_by
}

"aggregate min on columns"
type validator_voting_power_min_fields {
  height: bigint
  validator_address: String
  voting_power: bigint
}

"order by min() on columns of table \"validator_voting_power\""
input validator_voting_power_min_order_by {
  height: order_by
  validator_address: order_by
  voting_power: order_by
}

"Ordering options when selecting data from \"validator_voting_power\"."
input validator_voting_power_order_by {
  height: order_by
  validator: validator_order_by
  validator_address: order_by
  voting_power: order_by
}

"select columns of table \"validator_voting_power\""
enum validator_voting_power_select_column {
  "column name"
  height
  "column name"
  validator_address
  "column name"
  voting_power
}

"aggregate stddev on columns"
type validator_voting_power_stddev_fields {
  height: Float
  voting_power: Float
}

"order by stddev() on columns of table \"validator_voting_power\""
input validator_voting_power_stddev_order_by {
  height: order_by
  voting_power: order_by
}

"aggregate stddev_pop on columns"
type validator_voting_power_stddev_pop_fields {
  height: Float
  voting_power: Float
}

"order by stddev_pop() on columns of table \"validator_voting_power\""
input validator_voting_power_stddev_pop_order_by {
  height: order_by
  voting_power: order_by
}

"aggregate stddev_samp on columns"
type validator_voting_power_stddev_samp_fields {
  height: Float
  voting_power: Float
}

"order by stddev_samp() on columns of table \"validator_voting_power\""
input validator_voting_power_stddev_samp_order_by {
  height: order_by
  voting_power: order_by
}

"aggregate sum on columns"
type validator_voting_power_sum_fields {
  height: bigint
  voting_power: bigint
}

"order by sum() on columns of table \"validator_voting_power\""
input validator_voting_power_sum_order_by {
  height: order_by
  voting_power: order_by
}

"aggregate var_pop on columns"
type validator_voting_power_var_pop_fields {
  height: Float
  voting_power: Float
}

"order by var_pop() on columns of table \"validator_voting_power\""
input validator_voting_power_var_pop_order_by {
  height: order_by
  voting_power: order_by
}

"aggregate var_samp on columns"
type validator_voting_power_var_samp_fields {
  height: Float
  voting_power: Float
}

"order by var_samp() on columns of table \"validator_voting_power\""
input validator_voting_power_var_samp_order_by {
  height: order_by
  voting_power: order_by
}

"aggregate variance on columns"
type validator_voting_power_variance_fields {
  height: Float
  voting_power: Float
}

"order by variance() on columns of table \"validator_voting_power\""
input validator_voting_power_variance_order_by {
  height: order_by
  voting_power: order_by
}

"columns and relationships of \"vesting_account\""
type vesting_account {
  "An object relationship"
  account: account!
  address: String!
  end_time: timestamp!
  id: Int!
  original_vesting: _coin!
  start_time: timestamp
  type: String!
  "An array relationship"
  vesting_periods("distinct select on columns" distinct_on: [vesting_period_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_period_order_by!] "filter the rows returned" where: vesting_period_bool_exp): [vesting_period!]!
  "An aggregate relationship"
  vesting_periods_aggregate("distinct select on columns" distinct_on: [vesting_period_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [vesting_period_order_by!] "filter the rows returned" where: vesting_period_bool_exp): vesting_period_aggregate!
}

"aggregated selection of \"vesting_account\""
type vesting_account_aggregate {
  aggregate: vesting_account_aggregate_fields
  nodes: [vesting_account!]!
}

"aggregate fields of \"vesting_account\""
type vesting_account_aggregate_fields {
  avg: vesting_account_avg_fields
  count(columns: [vesting_account_select_column!] distinct: Boolean): Int!
  max: vesting_account_max_fields
  min: vesting_account_min_fields
  stddev: vesting_account_stddev_fields
  stddev_pop: vesting_account_stddev_pop_fields
  stddev_samp: vesting_account_stddev_samp_fields
  sum: vesting_account_sum_fields
  var_pop: vesting_account_var_pop_fields
  var_samp: vesting_account_var_samp_fields
  variance: vesting_account_variance_fields
}

"aggregate avg on columns"
type vesting_account_avg_fields {
  id: Float
}

"Boolean expression to filter rows from the table \"vesting_account\". All fields are combined with a logical 'AND'."
input vesting_account_bool_exp {
  _and: [vesting_account_bool_exp!]
  _not: vesting_account_bool_exp
  _or: [vesting_account_bool_exp!]
  account: account_bool_exp
  address: String_comparison_exp
  end_time: timestamp_comparison_exp
  id: Int_comparison_exp
  original_vesting: _coin_comparison_exp
  start_time: timestamp_comparison_exp
  type: String_comparison_exp
  vesting_periods: vesting_period_bool_exp
}

"aggregate max on columns"
type vesting_account_max_fields {
  address: String
  end_time: timestamp
  id: Int
  start_time: timestamp
  type: String
}

"aggregate min on columns"
type vesting_account_min_fields {
  address: String
  end_time: timestamp
  id: Int
  start_time: timestamp
  type: String
}

"Ordering options when selecting data from \"vesting_account\"."
input vesting_account_order_by {
  account: account_order_by
  address: order_by
  end_time: order_by
  id: order_by
  original_vesting: order_by
  start_time: order_by
  type: order_by
  vesting_periods_aggregate: vesting_period_aggregate_order_by
}

"select columns of table \"vesting_account\""
enum vesting_account_select_column {
  "column name"
  address
  "column name"
  end_time
  "column name"
  id
  "column name"
  original_vesting
  "column name"
  start_time
  "column name"
  type
}

"aggregate stddev on columns"
type vesting_account_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type vesting_account_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type vesting_account_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type vesting_account_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type vesting_account_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type vesting_account_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type vesting_account_variance_fields {
  id: Float
}

"columns and relationships of \"vesting_period\""
type vesting_period {
  amount: _coin!
  length: bigint!
  period_order: bigint!
  "An object relationship"
  vesting_account: vesting_account!
  vesting_account_id: bigint!
}

"aggregated selection of \"vesting_period\""
type vesting_period_aggregate {
  aggregate: vesting_period_aggregate_fields
  nodes: [vesting_period!]!
}

"aggregate fields of \"vesting_period\""
type vesting_period_aggregate_fields {
  avg: vesting_period_avg_fields
  count(columns: [vesting_period_select_column!] distinct: Boolean): Int!
  max: vesting_period_max_fields
  min: vesting_period_min_fields
  stddev: vesting_period_stddev_fields
  stddev_pop: vesting_period_stddev_pop_fields
  stddev_samp: vesting_period_stddev_samp_fields
  sum: vesting_period_sum_fields
  var_pop: vesting_period_var_pop_fields
  var_samp: vesting_period_var_samp_fields
  variance: vesting_period_variance_fields
}

"order by aggregate values of table \"vesting_period\""
input vesting_period_aggregate_order_by {
  avg: vesting_period_avg_order_by
  count: order_by
  max: vesting_period_max_order_by
  min: vesting_period_min_order_by
  stddev: vesting_period_stddev_order_by
  stddev_pop: vesting_period_stddev_pop_order_by
  stddev_samp: vesting_period_stddev_samp_order_by
  sum: vesting_period_sum_order_by
  var_pop: vesting_period_var_pop_order_by
  var_samp: vesting_period_var_samp_order_by
  variance: vesting_period_variance_order_by
}

"aggregate avg on columns"
type vesting_period_avg_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by avg() on columns of table \"vesting_period\""
input vesting_period_avg_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"Boolean expression to filter rows from the table \"vesting_period\". All fields are combined with a logical 'AND'."
input vesting_period_bool_exp {
  _and: [vesting_period_bool_exp!]
  _not: vesting_period_bool_exp
  _or: [vesting_period_bool_exp!]
  amount: _coin_comparison_exp
  length: bigint_comparison_exp
  period_order: bigint_comparison_exp
  vesting_account: vesting_account_bool_exp
  vesting_account_id: bigint_comparison_exp
}

"aggregate max on columns"
type vesting_period_max_fields {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"order by max() on columns of table \"vesting_period\""
input vesting_period_max_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate min on columns"
type vesting_period_min_fields {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"order by min() on columns of table \"vesting_period\""
input vesting_period_min_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"Ordering options when selecting data from \"vesting_period\"."
input vesting_period_order_by {
  amount: order_by
  length: order_by
  period_order: order_by
  vesting_account: vesting_account_order_by
  vesting_account_id: order_by
}

"select columns of table \"vesting_period\""
enum vesting_period_select_column {
  "column name"
  amount
  "column name"
  length
  "column name"
  period_order
  "column name"
  vesting_account_id
}

"aggregate stddev on columns"
type vesting_period_stddev_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by stddev() on columns of table \"vesting_period\""
input vesting_period_stddev_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate stddev_pop on columns"
type vesting_period_stddev_pop_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by stddev_pop() on columns of table \"vesting_period\""
input vesting_period_stddev_pop_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate stddev_samp on columns"
type vesting_period_stddev_samp_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by stddev_samp() on columns of table \"vesting_period\""
input vesting_period_stddev_samp_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate sum on columns"
type vesting_period_sum_fields {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"order by sum() on columns of table \"vesting_period\""
input vesting_period_sum_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate var_pop on columns"
type vesting_period_var_pop_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by var_pop() on columns of table \"vesting_period\""
input vesting_period_var_pop_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate var_samp on columns"
type vesting_period_var_samp_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by var_samp() on columns of table \"vesting_period\""
input vesting_period_var_samp_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"aggregate variance on columns"
type vesting_period_variance_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"order by variance() on columns of table \"vesting_period\""
input vesting_period_variance_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached("measured in seconds" ttl: Int! = 60 "refresh the cache entry" refresh: Boolean! = false) on QUERY